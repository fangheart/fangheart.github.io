<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[数据库索引以及mysql中的数据库引擎]]></title>
      <url>%2F2017%2F06%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E%2F</url>
      <content type="text"><![CDATA[数据库引擎数据库中的存储引擎其实是对使用了该引擎的表进行某种设置，数据库中的表设定了什么存储引擎，那么该表在数据存储方式、数据更新方式、数据查询性能以及是否支持索引等方面就会有不同的“效果”。在MySQL数据库中存在着多种引擎（不同版本的MySQL数据库支持的引擎不同），熟悉各种引擎才能在软件开发中应用引擎，从而开发出高性能的软件，MySQL数据库中的引擎有哪些呢？一般来说，MySQL有以下几种引擎：ISAM、MyISAM、HEAP（也称为MEMORY）、CSV、BLACKHOLE、ARCHIVE、PERFORMANCE_SCHEMA、InnoDB、 Berkeley、Merge、Federated和Cluster/NDB等，除此以外我们也可以参照MySQL++ API创建自己的数据库引擎。下面逐次介绍一下各种引擎： ISAM该引擎在读取数据方面速度很快，而且不占用大量的内存和存储资源；但是ISAM不支持事务处理、不支持外来键、不能够容错、也不支持索引。该引擎在包括MySQL 5.1及其以上版本的数据库中不再支持。 MyISAM该引擎基于ISAM数据库引擎，除了提供ISAM里所没有的索引和字段管理等大量功能，MyISAM还使用一种表格锁定的机制来优化多个并发的读写操作，但是需要经常运行OPTIMIZE TABLE命令，来恢复被更新机制所浪费的空间，否则碎片也会随之增加，最终影响数据访问性能。MyISAM还有一些有用的扩展，例如用来修复数据库文件的MyISAMChk工具和用来恢复浪费空间的 MyISAMPack工具。MyISAM强调了快速读取操作，主要用于高负载的select，这可能也是MySQL深受Web开发的主要原因：在Web开发中进行的大量数据操作都是读取操作，所以大多数虚拟主机提供商和Internet平台提供商（Internet Presence Provider，IPP）只允许使用MyISAM格式。MyISAM类型的表支持三种不同的存储结构：静态型、动态型、压缩型。静态型：指定义的表列的大小是固定（即不含有：xblob、xtext、varchar等长度可变的数据类型），这样MySQL就会自动使用静态MyISAM格式。使用静态格式的表的性能比较高，因为在维护和访问以预定格式存储数据时需要的开销很低；但这种高性能是以空间为代价换来的，因为在定义的时候是固定的，所以不管列中的值有多大，都会以最大值为准，占据了整个空间。动态型：如果列（即使只有一列）定义为动态的（xblob, xtext, varchar等数据类型），这时MyISAM就自动使用动态型，虽然动态型的表占用了比静态型表较少的空间，但带来了性能的降低，因为如果某个字段的内容发生改变则其位置很可能需要移动，这样就会导致碎片的产生，随着数据变化的增多，碎片也随之增加，数据访问性能会随之降低。对于因碎片增加而降低数据访问性这个问题，有两种解决办法：a、尽可能使用静态数据类型；b、经常使用optimize table table_name语句整理表的碎片，恢复由于表数据的更新和删除导致的空间丢失。如果存储引擎不支持 optimize table table_name则可以转储并 重新加载数据，这样也可以减少碎片；压缩型：如果在数据库中创建在整个生命周期内只读的表，则应该使用MyISAM的压缩型表来减少空间的占用。 Merge该引擎将一定数量的MyISAM表联合而成一个整体。 HEAP（也称为MEMORY）该存储引擎通过在内存中创建临时表来存储数据。每个基于该存储引擎的表实际对应一个磁盘文件，该文件的文件名和表名是相同的，类型为.frm。该磁盘文件只存储表的结构，而其数据存储在内存中，所以使用该种引擎的表拥有极高的插入、更新和查询效率。这种存储引擎默认使用哈希（HASH）索引，其速度比使用B-+Tree型要快，但也可以使用B树型索引。由于这种存储引擎所存储的数据保存在内存中，所以其保存的数据具有不稳定性，比如如果mysqld进程发生异常、重启或计算机关机等等都会造成这些数据的消失，所以这种存储引擎中的表的生命周期很短，一般只使用一次。 CSV（Comma-Separated Values逗号分隔值）使用该引擎的MySQL数据库表会在MySQL安装目录data文件夹中的和该表所在数据库名相同的目录中生成一个.CSV文件（所以，它可以将CSV类型的文件当做表进行处理），这种文件是一种普通文本文件，每个数据行占用一个文本行。该种类型的存储引擎不支持索引，即使用该种类型的表没有主键列；另外也不允许表中的字段为null。 BLACKHOLE（黑洞引擎）该存储引擎支持事务，而且支持mvcc的行级锁，写入这种引擎表中的任何数据都会消失，主要用于做日志记录或同步归档的中继存储，这个存储引擎除非有特别目的，否则不适合使用。详见博客《BlackHole 存储引擎》 Berkeley（BDB）该存储引擎支持COMMIT和ROLLBACK等其他事务特性。该引擎在包括MySQL 5.1及其以上版本的数据库中不再支持。 Federated该存储引擎可以不同的Mysql服务器联合起来，逻辑上组成一个完整的数据库。这种存储引擎非常适合数据库分布式应用。 Cluster/NDB该存储引擎用于多台数据机器联合提供服务以提高整体性能和安全性。适合数据量大、安全和性能要求高的场景。 PERFORMANCE_SCHEMA该引擎主要用于收集数据库服务器性能参数。这种引擎提供以下功能：提供进程等待的详细信息，包括锁、互斥变量、文件信息；保存历史的事件汇总信息，为提供MySQL服务器性能做出详细的判断；对于新增和删除监控事件点都非常容易，并可以随意改变mysql服务器的监控周期，例如（CYCLE、MICROSECOND）。 ARCHIVE该存储引擎非常适合存储大量独立的、作为历史记录的数据。区别于InnoDB和MyISAM这两种引擎，ARCHIVE提供了压缩功能，拥有高效的插入速度，但是这种引擎不支持索引，所以查询性能较差一些。 InnoDB该存储引擎为MySQL表提供了ACID事务支持、系统崩溃修复能力和多版本并发控制（即MVCC Multi-Version Concurrency Control）的行级锁;该引擎支持自增长列（auto_increment）,自增长列的值不能为空，如果在使用的时候为空则自动从现有值开始增值，如果有但是比现在的还大，则直接保存这个值; 该引擎存储引擎支持外键（foreign key）,外键所在的表称为子表而所依赖的表称为父表。该引擎在5.5后的MySQL数据库中为默认存储引擎。 数据库索引索引的定义索引问题就是一个查找问题**数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。在数据之外，数据库系统还维护着满足特定查找算法的数据结构*¡，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。 索引的优缺点创建索引可以大大提高系统的性能。第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。 也许会有人要问：增加索引有如此多的优点，为什么不对表中的每一个列创建一个索引呢？因为，增加索引也有许多不利的方面。第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引创建的选择索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。应该在这些列上创建索引：在经常需要搜索的列上，可以加快搜索的速度；在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 同样，对于有些列不应该创建索引。不应该创建索引的的这些列具有下列特点：第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 索引的类型根据数据库的功能，可以在数据库设计器中创建三种索引：唯一索引、主键索引和聚集索引。 唯一索引唯一索引是不允许其中任何两行具有相同索引值的索引。当现有数据中存在重复的键值时，大多数数据库不允许将新创建的唯一索引与表一起保存。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在employee表中职员的姓(lname)上创建了唯一索引，则任何两个员工都不能同姓。 主键索引数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型。该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。 聚集索引在聚集索引中，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。如果某索引不是聚集索引，则表中行的物理顺序与键值的逻辑顺序不匹配。与非聚集索引相比，聚集索引通常提供更快的数据访问速度。 局部性原理与磁盘预读由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。 B-/+Tree索引的性能分析到这里终于可以分析B-/+Tree索引的性能了。上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。 综上所述，用B-Tree作为索引结构效率是非常高的。 索引树的介绍B树即二叉搜索树：1.所有非叶子结点至多拥有两个儿子（Left和Right）；2.所有结点存储一个关键字；3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；如：B树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；如果B树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变B树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；如： 但B树在经过多次插入与删除后，有可能导致不同的结构： 右边也是一个B树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的树结构索引；所以，使用B树还要考虑尽可能让B树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；实际使用的B树都是在原B树的基础上加上平衡算法，即“平衡二叉树”；如何保持B树结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在B树中插入和删除结点的策略； B-树是一种多路搜索树（并不是二叉的）：1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；2.根结点的儿子数为[2, M]；3.除根结点以外的非叶子结点的儿子数为[M/2, M]；4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）5.非叶子结点的关键字个数=指向儿子的指针个数-1；6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；8.所有叶子结点位于同一层；如：（M=3） B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；B-树的特性：1.关键字集合分布在整颗树中；2.任何一个关键字出现且只出现在一个结点中；3.搜索有可能在非叶子结点结束；4.其搜索性能等价于在关键字全集内做一次二分查找；5.自动层次控制；由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为：其中，M为设定的非叶子结点最多子树个数，N为关键字总数；所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题；由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并； B+树B+树是B-树的变体，也是一种多路搜索树：1.其定义基本与B-树同，除了：2.非叶子结点的子树指针与关键字个数相同；3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；5.为所有叶子结点增加一个链指针；6.所有关键字都在叶子结点出现；如：（M=3）B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；B+的特性：1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；2.不可能在非叶子结点命中；3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；4.更适合文件索引系统； B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；B树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3（代替B+树的1/2）；B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；B树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；所以，B树分配新结点的概率比B+树要低，空间使用率更高； 小结B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习模型使用技巧、特征提升、模型正则化 、模型校验、超参数搜索]]></title>
      <url>%2F2017%2F06%2F20%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E3%80%81%E7%89%B9%E5%BE%81%E6%8F%90%E5%8D%87%E3%80%81%E6%A8%A1%E5%9E%8B%E6%AD%A3%E5%88%99%E5%8C%96-%E3%80%81%E6%A8%A1%E5%9E%8B%E6%A0%A1%E9%AA%8C%E3%80%81%E8%B6%85%E5%8F%82%E6%95%B0%E6%90%9C%E7%B4%A2%2F</url>
      <content type="text"><![CDATA[3.1 模型使用技巧通常情况下，并不能保证：1.所有用于训练的数据特征都是最好的2.学习得到的参数一定是最优的3.默认配置下的模型总是最佳的所以提升模型的性能很关键，这其中通常包括预处理数据、控制参数训练以及优化模型的配置等方法。 3.1.1 特征提升我们通常希望对数据特征的抽取或者筛选出来达到提升模型性能的目的。所谓的特征抽取，就是逐条将原始数据转换为特征向量的形式，这个过程同时设计对数据特征的量化表示；而特征筛选则更进一步，在高纬度、以量化的特征向量中选择对指定任务更有效的特征组合，进一步提升模型性能。 3.1.1.1 特征抽取原始数据的种类有很多种，除了数字化的信息数据，还有大量的符号化的文本，然而我们无法直接将符号化的文本本身用于计算任务，而是需要通过某些处理手段，预先将文本量化为特征向量。 有些用符号表示的数据特征已经相对的机构化了，并用字典这种数据结构进行存储，这时，我们可以使用DictVectorizer对特征进行抽取和向量化。12345678910111213141516# DictVectorizer对使用字典存储的数据进行特征抽取与向量化# 定义一组字典列表，用来表示多个数据样本（每个字典代表一个数据样本）。measurements = [&#123;'city': 'Dubai', 'temperature': 33.&#125;, &#123;'city': 'London', 'temperature': 12.&#125;, &#123;'city': 'San Fransisco', 'temperature': 18.&#125;]# 从sklearn.feature_extraction 导入 DictVectorizerfrom sklearn.feature_extraction import DictVectorizer# 初始化DictVectorizer特征抽取器vec = DictVectorizer()# 输出转化之后的特征矩阵。print vec.fit_transform(measurements).toarray()# 输出各个维度的特征含义。print vec.get_feature_names() [[ 1. 0. 0. 33.] [ 0. 1. 0. 12.] [ 0. 0. 1. 18.]] ['city=Dubai', 'city=London', 'city=San Fransisco', 'temperature'] 由上述代码可知，DictVectorizer对于类别型与数值型特征的处理方式由很大的差异。由于类别性特征无法直接数字化显示，因此需要借助原特征的名称，组合产生新的特征并采用0/1的二值方式进行量化，而数值型的特征转换则相对方便，一般情况下只需要维持原始特征值即可。 如果是村文本形式的存储，都是一系列的字符串，处理这些数据的时候常用的文本特征表示方法为词袋法，不考虑词语的出现顺序，只是将训练文本中的每个出现过的词汇单独的视作一列特征，我们称这些不重复的词汇集合为词表。于是每条训练文本都可以在高纬度的词表上映射出一个特征向量。而特征数值的常见计算方式为2种，分别是： CountVectorizer和TfidiVectorizer，对于每一条训练文本，CountVectorizer只考虑每种词汇在该条训练文本中出现的频率，而TfidiVectorizer除了考量某一词汇在当前文本中出现的频率之外，同时关注包含这个词汇的文本数条数的倒数（Inverse Document Frequency）。相比之下训练文本的条数越多，TfidiVectorizer这种特征量化方式就更有优势。因为我们的目的就是找出所在的文本含义更有贡献的重要词汇。如果一个词几乎在每个文本中都要出现，说明这是一个常用的词汇，反而不会帮助模型对文本的分类，在训练文本量较多的时候，利用TfidiVectorizer压制这些常用词汇对分类决策的干扰，往往可以起到提高模型性能的作用。 我们通常称这些在每条文本中都出现的常用词汇为停用词（Stop Words）,如英文中的the、a等。这些停用词在文本特征抽取中经常以黑名单的方式过滤掉，并且提高模型的性能表现。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# 使用CountVectorizer并且不去掉停用词的条件下，对文本特征进行量化的朴素贝叶斯分类性能测试## sklearn.datasets里导入20类新闻文本数据抓取器。from sklearn.datasets import fetch_20newsgroups# 从互联网上即时下载新闻样本,subset='all'参数代表下载全部近2万条文本存储在变量news中。news = fetch_20newsgroups(subset='all')# 从sklearn.cross_validation导入train_test_split模块用于分割数据集。from sklearn.cross_validation import train_test_split# 对news中的数据data进行分割，25%的文本用作测试集；75%作为训练集。X_train, X_test, y_train, y_test = train_test_split(news.data, news.target, test_size=0.25, random_state=33)# 从sklearn.feature_extraction.text里导入CountVectorizerfrom sklearn.feature_extraction.text import CountVectorizer# 采用默认的配置对CountVectorizer进行初始化（默认配置不去除英文停用词），并且赋值给变量count_vec。count_vec = CountVectorizer()# 只使用词频统计的方式将原始训练和测试文本转化为特征向量。X_count_train = count_vec.fit_transform(X_train)X_count_test = count_vec.transform(X_test)# 从sklearn.naive_bayes里导入朴素贝叶斯分类器。from sklearn.naive_bayes import MultinomialNB# 使用默认的配置对分类器进行初始化。mnb_count = MultinomialNB()# 使用朴素贝叶斯分类器，对CountVectorizer（不去除停用词）后的训练样本进行参数学习。mnb_count.fit(X_count_train, y_train)# 输出模型准确性结果。print 'The accuracy of classifying 20newsgroups using Naive Bayes (CountVectorizer without filtering stopwords):', mnb_count.score(X_count_test, y_test)# 将分类预测的结果存储在变量y_count_predict中。y_count_predict = mnb_count.predict(X_count_test)# 从sklearn.metrics 导入 classification_report。from sklearn.metrics import classification_report# 输出更加详细的其他评价分类性能的指标。print classification_report(y_test, y_count_predict, target_names = news.target_names) The accuracy of classifying 20newsgroups using Naive Bayes (CountVectorizer without filtering stopwords): 0.839770797963 precision recall f1-score support alt.atheism 0.86 0.86 0.86 201 comp.graphics 0.59 0.86 0.70 250 comp.os.ms-windows.misc 0.89 0.10 0.17 248comp.sys.ibm.pc.hardware 0.60 0.88 0.72 240 comp.sys.mac.hardware 0.93 0.78 0.85 242 comp.windows.x 0.82 0.84 0.83 263 misc.forsale 0.91 0.70 0.79 257 rec.autos 0.89 0.89 0.89 238 rec.motorcycles 0.98 0.92 0.95 276 rec.sport.baseball 0.98 0.91 0.95 251 rec.sport.hockey 0.93 0.99 0.96 233 sci.crypt 0.86 0.98 0.91 238 sci.electronics 0.85 0.88 0.86 249 sci.med 0.92 0.94 0.93 245 sci.space 0.89 0.96 0.92 221 soc.religion.christian 0.78 0.96 0.86 232 talk.politics.guns 0.88 0.96 0.92 251 talk.politics.mideast 0.90 0.98 0.94 231 talk.politics.misc 0.79 0.89 0.84 188 talk.religion.misc 0.93 0.44 0.60 158 avg / total 0.86 0.84 0.82 4712 123456789101112131415161718192021222324252627282930313233343536373839404142# 使用TfidiVectorizer并且不去掉停用词的条件下，对文本特征进行量化的朴素贝叶斯分类性能测试# 从sklearn.feature_extraction.text里分别导入TfidfVectorizer。from sklearn.feature_extraction.text import TfidfVectorizer# 采用默认的配置对TfidfVectorizer进行初始化（默认配置不去除英文停用词），并且赋值给变量tfidf_vec。tfidf_vec = TfidfVectorizer()# 使用tfidf的方式，将原始训练和测试文本转化为特征向量。X_tfidf_train = tfidf_vec.fit_transform(X_train)X_tfidf_test = tfidf_vec.transform(X_test)# 依然使用默认配置的朴素贝叶斯分类器，在相同的训练和测试数据上，对新的特征量化方式进行性能评估。mnb_tfidf = MultinomialNB()mnb_tfidf.fit(X_tfidf_train, y_train)print 'The accuracy of classifying 20newsgroups with Naive Bayes (TfidfVectorizer without filtering stopwords):', mnb_tfidf.score(X_tfidf_test, y_test)y_tfidf_predict = mnb_tfidf.predict(X_tfidf_test)print classification_report(y_test, y_tfidf_predict, target_names = news.target_names) The accuracy of classifying 20newsgroups with Naive Bayes (TfidfVectorizer without filtering stopwords): 0.846349745331 precision recall f1-score support alt.atheism 0.84 0.67 0.75 201 comp.graphics 0.85 0.74 0.79 250 comp.os.ms-windows.misc 0.82 0.85 0.83 248comp.sys.ibm.pc.hardware 0.76 0.88 0.82 240 comp.sys.mac.hardware 0.94 0.84 0.89 242 comp.windows.x 0.96 0.84 0.89 263 misc.forsale 0.93 0.69 0.79 257 rec.autos 0.84 0.92 0.88 238 rec.motorcycles 0.98 0.92 0.95 276 rec.sport.baseball 0.96 0.91 0.94 251 rec.sport.hockey 0.88 0.99 0.93 233 sci.crypt 0.73 0.98 0.83 238 sci.electronics 0.91 0.83 0.87 249 sci.med 0.97 0.92 0.95 245 sci.space 0.89 0.96 0.93 221 soc.religion.christian 0.51 0.97 0.67 232 talk.politics.guns 0.83 0.96 0.89 251 talk.politics.mideast 0.92 0.97 0.95 231 talk.politics.misc 0.98 0.62 0.76 188 talk.religion.misc 0.93 0.16 0.28 158 avg / total 0.87 0.85 0.84 4712 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# 使用CountVectorizer和TfidiVectorizer并且去掉停用词的条件下，对文本特征进行量化的朴素贝叶斯分类性能测试# 继续沿用代码56与代码57中导入的工具包（在同一份源代码中，或者不关闭解释器环境），分别使用停用词过滤配置初始化CountVectorizer与TfidfVectorizer。count_filter_vec, tfidf_filter_vec = CountVectorizer(analyzer='word', stop_words='english'), TfidfVectorizer(analyzer='word', stop_words='english')# 使用带有停用词过滤的CountVectorizer对训练和测试文本分别进行量化处理。X_count_filter_train = count_filter_vec.fit_transform(X_train)X_count_filter_test = count_filter_vec.transform(X_test)# 使用带有停用词过滤的TfidfVectorizer对训练和测试文本分别进行量化处理。X_tfidf_filter_train = tfidf_filter_vec.fit_transform(X_train)X_tfidf_filter_test = tfidf_filter_vec.transform(X_test)# 初始化默认配置的朴素贝叶斯分类器，并对CountVectorizer后的数据进行预测与准确性评估。mnb_count_filter = MultinomialNB()mnb_count_filter.fit(X_count_filter_train, y_train)print 'The accuracy of classifying 20newsgroups using Naive Bayes (CountVectorizer by filtering stopwords):', mnb_count_filter.score(X_count_filter_test, y_test)y_count_filter_predict = mnb_count_filter.predict(X_count_filter_test)# 初始化另一个默认配置的朴素贝叶斯分类器，并对TfidfVectorizer后的数据进行预测与准确性评估。mnb_tfidf_filter = MultinomialNB()mnb_tfidf_filter.fit(X_tfidf_filter_train, y_train)print 'The accuracy of classifying 20newsgroups with Naive Bayes (TfidfVectorizer by filtering stopwords):', mnb_tfidf_filter.score(X_tfidf_filter_test, y_test)y_tfidf_filter_predict = mnb_tfidf_filter.predict(X_tfidf_filter_test)# 对上述两个模型进行更加详细的性能评估。from sklearn.metrics import classification_reportprint classification_report(y_test, y_count_filter_predict, target_names = news.target_names)print classification_report(y_test, y_tfidf_filter_predict, target_names = news.target_names) The accuracy of classifying 20newsgroups using Naive Bayes (CountVectorizer by filtering stopwords): 0.863752122241The accuracy of classifying 20newsgroups with Naive Bayes (TfidfVectorizer by filtering stopwords): 0.882640067912 precision recall f1-score support alt.atheism 0.85 0.89 0.87 201 comp.graphics 0.62 0.88 0.73 250 comp.os.ms-windows.misc 0.93 0.22 0.36 248comp.sys.ibm.pc.hardware 0.62 0.88 0.73 240 comp.sys.mac.hardware 0.93 0.85 0.89 242 comp.windows.x 0.82 0.85 0.84 263 misc.forsale 0.90 0.79 0.84 257 rec.autos 0.91 0.91 0.91 238 rec.motorcycles 0.98 0.94 0.96 276 rec.sport.baseball 0.98 0.92 0.95 251 rec.sport.hockey 0.92 0.99 0.95 233 sci.crypt 0.91 0.97 0.93 238 sci.electronics 0.87 0.89 0.88 249 sci.med 0.94 0.95 0.95 245 sci.space 0.91 0.96 0.93 221 soc.religion.christian 0.87 0.94 0.90 232 talk.politics.guns 0.89 0.96 0.93 251 talk.politics.mideast 0.95 0.98 0.97 231 talk.politics.misc 0.84 0.90 0.87 188 talk.religion.misc 0.91 0.53 0.67 158 avg / total 0.88 0.86 0.85 4712 precision recall f1-score support alt.atheism 0.86 0.81 0.83 201 comp.graphics 0.85 0.81 0.83 250 comp.os.ms-windows.misc 0.84 0.87 0.86 248comp.sys.ibm.pc.hardware 0.78 0.88 0.83 240 comp.sys.mac.hardware 0.92 0.90 0.91 242 comp.windows.x 0.95 0.88 0.91 263 misc.forsale 0.90 0.80 0.85 257 rec.autos 0.89 0.92 0.90 238 rec.motorcycles 0.98 0.94 0.96 276 rec.sport.baseball 0.97 0.93 0.95 251 rec.sport.hockey 0.88 0.99 0.93 233 sci.crypt 0.85 0.98 0.91 238 sci.electronics 0.93 0.86 0.89 249 sci.med 0.96 0.93 0.95 245 sci.space 0.90 0.97 0.93 221 soc.religion.christian 0.70 0.96 0.81 232 talk.politics.guns 0.84 0.98 0.90 251 talk.politics.mideast 0.92 0.99 0.95 231 talk.politics.misc 0.97 0.74 0.84 188 talk.religion.misc 0.96 0.29 0.45 158 avg / total 0.89 0.88 0.88 4712 从上面可以知道使用TdifiCectorizer比CountVectorizer在不去掉停用词的时候，对训练和测试文本就行特征量化，并利用默认配置的朴素贝叶斯分类器，在测试文本上可以得到TdifiVectorizer可以得到更高的准确率。而且平均精度、召回率和F1指标也都有提升。去掉停用词的时候效果更加好。TdifiVectorizer的特征抽取和量化方法更加具备优势，使用停用词比不用停用词的模型综合性能要高. 3.1.1.2 特征筛选良好的数据特征组合不需要太多，就可以是的模型的性能表现突出。冗余的特征虽然不会影响到模型的性能，不过却是的CPU的计算做了无用功，二不良的特征还会降低模型的精度，所以特征的筛选很重要。 特征筛选与PCA这类通过选择主成分特征进行重建的方法略有区别：对于PCA而言，我们经常无法解释重建之后的特征，但是特征筛选不存在对特征值的修改，更加侧重于寻找那些对模型的性能提升较大的少量特征。 3.1.2 模型正则化通常我们需要重视模型的繁华里，也就是对未知的数据能有更好的适应能力表现能力，防止过拟合或者欠拟合。而通过正则化的方式可以加强模型的泛化力，避免模型过拟合。 3.1.2.1 欠拟合与过拟合拟合就是指机器学习模型在训练过程中，通过更新参数，使得模型不断的契合可以观测数据（训练集）的过程。一次多项式二次多项式四次多项式准确度对比如出现以上情况，当模型复杂度很低的时候Degree=1时，模型不仅没有对训练集上的数据有良好的拟合状态，而且在测试数据集上也表现平平，这种状态叫欠拟合（Underfitting）,但是如果一味追求很高的模型复杂度如Degree=4的时候，尽管模型几乎完全的拟合了所有的训练数据，但是模型也会变得非常波动，几乎丧失了对未知数据的预测能力，这种情况叫做过拟合（Overfitting），这两种情况都是缺乏模型泛化力的表现。 为了能够在增加模型复杂度提高在训练集数据上表现性能的同时，又能够兼顾模型的泛化力，防止发生过拟合，平衡这个两难问题，采用模型正则化的方法， 3.1.2.2 L 1 范数正则化12345678910111213141516171819202122232425262728293031323334353637383940414243444546#Lasso。lasso_poly4 = Lasso()# 从使用Lasso对4次多项式特征进行拟合。lasso_poly4.fit(X_train_poly4, y_train)# 对Lasso模型在测试样本上的回归性能进行评估。print lasso_poly4.score(X_test_poly4, y_test)# 从sklearn.linear_model中导入Lasso。from sklearn.linear_model import Lasso​# 从使用默认配置初始化Lasso。lasso_poly4 = Lasso()# 从使用Lasso对4次多项式特征进行拟合。lasso_poly4.fit(X_train_poly4, y_train)​# 对Lasso模型在测试样本上的回归性能进行评估。print lasso_poly4.score(X_test_poly4, y_test)​ 0.83889268736# 输出Lasso模型的参数列表。print lasso_poly4.coef_​[ 0.00000000e+00 0.00000000e+00 1.17900534e-01 5.42646770e-05 -2.23027128e-04]# 回顾普通4次多项式回归模型过拟合之后的性能。print regressor_poly4.score(X_test_poly4, y_test)​0.809588079578# 回顾普通4次多项式回归模型的参数列表。print regressor_poly4.coef_​[[ 0.00000000e+00 -2.51739583e+01 3.68906250e+00 -2.12760417e-01 4.29687500e-03]]# 输出普通4次多项式回归模型的参数列表。print regressor_poly4.coef_​[[ 0.00000000e+00 -2.51739583e+01 3.68906250e+00 -2.12760417e-01 4.29687500e-03]]# 输出上述这些参数的平方和，验证参数之间的巨大差异。print np.sum(regressor_poly4.coef_ ** 2)​647.382645692 Lass使得4次3次多项式的特征参数都为0，使得特征更为稀疏，并且调高了模型的性能。 3.1.2.3 L 2 范数正则化L2也是增加惩罚项也叫ridge123456789101112131415161718192021222324252627# 从sklearn.linear_model导入Ridge。from sklearn.linear_model import Ridge# 使用默认配置初始化Riedge。ridge_poly4 = Ridge()# 从sklearn.linear_model导入Ridge。from sklearn.linear_model import Ridge# 使用默认配置初始化Riedge。ridge_poly4 = Ridge()​# 使用Ridge模型对4次多项式特征进行拟合。ridge_poly4.fit(X_train_poly4, y_train)​# 输出Ridge模型在测试样本上的回归性能。print ridge_poly4.score(X_test_poly4, y_test)​0.837420175937# 输出Ridge模型的参数列表，观察参数差异。print ridge_poly4.coef_​[[ 0. -0.00492536 0.12439632 -0.00046471 -0.00021205]]# 计算Ridge模型拟合后参数的平方和。print np.sum(ridge_poly4.coef_ ** 2)​0.0154989652036 ridge模型你和后参数之间的差异非常的小，不论是Lasso还是ridge的惩罚项中都会有一个因子兰布达进行调节，尽管其不属于拟合的参数，但是却有着非常重要的作用。 3.1.3 模型检验3.1.3.1 留一验证就是从任务提供的数据中，随机采样一定比例作为训练集，剩下的留作验证。一般取得比例为7：3，或者4：1，即70%作为训练集，30%作为测试集进行模型验证。这一验证方法不是很稳定，原因在于对验证集合随机采样的不确定性。 3.1.3.2 交叉验证交叉验证可以理解为多次留意验证的集合的过程，只是每次检验所使用的验证集之间是互斥的，并且要保证每一条可用数据都被模型验证过。例如5折验证就是全部可用数据被随机的分割为平均数量的5组，每次迭代都选取其中的1组数据作为验证集， 其它4组作为训练集。交叉验证的好处在于可用保证所有的数据都有被训练和验证的机会，也尽最大可能让优化的模型性能保险的更加可信。 3.1.4 超参数搜索模型中的一些重要参数，我们常常称为模型的超参数，如K邻近算法中的K值，支持向量机中的不同核函数等。 3.1.4.1 网格搜索由于超参数的空间是无尽的，因此超参数的组合配置只能是更优解，没有最优解。通常情况下，我们依靠网格搜索对多种超参数组合的空间进行暴力搜索，每一条超参数组合被代入到学习函数中作为新的模型，并且为了比较新模型之间的性能，每个模型都会采用交叉验证的方法在多组相同的训练和开发数据集下进行评估。12345678910111213141516171819202122232425262728293031323334353637383940# 从sklearn.datasets中导入20类新闻文本抓取器。from sklearn.datasets import fetch_20newsgroups# 导入numpy，并且重命名为np。import numpy as np# 使用新闻抓取器从互联网上下载所有数据，并且存储在变量news中。news = fetch_20newsgroups(subset='all')# 从sklearn.cross_validation导入train_test_split用来分割数据。from sklearn.cross_validation import train_test_split# 对前3000条新闻文本进行数据分割，25%文本用于未来测试。X_train, X_test, y_train, y_test = train_test_split(news.data[:3000], news.target[:3000], test_size=0.25, random_state=33)# 导入支持向量机（分类）模型。from sklearn.svm import SVC# 导入TfidfVectorizer文本抽取器。from sklearn.feature_extraction.text import TfidfVectorizer# 导入Pipeline。from sklearn.pipeline import Pipeline#使用Pipeline 简化系统搭建流程，将文本抽取与分类器模型串联起来。clf = Pipeline([('vect', TfidfVectorizer(stop_words='english', analyzer='word')), ('svc', SVC())])# 这里需要试验的2个超参数的的个数分别是4、3， svc__gamma的参数共有10^-2, 10^-1... 。这样我们一共有12种的超参数组合，12个不同参数下的模型。parameters = &#123;'svc__gamma': np.logspace(-2, 1, 4), 'svc__C': np.logspace(-1, 1, 3)&#125;# 从sklearn.grid_search中导入网格搜索模块GridSearchCV。from sklearn.grid_search import GridSearchCV# 将12组参数组合以及初始化的Pipline包括3折交叉验证的要求全部告知GridSearchCV。请大家务必注意refit=True这样一个设定 。gs = GridSearchCV(clf, parameters, verbose=2, refit=True, cv=3)# 执行单线程网格搜索。%time _= gs.fit(X_train, y_train)gs.best_params_, gs.best_score_# 输出最佳模型在测试集上的准确性。print gs.score(X_test, y_test) 共3x4=12组超参数，再乘以3折交叉验证共36项独立运行的计算任务。 3.1.4.2 并行搜索网格搜索结合交叉验证来寻找超参数组合比较耗时，然而一旦获得了比较好的参数组合，都可以保持一段时间的使用，因此是非常值得推荐的提升方法，而且各个新模型在执行交叉验证的过程中间都是相互独立的，所以我们可以充分利用多核处理器，甚至是分布式的计算资源来从事并行搜索，这样就可以节省时间。1234567891011121314151617181920212223242526272829303132333435363738394041#使用多个线程对文本分类的朴素贝叶斯模型的超参数组合执行并行化的网格搜索# 从sklearn.datasets中导入20类新闻文本抓取器。from sklearn.datasets import fetch_20newsgroups# 导入numpy，并且重命名为np。import numpy as np# 使用新闻抓取器从互联网上下载所有数据，并且存储在变量news中。news = fetch_20newsgroups(subset='all')# 从sklearn.cross_validation导入train_test_split用来分割数据。from sklearn.cross_validation import train_test_split# 对前3000条新闻文本进行数据分割，25%文本用于未来测试。X_train, X_test, y_train, y_test = train_test_split(news.data[:3000], news.target[:3000], test_size=0.25, random_state=33)# 导入支持向量机（分类）模型。from sklearn.svm import SVC# 导入TfidfVectorizer文本抽取器。from sklearn.feature_extraction.text import TfidfVectorizer# 导入Pipeline。from sklearn.pipeline import Pipeline#使用Pipeline 简化系统搭建流程，将文本抽取与分类器模型串联起来。clf = Pipeline([('vect', TfidfVectorizer(stop_words='english', analyzer='word')), ('svc', SVC())])# 这里需要试验的2个超参数的的个数分别是4、3， svc__gamma的参数共有10^-2, 10^-1... 。这样我们一共有12种的超参数组合，12个不同参数下的模型。parameters = &#123;'svc__gamma': np.logspace(-2, 1, 4), 'svc__C': np.logspace(-1, 1, 3)&#125;# 从sklearn.grid_search中导入网格搜索模块GridSearchCV。from sklearn.grid_search import GridSearchCV# 初始化配置并行网格搜索，n_jobs=-1代表使用该计算机全部的CPU。gs = GridSearchCV(clf, parameters, verbose=2, refit=True, cv=3, n_jobs=-1)# 执行多线程并行网格搜索。%time _= gs.fit(X_train, y_train)gs.best_params_, gs.best_score_# 输出最佳模型在测试集上的准确性。print gs.score(X_test, y_test)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[机器学习基础-有监督模型（分类、回归）、无监督模型（聚合、降维）]]></title>
      <url>%2F2017%2F06%2F11%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E6%9C%89%E7%9B%91%E7%9D%A3%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%88%86%E7%B1%BB%E3%80%81%E5%9B%9E%E5%BD%92%EF%BC%89%E3%80%81%E6%97%A0%E7%9B%91%E7%9D%A3%E6%A8%A1%E5%9E%8B%EF%BC%88%E8%81%9A%E5%90%88%E3%80%81%E9%99%8D%E7%BB%B4%EF%BC%89%2F</url>
      <content type="text"><![CDATA[基本知识1.1.1 机器学习的任务机器学习的任务种类较多，但是常规来讲可以以监督学习（Supervised Learning）和无监督学习（Unsupervised Learning）。其中监督学习关注对事物未知表现的预测，一般包括分类问题（classification）、回归问题（Regression）。无监督学习则倾向于对事物本身特性的分析，常用的技术包括数据降维（Dimensionality Reduction）和聚类问题（Clustering）。 分类问题，便是对其所在类别进行预测，类别是离散的，同时也是预先知道数量的。例如根据一个人的身高、体重和三维判定性别，性别是离散的，男和女，同时预先知道其数量。或者说更经典的例子，根据鸢尾花的花瓣、花萼的长宽等数据，判断其所属的鸢尾花亚种，因为鸢尾花的亚种的种类和数量也满足离散和预先知道这两项特征，因此也是分类预测问题。 回归同样是预测问题，只是预测的目标往往是连续的变量，比如根据房屋的面积、地理位置、建筑年代等对房屋销售价格进行预测，销售价格一定是一个连续的变量。 数据降维度是对事物的特征进行压缩和筛选。如果没有特定领域的知识，无法预先确定采样哪些数据，而现如今采样数据成本较低，但是筛选的成本比较高，比如在图像识别中，如今像素分辨率极大，因而若直接使用这些像素信息那么数据维度非常高，所以很难对数据进行处理。因此这样的数据通常需要进行降维，保存其最有区分度的像素组合，从此便能不影响效果，但是数据维度降低，降低运算难度，也更容易理解。 聚类则是依赖于数据的相似性，把相似的数据样本划分为一个簇，不同于分类问题，我们在大多数情况下不会预先知道簇的数量和每个簇的具体含义。例如购物网站对用户信息和购买习惯进行聚类分析，这样就可以进行分类的广告投放。 1.1.2 机器学习中应用的经验习惯性的认为数据就是经验，只有那些对学习任务有用的特定信息才会被列入考虑范围，通常把这些反映数据内在规律的信息叫做特征（Feature）。譬如经典的人脸识别，很少直接用原始图像来进行经验来学习，而是先进行建委，把复杂的数据处理成有助于人脸识别的轮廓特征。 对于监督学习问题，所需要的经验一般包括特征，以及标记/目标(Label/Target)这样才能知道结果是什么，标记/目标的表现形式则取决于监督学习的种类。 无监督学习并不用于做结果预测，那么自然就不需要标记/目标，但是却更加适合对于数据结构的分析。正式因为这个区别可以尝尝获得大量无监督数据，而监督数据的标注因为经常耗费大量的时间、金钱和人力，所以数据量相对较少。 更重要的是，标记/目标的表现形式存在离散、连续变量的区别，从原始数据到特征数据的转换过程中也会遭遇到多种数据类型：类别型特征、数值型特征、甚至是缺失的数据。而学习的过程中需要将这些特征转换为具体的数据参与计算，所以通常要经过缺失数据补全、部分数据过滤、和数据标准化等预先对数据进行处理。 而通常所说的训练集就是既有特征，同时带有目标/标记的数据集。 1.1.3 机器学习的性能、精度表现形式所谓的性能，便是评价完成任务的质量指标。通常为了评价其完成的质量，我们需要具有相同特征的数据，并将模型的预测结果与相对应的正确结果进行对比。这样的数据成为测试集。（测试集的数据一定不能出现在训练集中，也就是说他们说相互排斥的。） 预测精度问题： - 对于分类问题来讲，需要根据预测正确类别的百分比来评判其性能，这个指标也通常成为准确性（Accuracy）. - 对于回归问题需要衡量预测值与实际值之间的偏差大小。 - 而通常这两种预测指标的表现形式有些不足。对于分类问题一般还有召回率（Recall）、精确率（Percision）以及F1指标。 - 对于回归问题一般又有三种关于回归的特有的评价机制如R-squared。【p69】 - 对于聚类问题，如果评估的数据有具体的所属类别，一般采用ARI（Adjust Rand Index）指标，他与分类问题的准确性（Accuracy）类似，但是它也兼顾的考虑到了类簇无法和分类标记意义对应的问题。如果没有具体的所属类别，那么一般使用轮廓系数（Slihouette Coefficient）来度量聚类的结果质量。取值范围【-1，1】数值越大表明效果越好。【P85】 - 对于数据降维如PCA,一般用处理过的数据与未降维的数据来进行对比即可。对比参数可根据数据所属类别来选择。 监督学习：机器学习的监督学习模型的任务重点在于，根据已有经验的知识对未知样本的目标/标记进行预测，根据目标预测变量的类别不同，把监督学习任务大体分为分类学习与回归预测两类。流程即如上体所示，首先需要准备训练数据，可以是文本、图像、音频等，然后抽取所需要的特征，形成特征向量（Feature Vectors），接着把这些特征向量连同对应的标记/目标（即结果）一同送入学习算法（Machine Learning Algorithm）中，训练出一个预测模型(Predictive Model)，然后采用同样的特征抽取方法作用于新的测试数据，得到用于测试的特征向量，最后使用预测模型对这些待测试的特征向量进行预测并得到结果（Expected Label）. 2.1.1分类学习（Classifier）分类学习是最为常见的监督学习问题，最为基础的是二分类问题，即是判断是非，从两个类别中选择一个作为预测结果，除此之外还有多类分类即是在多余两个类别中选择一个作为预测结果，甚至还有多标签多分类问题，多标签多分类问题判断一个样本是否同时属于多个不同的类别。 比如实际生活中，遇到许多分类问题，如医生对肿瘤性质进行判定，邮件系统对手写数字进行识别，互联网公司对新闻进行分类，生物学家对物种类型进行鉴定。 2.1.1.1 线性分类器（Linear Classifier）模型介绍：线性分类器（Linear Classifiers），是一种假设特征与分类结果存在线性关系的模型，这个模型通过累加计算每个维度的特征与各自的权重的乘积来帮助决策。常用的有LogisticRegression与SGDClassifiler。 数据描述：采用UCI的良/恶性乳腺癌肿瘤预测，分别是逻辑斯蒂回归分类，与随机梯度下降分类。 性能分析：准确率（Accuracy）、召回率（Recall）、精确率（Percision）以及F1指标。 特点分析：线性分类器可以说是最为基本和常用的机器学习模型，尽管受限于数据特征与分类目标之间的线性假设，仍然可以在科学研究和工程实践中吧线性分类器作为基准，所使用的模型包括LogisticRegression与SGDClassifiler，相比较，前者对参数的计算采用精确的解析方式，计算时间长但是模型性略高，后者采取随机梯度下降算法估计模型参数，计算时间段，但是模型性能略低。一般而言顺联的数据规模如果超过10W条，考虑到时间的耗用等因素，运用随机梯度算法对模型参数进行估计。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171# 导入pandas与numpy工具包。import pandas as pdimport numpy as np# 创建特征列表。column_names = ['Sample code number', 'Clump Thickness', 'Uniformity of Cell Size', 'Uniformity of Cell Shape', 'Marginal Adhesion', 'Single Epithelial Cell Size', 'Bare Nuclei', 'Bland Chromatin', 'Normal Nucleoli', 'Mitoses', 'Class']# 使用pandas.read_csv函数从互联网读取指定数据。data = pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data', names = column_names )# 将?替换为标准缺失值表示。data = data.replace(to_replace='?', value=np.nan)# 丢弃带有缺失值的数据（只要有一个维度有缺失）。data = data.dropna(how='any')# 输出data的数据量和维度。data.shape (683, 11)# 使用sklearn.cross_valiation里的train_test_split模块用于分割数据。from sklearn.cross_validation import train_test_split# 随机采样25%的数据用于测试，剩下的75%用于构建训练集合。X_train, X_test, y_train, y_test = train_test_split(data[column_names[1:10]], data[column_names[10]], test_size=0.25, random_state=33)# 查验训练样本的数量和类别分布。y_train.value_counts() 2 344 4 168 Name: Class, dtype: int64# 查验测试样本的数量和类别分布。y_test.value_counts() Out[4]:2 1004 71Name: Class, dtype: int64# 从sklearn.preprocessing里导入StandardScaler。from sklearn.preprocessing import StandardScaler# 从sklearn.linear_model里导入LogisticRegression与SGDClassifier。from sklearn.linear_model import LogisticRegressionfrom sklearn.linear_model import SGDClassifier# 标准化数据，保证每个维度的特征数据方差为1，均值为0。使得预测结果不会被某些维度过大的特征值而主导。ss = StandardScaler()X_train = ss.fit_transform(X_train)X_test = ss.transform(X_test)# 初始化LogisticRegression与SGDClassifier。lr = LogisticRegression()sgdc = SGDClassifier()# 调用LogisticRegression中的fit函数/模块用来训练模型参数。lr.fit(X_train, y_train)# 使用训练好的模型lr对X_test进行预测，结果储存在变量lr_y_predict中。lr_y_predict = lr.predict(X_test)# 调用SGDClassifier中的fit函数/模块用来训练模型参数。sgdc.fit(X_train, y_train)# 使用训练好的模型sgdc对X_test进行预测，结果储存在变量sgdc_y_predict中。sgdc_y_predict = sgdc.predict(X_test)# 从sklearn.metrics里导入classification_report模块。from sklearn.metrics import classification_report# 使用逻辑斯蒂回归模型自带的评分函数score获得模型在测试集上的准确性结果。print 'Accuracy of LR Classifier:', lr.score(X_test, y_test)# 利用classification_report模块获得LogisticRegression其他三个指标的结果。print classification_report(y_test, lr_y_predict, target_names=['Benign', 'Malignant']) Accuracy of LR Classifier: 0.988304093567 precision recall f1-score support Benign 0.99 0.99 0.99 100 Malignant 0.99 0.99 0.99 71avg / total 0.99 0.99 0.99 171 # 使用随机梯度下降模型自带的评分函数score获得模型在测试集上的准确性结果。print 'Accuarcy of SGD Classifier:', sgdc.score(X_test, y_test)# 利用classification_report模块获得SGDClassifier其他三个指标的结果。print classification_report(y_test, sgdc_y_predict, target_names=['Benign', 'Malignant']) Accuarcy of SGD Classifier: 0.953216374269 precision recall f1-score support Benign 0.93 0.99 0.96 100 Malignant 0.98 0.90 0.94 71avg / total 0.95 0.95 0.95 171``` #### 2.1.1.2 支持向量机(Support Vector Classifier) ![](http://ocef6bnjz.bkt.clouddn.com/17-6-11/50533102.jpg)模型介绍： 例如线性分类可能获得多个线性分类线，但是我们更希望选取更好的那一条，即如上图的H3线，可以对更多的数据点有更好的容忍度。所以支持向量机分类器便是根据训练样本的分布，搜索所有可能的线性分类器中最佳的那个。而其中可以用来真正帮助决策最优线性分类器模型的数据点叫做“支持向量”，如上图中的虚线连接的两个点。数据描述：使用支持向量机分类器处理框架Scikit-learn内部集成的手写数字图片集。性能分析：准确率（Accuracy）、召回率（Recall）、精确率（Percision）以及F1指标。需要进一步指出的是以上三个参数最先适用于二分类任务，但是在拥有多个类别的项目中（如此例数据的识别有0-9共10个数字），因此无法直接计算上述三个指标，通常的做法是注意评估每个类别的三个指标，也就相当于10个二分类任务。而此学习库也的确是这样的做的。特点分析：支持向量机模型在机器学习领域繁荣了一段时间，主要原因在于其精妙的模型假设，可以帮助我们在海量甚至更高维度的数据中筛选出对预测任务最为有效的少数训练样本。这样不仅节省了模型学习所需要的数据内存，同时也提高了模型的预测性能。然后要获得此性能，就必须付出更多的计算代价（CPU资源和计算时间）。```python# 从sklearn.datasets里导入手写体数字加载器。from sklearn.datasets import load_digits# 从通过数据加载器获得手写体数字的数码图像数据并储存在digits变量中。digits = load_digits()# 检视数据规模和特征维度。digits.data.shape (1797, 64） # 从sklearn.cross_validation中导入train_test_split用于数据分割。from sklearn.cross_validation import train_test_split# 随机选取75%的数据作为训练样本；其余25%的数据作为测试样本。X_train, X_test, y_train, y_test = train_test_split(digits.data, digits.target, test_size=0.25, random_state=33)y_train.shape (1347,) y_test.shape (450,) # 从sklearn.preprocessing里导入数据标准化模块。from sklearn.preprocessing import StandardScaler# 从sklearn.svm里导入基于线性假设的支持向量机分类器LinearSVC。from sklearn.svm import LinearSVC# 从仍然需要对训练和测试的特征数据进行标准化。ss = StandardScaler()X_train = ss.fit_transform(X_train)X_test = ss.transform(X_test)# 初始化线性假设的支持向量机分类器LinearSVC。lsvc = LinearSVC()#进行模型训练lsvc.fit(X_train, y_train)# 利用训练好的模型对测试样本的数字类别进行预测，预测结果储存在变量y_predict中。y_predict = lsvc.predict(X_test)# 使用模型自带的评估函数进行准确性测评。print 'The Accuracy of Linear SVC is', lsvc.score(X_test, y_test) The Accuracy of Linear SVC is 0.953333333333 # 依然使用sklearn.metrics里面的classification_report模块对预测结果做更加详细的分析。from sklearn.metrics import classification_reportprint classification_report(y_test, y_predict, target_names=digits.target_names.astype(str)) precision recall f1-score support 0 0.92 1.00 0.96 35 1 0.96 0.98 0.97 54 2 0.98 1.00 0.99 44 3 0.93 0.93 0.93 46 4 0.97 1.00 0.99 35 5 0.94 0.94 0.94 48 6 0.96 0.98 0.97 51 7 0.92 1.00 0.96 35 8 0.98 0.84 0.91 58 9 0.95 0.91 0.93 44avg / total 0.95 0.95 0.95 450 2.1.1.3 朴素贝叶斯(Native Bayes)模型介绍：朴素贝叶斯是一个非常简单，但是实用性很强的分类模型，不过和基于线性假设的（线性分类器、支持向量机）不同，朴素贝叶斯分类器的构造基础是贝叶斯理论。数据描述：朴素贝叶斯模型有着广泛的应用环境，特别是在文本分类的任务中间，包括互联网新闻的分类、垃圾邮件的筛选等。本次实例就采取新闻文本作为实验数据。性能分析：准确率（Accuracy）、召回率（Recall）、精确率（Percision）以及F1指标。通过这个测度对朴素贝叶斯模型在20类新闻文本分类任务上的性能进行评估。特点分析：朴素贝叶斯模型被广泛的运用于海量互联网文本分类任务。由于其较强的特征条件独立假设，使得模型预测所需估计的参数规模从幂指数向线性量级别减少，极大的节约了内存消耗和计算时间。但是也正因为这种强假设的限制，模型训练无法将各个特征之间的联系考量在内，使得该模型在其他数据特征关联性较强的分类任务上的性能表现不佳。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# 从sklearn.datasets里导入新闻数据抓取器fetch_20newsgroups。from sklearn.datasets import fetch_20newsgroups# 与之前预存的数据不同，fetch_20newsgroups需要即时从互联网下载数据。news = fetch_20newsgroups(subset='all')# 查验数据规模和细节。print len(news.data)print news.data[0] WARNING:sklearn.datasets.twenty_newsgroups:Downloading dataset from http://people.csail.mit.edu/jrennie/20Newsgroups/20news-bydate.tar.gz (14 MB) 18846 From: Mamatha Devineni Ratnam &lt;mr47+@andrew.cmu.edu&gt; Subject: Pens fans reactions Organization: Post Office, Carnegie Mellon, Pittsburgh, PA Lines: 12 NNTP-Posting-Host: po4.andrew.cmu.edu I am sure some bashers of Pens fans are pretty confused about the lack of any kind of posts about the recent Pens massacre of the Devils. Actually, I am bit puzzled too and a bit relieved. However, I am going to put an end to non-PIttsburghers' relief with a bit of praise for the Pens. Man, they are killing those Devils worse than I thought. Jagr just showed you why he is much better than his regular season stats. He is also a lot fo fun to watch in the playoffs. Bowman should let JAgr have a lot of fun in the next couple of games since the Pens are going to beat the pulp out of Jersey anyway. I was very disappointed not to see the Islanders lose the final regular season game. PENS RULE!!! # 从sklearn.cross_validation 导入 train_test_split。from sklearn.cross_validation import train_test_split# 随机采样25%的数据样本作为测试集。X_train, X_test, y_train, y_test = train_test_split(news.data, news.target, test_size=0.25, random_state=33)# 从sklearn.feature_extraction.text里导入用于文本特征向量转化模块。详细介绍请读者参考3.1.1.1 特征抽取一节。from sklearn.feature_extraction.text import CountVectorizervec = CountVectorizer()X_train = vec.fit_transform(X_train)X_test = vec.transform(X_test)# 从sklearn.naive_bayes里导入朴素贝叶斯模型。from sklearn.naive_bayes import MultinomialNB# 从使用默认配置初始化朴素贝叶斯模型。mnb = MultinomialNB()# 利用训练数据对模型参数进行估计。mnb.fit(X_train, y_train)# 对测试样本进行类别预测，结果存储在变量y_predict中。y_predict = mnb.predict(X_test)# 从sklearn.metrics里导入classification_report用于详细的分类性能报告。from sklearn.metrics import classification_reportprint 'The accuracy of Naive Bayes Classifier is', mnb.score(X_test, y_test)print classification_report(y_test, y_predict, target_names = news.target_names) The accuracy of Naive Bayes Classifier is 0.839770797963 precision recall f1-score support alt.atheism 0.86 0.86 0.86 201 comp.graphics 0.59 0.86 0.70 250 comp.os.ms-windows.misc 0.89 0.10 0.17 248 comp.sys.ibm.pc.hardware 0.60 0.88 0.72 240 comp.sys.mac.hardware 0.93 0.78 0.85 242 comp.windows.x 0.82 0.84 0.83 263 misc.forsale 0.91 0.70 0.79 257 rec.autos 0.89 0.89 0.89 238 rec.motorcycles 0.98 0.92 0.95 276 rec.sport.baseball 0.98 0.91 0.95 251 rec.sport.hockey 0.93 0.99 0.96 233 sci.crypt 0.86 0.98 0.91 238 sci.electronics 0.85 0.88 0.86 249 sci.med 0.92 0.94 0.93 245 sci.space 0.89 0.96 0.92 221 soc.religion.christian 0.78 0.96 0.86 232 talk.politics.guns 0.88 0.96 0.92 251 talk.politics.mideast 0.90 0.98 0.94 231 talk.politics.misc 0.79 0.89 0.84 188 talk.religion.misc 0.93 0.44 0.60 158 avg / total 0.86 0.84 0.82 4712 2.1.1.4 K近邻(K-Nearest Neighbor)模型介绍：假设有一些携带分类标记的训练样本，分布于特征空间中。（有三类颜色蓝绿红，但图黑白将就看吧），不同颜色代表各自的类别，对于一个待分类的样本，选取待分类样本在特征空间中距离最近的K个已标记样本作为参考，来帮助做出分类决策。因此可以得知K值不同得到的分类器可能不同。数据描述：使用K临近算法对生物物种进行分类，并且使用最为著名的鸢尾数据集。性能分析：准确率（Accuracy）、召回率（Recall）、精确率（Percision）以及F1指标。通过这个测度对朴素贝叶斯模型在20类新闻文本分类任务上的性能进行评估。特点分析：K临近分类是非常直观的机器学习模型，K临近算法与其他模型的最大不同在于该模型没有参数训练过程。也就是说没有通过任何学习算法分析训练数据，而只是根据测试样本在训练数据的分布直接作出决策。所以K临近算法属于无参数模型中非常简单的一种。但是这样的决策算法导致了非常高的计算复杂度和内存消耗。因为该模型每处理一个测试样本都需要对所有预先加载在内存的训练样本进行遍历、逐一计算相似度、排序并且选取K个最近邻训练样本的标记，进而做出决策。这是平方级别的算法复杂度，一旦数据量较大，时间消耗会很大。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110# 从sklearn.datasets 导入 iris数据加载器。from sklearn.datasets import load_iris# 使用加载器读取数据并且存入变量iris。iris = load_iris()# 查验数据规模。iris.data.shape (150L, 4L)# 查看数据说明。对于一名机器学习的实践者来讲，这是一个好习惯。print iris.DESCR Iris Plants Database Notes ----- Data Set Characteristics: :Number of Instances: 150 (50 in each of three classes) :Number of Attributes: 4 numeric, predictive attributes and the class :Attribute Information: - sepal length in cm - sepal width in cm - petal length in cm - petal width in cm - class: - Iris-Setosa - Iris-Versicolour - Iris-Virginica :Summary Statistics: ============== ==== ==== ======= ===== ==================== Min Max Mean SD Class Correlation ============== ==== ==== ======= ===== ==================== sepal length: 4.3 7.9 5.84 0.83 0.7826 sepal width: 2.0 4.4 3.05 0.43 -0.4194 petal length: 1.0 6.9 3.76 1.76 0.9490 (high!) petal width: 0.1 2.5 1.20 0.76 0.9565 (high!) ============== ==== ==== ======= ===== ==================== :Missing Attribute Values: None :Class Distribution: 33.3% for each of 3 classes. :Creator: R.A. Fisher :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov) :Date: July, 1988 This is a copy of UCI ML iris datasets. http://archive.ics.uci.edu/ml/datasets/Iris The famous Iris database, first used by Sir R.A Fisher This is perhaps the best known database to be found in the pattern recognition literature. Fisher's paper is a classic in the field and is referenced frequently to this day. (See Duda &amp; Hart, for example.) The data set contains 3 classes of 50 instances each, where each class refers to a type of iris plant. One class is linearly separable from the other 2; the latter are NOT linearly separable from each other. References ---------- - Fisher,R.A. "The use of multiple measurements in taxonomic problems" Annual Eugenics, 7, Part II, 179-188 (1936); also in "Contributions to Mathematical Statistics" (John Wiley, NY, 1950). - Duda,R.O., &amp; Hart,P.E. (1973) Pattern Classification and Scene Analysis. (Q327.D83) John Wiley &amp; Sons. ISBN 0-471-22361-1. See page 218. - Dasarathy, B.V. (1980) "Nosing Around the Neighborhood: A New System Structure and Classification Rule for Recognition in Partially Exposed Environments". IEEE Transactions on Pattern Analysis and Machine Intelligence, Vol. PAMI-2, No. 1, 67-71. - Gates, G.W. (1972) "The Reduced Nearest Neighbor Rule". IEEE Transactions on Information Theory, May 1972, 431-433. - See also: 1988 MLC Proceedings, 54-64. Cheeseman et al"s AUTOCLASS II conceptual clustering system finds 3 classes in the data. - Many, many more ... # 从sklearn.cross_validation里选择导入train_test_split用于数据分割。from sklearn.cross_validation import train_test_split# 从使用train_test_split，利用随机种子random_state采样25%的数据作为测试集。X_train, X_test, y_train, y_test = train_test_split(iris.data, iris.target, test_size=0.25, random_state=33)# 从sklearn.preprocessing里选择导入数据标准化模块。from sklearn.preprocessing import StandardScaler# 从sklearn.neighbors里选择导入KNeighborsClassifier，即K近邻分类器。from sklearn.neighbors import KNeighborsClassifier# 对训练和测试的特征数据进行标准化。ss = StandardScaler()X_train = ss.fit_transform(X_train)X_test = ss.transform(X_test)# 使用K近邻分类器对测试数据进行类别预测，预测结果储存在变量y_predict中。knc = KNeighborsClassifier()knc.fit(X_train, y_train)y_predict = knc.predict(X_test)# 使用模型自带的评估函数进行准确性测评。print 'The accuracy of K-Nearest Neighbor Classifier is', knc.score(X_test, y_test) The accuracy of K-Nearest Neighbor Classifier is 0.894736842105# 依然使用sklearn.metrics里面的classification_report模块对预测结果做更加详细的分析。from sklearn.metrics import classification_reportprint classification_report(y_test, y_predict, target_names=iris.target_names) precision recall f1-score support setosa 1.00 1.00 1.00 8 versicolor 0.73 1.00 0.85 11 virginica 1.00 0.79 0.88 19 avg / total 0.92 0.89 0.90 38 2.1.1.5 决策树(Decision Tree)模型介绍：无论是logistic回归还是支持向量机模型，都在某种程度上要求被学习的数据特征和目标之间遵循着线性假设。但实际中很多情况这是不可能的。如一个人的年龄与患流感而死亡之间不存在线程关系，如果非要描述这种非线性关系，那么使用分段函数最为合理。而在机器学习中，决策树就是描述这种非线性关系的不二之选。多层决策树的时候，模型在学习的时候就需要考虑特征节点的选取顺序，常用的度量方式包括信息熵（information Gain）和基尼不纯性（Gini Impurity）。数据描述：泰坦尼克号数据，预测事故中人生存的可能性。性能分析：准确率（Accuracy）、召回率（Recall）、精确率（Percision）以及F1指标。特点分析：相比于其他模型，决策树在模型描述上有巨大的优势，决策树的推断逻辑非常直观，具有清晰的可解释性，也方便了模型的可视化。这些特性同时保证了在使用决策树模型时，是无需考虑对数据量化甚至标准化的，并且仍然属于有参数模型，需要花费更多的时间在训练上。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# 导入pandas用于数据分析。import pandas as pd# 利用pandas的read_csv模块直接从互联网收集泰坦尼克号乘客数据。titanic = pd.read_csv('http://biostat.mc.vanderbilt.edu/wiki/pub/Main/DataSets/titanic.txt')# 观察一下前几行数据，可以发现，数据种类各异，数值型、类别型，甚至还有缺失数据。titanic.head() row.names pclass survived name age embarked home.dest room ticket boat sex 0 1 1st 1 Allen, Miss Elisabeth Walton 29.0000 Southampton St Louis, MO B-5 24160 L221 2 female 1 2 1st 0 Allison, Miss Helen Loraine 2.0000 Southampton Montreal, PQ / Chesterville, ON C26 NaN NaN female 2 3 1st 0 Allison, Mr Hudson Joshua Creighton 30.0000 Southampton Montreal, PQ / Chesterville, ON C26 NaN (135) male 3 4 1st 0 Allison, Mrs Hudson J.C. (Bessie Waldo Daniels) 25.0000 Southampton Montreal, PQ / Chesterville, ON C26 NaN NaN female 4 5 1st 1 Allison, Master Hudson Trevor 0.9167 Southampton Montreal, PQ / Chesterville, ON C22 NaN 11 male # 使用pandas，数据都转入pandas独有的dataframe格式（二维数据表格），直接使用info()，查看数据的统计特性。titanic.info() &lt;class 'pandas.core.frame.DataFrame'&gt; Int64Index: 1313 entries, 0 to 1312 Data columns (total 11 columns): row.names 1313 non-null int64 pclass 1313 non-null object survived 1313 non-null int64 name 1313 non-null object age 633 non-null float64 embarked 821 non-null object home.dest 754 non-null object room 77 non-null object ticket 69 non-null object boat 347 non-null object sex 1313 non-null object dtypes: float64(1), int64(2), object(8) memory usage: 123.1+ KB # 机器学习有一个不太被初学者重视，并且耗时，但是十分重要的一环，特征的选择，这个需要基于一些背景知识。根据我们对这场事故的了解，sex, age, pclass这些都很有可能是决定幸免与否的关键因素。X = titanic[['pclass', 'age', 'sex']]y = titanic['survived']# 对当前选择的特征进行探查。X.info() &lt;class 'pandas.core.frame.DataFrame'&gt; Int64Index: 1313 entries, 0 to 1312 Data columns (total 3 columns): pclass 1313 non-null object age 633 non-null float64 sex 1313 non-null object dtypes: float64(1), object(2) memory usage: 41.0+ KB # 借由上面的输出，我们设计如下几个数据处理的任务：# 1) age这个数据列，只有633个，需要补完。# 2) sex 与 pclass两个数据列的值都是类别型的，需要转化为数值特征，用0/1代替。# 首先我们补充age里的数据，使用平均数或者中位数都是对模型偏离造成最小影响的策略。X['age'].fillna(X['age'].mean(), inplace=True)# 对补完的数据重新探查。X.info() &lt;class 'pandas.core.frame.DataFrame'&gt; Int64Index: 1313 entries, 0 to 1312 Data columns (total 3 columns): pclass 1313 non-null object age 1313 non-null float64 sex 1313 non-null object dtypes: float64(1), object(2) memory usage: 41.0+ KB # 由此得知，age特征得到了补完。# 数据分割。from sklearn.cross_validation import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state = 33)# 我们使用scikit-learn.feature_extraction中的特征转换器，详见3.1.1.1特征抽取。from sklearn.feature_extraction import DictVectorizervec = DictVectorizer(sparse=False)# 转换特征后，我们发现凡是类别型的特征都单独剥离出来，独成一列特征，数值型的则保持不变。X_train = vec.fit_transform(X_train.to_dict(orient='record')) ['age', 'pclass=1st', 'pclass=2nd', 'pclass=3rd', 'sex=female', 'sex=male'] # 同样需要对测试数据的特征进行转换。X_test = vec.transform(X_test.to_dict(orient='record'))# 从sklearn.tree中导入决策树分类器。from sklearn.tree import DecisionTreeClassifier# 使用默认配置初始化决策树分类器。dtc = DecisionTreeClassifier()# 使用分割到的训练数据进行模型学习。dtc.fit(X_train, y_train)# 用训练好的决策树模型对测试特征数据进行预测。y_predict = dtc.predict(X_test)# 从sklearn.metrics导入classification_report。from sklearn.metrics import classification_report# 输出预测准确性。print dtc.score(X_test, y_test)# 输出更加详细的分类性能。print classification_report(y_predict, y_test, target_names = ['died', 'survived']) 0.781155015198 precision recall f1-score support died 0.91 0.78 0.84 236 survived 0.58 0.80 0.67 93 avg / total 0.81 0.78 0.79 329 2.1.1.6 集成模型(Ensemble):随机森林：Random Forest Classifier，梯度提升决策树：Gradient Tree Boosting。模型介绍：集成分类模型便是综合考量多个分类器的预测结果，从而做出决策。这种综合考量大体上分为两种：1.一种是利用相同的训练数据同时搭建多个独立的分类模型，然后通过投票的方式，以少数服从多数的原则做出最终的分类决策。比较具有代表性的模型为随机森林分类器。即是在相同的训练数据上同时搭建多棵决策树，一株标准的决策树根据每维特征对预测结果的影响程度进行排序，进而决定不同特征从上至下构建分裂节点的顺序，但如果都这样，那么每一棵树都类似，那么就丧失了多样性，而随机森林分类器在构建过程中放弃了这一固定的排序算法，转而随机选取特征。【也是工业上对比的基准线】2.另一种是按照一定次序搭建多个分类模型。这些模型之间彼此存在依赖关系。每一个后续模型的加入都需要对现有的集成模型的综合性能有所贡献，进而不断的提升更新后的集成模型的性能，并最终期望借助整合多个分类能力较弱的分类器，搭建出具有更强分类能力的模型。比较有代表性的就是梯度提升决策树。与构建随机森林分类器模型不同，每一棵决策树在生成的过程中对吼尽可能的降低整体集成模型在训练集上的拟合误差。数据描述：仍然用泰坦尼克号数据。性能分析：使用多种用于评价分类任务性能的指标，将单一决策树、随机森林分类器以及随机梯度提升决策树进行以下四种参数的对比。准确率（Accuracy）、召回率（Recall）、精确率（Percision）以及F1指标。特点分析：相比于其他单一的学习模型，集成模型可以整合多种模型，或者多次就一种类型的模型进行建模，由于模型估计参数的过程也同样受到概率的影响，具有一定的不确定性，因此集成模型虽然在训练过程中要耗费更多的时间，但是得到的综合模型往往具有更高的性能和更好的稳定性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283# 导入pandas，并且重命名为pd。import pandas as pd# 通过互联网读取泰坦尼克乘客档案，并存储在变量titanic中。titanic = pd.read_csv('http://biostat.mc.vanderbilt.edu/wiki/pub/Main/DataSets/titanic.txt')# 人工选取pclass、age以及sex作为判别乘客是否能够生还的特征。X = titanic[['pclass', 'age', 'sex']]y = titanic['survived']# 对于缺失的年龄信息，我们使用全体乘客的平均年龄代替，这样可以在保证顺利训练模型的同时，尽可能不影响预测任务。X['age'].fillna(X['age'].mean(), inplace=True)# 对原始数据进行分割，25%的乘客数据用于测试。from sklearn.cross_validation import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state = 33)# 对类别型特征进行转化，成为特征向量。from sklearn.feature_extraction import DictVectorizervec = DictVectorizer(sparse=False)X_train = vec.fit_transform(X_train.to_dict(orient='record'))X_test = vec.transform(X_test.to_dict(orient='record'))# 使用单一决策树进行模型训练以及预测分析。from sklearn.tree import DecisionTreeClassifierdtc = DecisionTreeClassifier()dtc.fit(X_train, y_train)dtc_y_pred = dtc.predict(X_test# 使用随机森林分类器进行集成模型的训练以及预测分析。from sklearn.ensemble import RandomForestClassifierrfc = RandomForestClassifier()rfc.fit(X_train, y_train)rfc_y_pred = rfc.predict(X_test)# 使用梯度提升决策树进行集成模型的训练以及预测分析。from sklearn.ensemble import GradientBoostingClassifiergbc = GradientBoostingClassifier()gbc.fit(X_train, y_train)gbc_y_pred = gbc.predict(X_test)# 从sklearn.metrics导入classification_report。from sklearn.metrics import classification_report# 输出单一决策树在测试集上的分类准确性，以及更加详细的精确率、召回率、F1指标。print 'The accuracy of decision tree is', dtc.score(X_test, y_test)print classification_report(dtc_y_pred, y_test) The accuracy of decision tree is 0.781155015198 precision recall f1-score support 0 0.91 0.78 0.84 236 1 0.58 0.80 0.67 93 avg / total 0.81 0.78 0.79 329# 输出随机森林分类器在测试集上的分类准确性，以及更加详细的精确率、召回率、F1指标。print 'The accuracy of random forest classifier is', rfc.score(X_test, y_test)print classification_report(rfc_y_pred, y_test) The accuracy of random forest classifier is 0.77811550152 precision recall f1-score support 0 0.90 0.77 0.83 235 1 0.58 0.79 0.67 94 avg / total 0.81 0.78 0.79 329# 输出梯度提升决策树在测试集上的分类准确性，以及更加详细的精确率、召回率、F1指标。print 'The accuracy of gradient tree boosting is', gbc.score(X_test, y_test)print classification_report(gbc_y_pred, y_test) The accuracy of gradient tree boosting is 0.790273556231 precision recall f1-score support 0 0.92 0.78 0.84 239 1 0.58 0.82 0.68 90 avg / total 0.83 0.79 0.80 329 2.1.2 回归预测（Regressor）回归问题和分类问题的区别在于其预测的目标是连续的变量，比如：价格、降水量等等。比如经典的例子房价预测，以下小节都采用这个例子。 2.1.2.1 线性回归器模型介绍：在线性分类器的时候，为了方便将实数域的结果映射到（0,1）区间，引入了逻辑斯蒂函数，而在线性回归问题中，预测目标直接就是实数域上的数值。因此优化目标更为简单，即最小化预测结果与真实值之间的差值。此处采用线性回归模型LinearRegression和SGDRegressor两种线性模型。数据描述：美国波士顿地区的房价预测。性能分析：不同于类别预测，不能苛求回归预测的数值结果严格的与真实值相同。一般情况下，希望衡量预测值与真实值之间的差距。因此可以通过多种测评函数进行评价，最为直观的评价指标包括平均绝对误差（Mean Absolute Error,MAE）,均方误差（Mean Squared Error,MSE）,这些都是线性模型所优化的额目标。以及最传统的R-squared（用来衡量模型回归结果的波动可被真实值验证的百分比，也暗示了模型在数值回归方面的能力，同时即考量了回归值与真实值之间的差异，同时也反映了真实值的变动）特点分析：线性回归其是最为简单的、易用的回归模型。正是因为其对特征与回归目标之间的线性假设，从某种程度上也局限了其应用范围，特别是现实生活中的许多实例数据的各个特征与回归目标之间，绝大数不能保证严格的线性关系。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147# 从sklearn.datasets导入波士顿房价数据读取器。from sklearn.datasets import load_boston# 从读取房价数据存储在变量boston中。boston = load_boston()# 输出数据描述。print (boston.DESCR) Boston House Prices dataset =========================== Notes ------ Data Set Characteristics: :Number of Instances: 506 :Number of Attributes: 13 numeric/categorical predictive :Median Value (attribute 14) is usually the target :Attribute Information (in order): - CRIM per capita crime rate by town - ZN proportion of residential land zoned for lots over 25,000 sq.ft. - INDUS proportion of non-retail business acres per town - CHAS Charles River dummy variable (= 1 if tract bounds river; 0 otherwise) - NOX nitric oxides concentration (parts per 10 million) - RM average number of rooms per dwelling - AGE proportion of owner-occupied units built prior to 1940 - DIS weighted distances to five Boston employment centres - RAD index of accessibility to radial highways - TAX full-value property-tax rate per $10,000 - PTRATIO pupil-teacher ratio by town - B 1000(Bk - 0.63)^2 where Bk is the proportion of blacks by town - LSTAT % lower status of the population - MEDV Median value of owner-occupied homes in $1000's :Missing Attribute Values: None :Creator: Harrison, D. and Rubinfeld, D.L. This is a copy of UCI ML housing dataset. http://archive.ics.uci.edu/ml/datasets/Housing This dataset was taken from the StatLib library which is maintained at Carnegie Mellon University. The Boston house-price data of Harrison, D. and Rubinfeld, D.L. 'Hedonic prices and the demand for clean air', J. Environ. Economics &amp; Management, vol.5, 81-102, 1978. Used in Belsley, Kuh &amp; Welsch, 'Regression diagnostics ...', Wiley, 1980. N.B. Various transformations are used in the table on pages 244-261 of the latter. The Boston house-price data has been used in many machine learning papers that address regression problems. **References** - Belsley, Kuh &amp; Welsch, 'Regression diagnostics: Identifying Influential Data and Sources of Collinearity', Wiley, 1980. 244-261. - Quinlan,R. (1993). Combining Instance-Based and Model-Based Learning. In Proceedings on the Tenth International Conference of Machine Learning, 236-243, University of Massachusetts, Amherst. Morgan Kaufmann. - many more! (see http://archive.ics.uci.edu/ml/datasets/Housing)# 从sklearn.cross_validation导入数据分割器。from sklearn.cross_validation import train_test_split# 导入numpy并重命名为np。import numpy as npX = boston.datay = boston.target# 随机采样25%的数据构建测试样本，其余作为训练样本。X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=33, test_size=0.25)# 分析回归目标值的差异。print ("The max target value is", np.max(boston.target))print ("The min target value is", np.min(boston.target))print ("The average target value is", np.mean(boston.target)) ('The max target value is', 50.0) ('The min target value is', 5.0) ('The average target value is', 22.532806324110677) # 从sklearn.preprocessing导入数据标准化模块。from sklearn.preprocessing import StandardScaler# 分别初始化对特征和目标值的标准化器。ss_x = StandardScaler()ss_y = StandardScaler()# 分别对训练和测试数据的特征以及目标值进行标准化处理。X_train = ss_x.fit_transform(X_train)X_test = ss_x.transform(X_test)y_train = ss_y.fit_transform(y_train)y_test = ss_y.transform(y_test)# 从sklearn.linear_model导入LinearRegression。from sklearn.linear_model import LinearRegression# 使用默认配置初始化线性回归器LinearRegression。lr = LinearRegression()# 使用训练数据进行参数估计。lr.fit(X_train, y_train)# 对测试数据进行回归预测。lr_y_predict = lr.predict(X_test)# 从sklearn.linear_model导入SGDRegressor。from sklearn.linear_model import SGDRegressor# 使用默认配置初始化线性回归器SGDRegressor。sgdr = SGDRegressor()# 使用训练数据进行参数估计。sgdr.fit(X_train, y_train)# 对测试数据进行回归预测。sgdr_y_predict = sgdr.predict(X_test)# 使用LinearRegression模型自带的评估模块，并输出评估结果。print 'The value of default measurement of LinearRegression is', lr.score(X_test, y_test)# 从sklearn.metrics依次导入r2_score、mean_squared_error以及mean_absoluate_error用于回归性能的评估。from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error# 使用r2_score模块，并输出评估结果。print 'The value of R-squared of LinearRegression is', r2_score(y_test, lr_y_predict)# 使用mean_squared_error模块，并输出评估结果。print 'The mean squared error of LinearRegression is', mean_squared_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(lr_y_predict))# 使用mean_absolute_error模块，并输出评估结果。print 'The mean absoluate error of LinearRegression is', mean_absolute_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(lr_y_predict))# 使用SGDRegressor模型自带的评估模块，并输出评估结果。print 'The value of default measurement of SGDRegressor is', sgdr.score(X_test, y_test)# 使用r2_score模块，并输出评估结果。print 'The value of R-squared of SGDRegressor is', r2_score(y_test, sgdr_y_predict)# 使用mean_squared_error模块，并输出评估结果。print 'The mean squared error of SGDRegressor is', mean_squared_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(sgdr_y_predict))# 使用mean_absolute_error模块，并输出评估结果。print 'The mean absoluate error of SGDRegressor is', mean_absolute_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(sgdr_y_predict)) The value of default measurement of SGDRegressor is 0.659853975749 The value of R-squared of SGDRegressor is 0.659853975749 The mean squared error of SGDRegressor is 26.3753630607 The mean absoluate error of SGDRegressor is 3.55075990424 2.1.2.2 支持向量机模型介绍：与分类中的解释一致，只是用法不同，前者用来分类，而这里进行回归预测，具体的数值预测（在回归中可以对SVM配置不同的核函数）。数据描述：同上文支持向量机分类的数据性能分析：就不同的核函数装配下的支持向量机回归模型在测试集上的回归性能做出评估。会发现在不同的核函数下存在着很大的性能差异，在此例中使用了径向量（Radial basis function）核函数对特征进行非线性映射之后，支持向量机展现了最佳的回归性能。特点分析：可以帮助我们在海量甚至更高维度的数据中筛选出对预测任务最为有效的少数训练样本。这样不仅节省了模型学习所需要的数据内存，同时也提高了模型的预测性能。然后要获得此性能，就必须付出更多的计算代价（CPU资源和计算时间）。不同核函数下性能有差异，所以要多尝试几种核函数模型。核函数：核函数就是通过某种函数计算，将原有的特征映射到更高的维度空间，从而尽可能的达到新的高纬度特征线性可分程度。12345678910111213141516171819202122232425262728293031323334353637383940414243# 从sklearn.svm中导入支持向量机（回归）模型。from sklearn.svm import SVR# 使用线性核函数配置的支持向量机进行回归训练，并且对测试样本进行预测。linear_svr = SVR(kernel='linear')linear_svr.fit(X_train, y_train)linear_svr_y_predict = linear_svr.predict(X_test)# 使用多项式核函数配置的支持向量机进行回归训练，并且对测试样本进行预测。poly_svr = SVR(kernel='poly')poly_svr.fit(X_train, y_train)poly_svr_y_predict = poly_svr.predict(X_test)# 使用径向基核函数配置的支持向量机进行回归训练，并且对测试样本进行预测。rbf_svr = SVR(kernel='rbf')rbf_svr.fit(X_train, y_train)rbf_svr_y_predict = rbf_svr.predict(X_test)# 使用R-squared、MSE和MAE指标对三种配置的支持向量机（回归）模型在相同测试集上进行性能评估。from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_errorprint 'R-squared value of linear SVR is', linear_svr.score(X_test, y_test)print 'The mean squared error of linear SVR is', mean_squared_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(linear_svr_y_predict))print 'The mean absoluate error of linear SVR is', mean_absolute_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(linear_svr_y_predict)) R-squared value of linear SVR is 0.65171709743 The mean squared error of linear SVR is 0.31360572651 The mean absoluate error of linear SVR is 0.369259810963print 'R-squared value of Poly SVR is', poly_svr.score(X_test, y_test)print 'The mean squared error of Poly SVR is', mean_squared_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(poly_svr_y_predict))print 'The mean absoluate error of Poly SVR is', mean_absolute_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(poly_svr_y_predict) R-squared value of Poly SVR is 0.404454058003 The mean squared error of Poly SVR is 0.536249745341 The mean absoluate error of Poly SVR is 0.404323590015print 'R-squared value of RBF SVR is', rbf_svr.score(X_test, y_test)print 'The mean squared error of RBF SVR is', mean_squared_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(rbf_svr_y_predict))print 'The mean absoluate error of RBF SVR is', mean_absolute_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(rbf_svr_y_predict)) R-squared value of RBF SVR is 0.756406891227 The mean squared error of RBF SVR is 0.21933948892 The mean absoluate error of RBF SVR is 0.280992190922 2.1.2.3 K近邻模型介绍：不需要训练参数，对于待预测的测试样本选取K个最邻近的点进行回归值的决策。（自然也衍生出了待测试样本回归值的不同方式，即到底是对K个临近目标值使用普通的算术平均算法，还是同时考虑距离的差异进行加权平均，一下代码也会配置不同配置的K临近回归模型来比较性能差异）【预测方式为平均回归的K临近回归和加权回归的K临近回归】数据描述：仍然使用波士顿房价数据。性能分析：仍然使用R-squared、MSE、MAE三种指标。发现此例中加权平均的方式回归预测房价更具有好的预测性。特点分析：K临近回归于K临近分类一样，都属于无参数模型，同样没有训练的过程。但是模型的计算方法非常直观。123456789101112131415161718192021222324252627282930# 从sklearn.neighbors导入KNeighborRegressor（K近邻回归器）。from sklearn.neighbors import KNeighborsRegressor# 初始化K近邻回归器，并且调整配置，使得预测的方式为平均回归：weights='uniform'。uni_knr = KNeighborsRegressor(weights='uniform')uni_knr.fit(X_train, y_train)uni_knr_y_predict = uni_knr.predict(X_test)# 初始化K近邻回归器，并且调整配置，使得预测的方式为根据距离加权回归：weights='distance'。dis_knr = KNeighborsRegressor(weights='distance')dis_knr.fit(X_train, y_train)dis_knr_y_predict = dis_knr.predict(X_test)# 使用R-squared、MSE以及MAE三种指标对平均回归配置的K近邻模型在测试集上进行性能评估。print 'R-squared value of uniform-weighted KNeighorRegression:', uni_knr.score(X_test, y_test)print 'The mean squared error of uniform-weighted KNeighorRegression:', mean_squared_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(uni_knr_y_predict))print 'The mean absoluate error of uniform-weighted KNeighorRegression', mean_absolute_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(uni_knr_y_predict)) R-squared value of uniform-weighted KNeighorRegression: 0.690345456461 The mean squared error of uniform-weighted KNeighorRegression: 0.278823443175 The mean absoluate error of uniform-weighted KNeighorRegression 0.319836405678 # 使用R-squared、MSE以及MAE三种指标对根据距离加权回归配置的K近邻模型在测试集上进行性能评估。print 'R-squared value of distance-weighted KNeighorRegression:', dis_knr.score(X_test, y_test)print 'The mean squared error of distance-weighted KNeighorRegression:', mean_squared_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(dis_knr_y_predict))print 'The mean absoluate error of distance-weighted KNeighorRegression:', mean_absolute_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(dis_knr_y_predict)) R-squared value of distance-weighted KNeighorRegression: 0.719758997016 The mean squared error of distance-weighted KNeighorRegression: 0.252338494627 The mean absoluate error of distance-weighted KNeighorRegression: 0.302274187769 2.1.2.4 回归树模型介绍：回归树的叶节点的数据类型不是离散型，而是连续型的。决策树每个叶节点依照训练数据表现的概率倾向决定了其最终的预测类别，而回归树的叶节点却是一个个具体的值，从预测连续这个意义上严格来讲，回归树不能称为回归算法，因为回归树的叶子节点返回的是一团训练数据的均值，而不是具体的连续的预测值。数据描述：仍然采用波士顿房价数据。性能分析：效果显著优于LinearRegression和SGDRegression,所以可知道美国波士顿房价预测问题的特征与目标之间存在一定的非线性关系。特点分析： - 优点 - 数模型可以解决非线性特征的问题。 - 树模型不要求对特征数据进行标准化和统一量化，即数值型和类别型特征都可以直接被应用在树模型的构建和预测过程中 - 因为上面的优点，树模型也可以直观的输出决策过程，使得预测结果具有可解释性。 - 缺点 - 因为其可以解决复杂的非线性拟合问题，所以更加容易因为模型搭建过于复杂而丧失对新数据预测的精度（泛化力） - 树模型从上至下的预测流程会因为数据细微的更改而发生较大的结构变化，因此预测稳定下较差 - 依托训练数据构架的最佳树模型是个NP-hard问题，所以有限时间内无法找到最优解，所以经常借助集成模型，在多个次优解中找到更高的模型性能。 1234567891011121314151617# 从sklearn.tree中导入DecisionTreeRegressor。from sklearn.tree import DecisionTreeRegressor# 使用默认配置初始化DecisionTreeRegressor。dtr = DecisionTreeRegressor()# 用波士顿房价的训练数据构建回归树。dtr.fit(X_train, y_train)# 使用默认配置的单一回归树对测试数据进行预测，并将预测值存储在变量dtr_y_predict中。dtr_y_predict = dtr.predict(X_test)# 使用R-squared、MSE以及MAE指标对默认配置的回归树在测试集上进行性能评估。print 'R-squared value of DecisionTreeRegressor:', dtr.score(X_test, y_test)print 'The mean squared error of DecisionTreeRegressor:', mean_squared_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(dtr_y_predict))print 'The mean absoluate error of DecisionTreeRegressor:', mean_absolute_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(dtr_y_predict)) R-squared value of DecisionTreeRegressor: 0.692592549712 The mean squared error of DecisionTreeRegressor: 0.276800084273 The mean absoluate error of DecisionTreeRegressor: 0.340675749137 2.1.2.5 集成模型模型介绍：同样有随机森林回归和随机梯度提升树模型，此外还加入了随机森林的变种：极限随机森林（Extremely Randomized Tree）,与普通随机森林模型不同的是，极限随机森林在每当构建一棵树的分裂节点（node）的时候，不会任意选取特征，而是先随机收集一部分特征，然后利用信息熵（Information Gain）和基尼不纯性（Gini Impurity）等指标挑选最佳节点特征。数据描述：仍然是波士顿房价数据。性能分析：同样采用R-Squared、MAE、MSE三种预测指标。特点分析：许多业界从事商业分析系统开发和搭建的工作者更加青睐集成模型，并且经常以这些模型的性能表现为基准，与新设计的其他模型性能进行对比。虽然这些集成模型在训练过程中需要耗费更多的时间，但是往往可以提供更高的表现性能和更好的稳定性。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 从sklearn.ensemble中导入RandomForestRegressor、ExtraTreesGressor以及GradientBoostingRegressor。from sklearn.ensemble import RandomForestRegressor, ExtraTreesRegressor, GradientBoostingRegressor# 使用RandomForestRegressor训练模型，并对测试数据做出预测，结果存储在变量rfr_y_predict中。rfr = RandomForestRegressor()rfr.fit(X_train, y_train)rfr_y_predict = rfr.predict(X_test)# 使用ExtraTreesRegressor训练模型，并对测试数据做出预测，结果存储在变量etr_y_predict中。etr = ExtraTreesRegressor()etr.fit(X_train, y_train)etr_y_predict = etr.predict(X_test)# 使用GradientBoostingRegressor训练模型，并对测试数据做出预测，结果存储在变量gbr_y_predict中。gbr = GradientBoostingRegressor()gbr.fit(X_train, y_train)gbr_y_predict = gbr.predict(X_test)# 使用R-squared、MSE以及MAE指标对默认配置的随机回归森林在测试集上进行性能评估。print 'R-squared value of RandomForestRegressor:', rfr.score(X_test, y_test)print 'The mean squared error of RandomForestRegressor:', mean_squared_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(rfr_y_predict))print 'The mean absoluate error of RandomForestRegressor:', mean_absolute_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(rfr_y_predict)) R-squared value of RandomForestRegressor: 0.840592481412 The mean squared error of RandomForestRegressor: 0.143535931018 The mean absoluate error of RandomForestRegressor: 0.237149352743 # 使用R-squared、MSE以及MAE指标对默认配置的极端回归森林在测试集上进行性能评估。print 'R-squared value of ExtraTreesRegessor:', etr.score(X_test, y_test)print 'The mean squared error of ExtraTreesRegessor:', mean_squared_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(etr_y_predict))print 'The mean absoluate error of ExtraTreesRegessor:', mean_absolute_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(etr_y_predict))# 利用训练好的极端回归森林模型，输出每种特征对预测目标的贡献度。print np.sort(zip(etr.feature_importances_, boston.feature_names), axis=0) R-squared value of ExtraTreesRegessor: 0.835582207186 The mean squared error of ExtraTreesRegessor: 0.148047351696 The mean absoluate error of ExtraTreesRegessor: 0.250649106588 [['0.0148831885456' 'AGE'] ['0.0164137658185' 'B'] ['0.0186619396796' 'CHAS'] ['0.0189673119564' 'CRIM'] ['0.0205761600375' 'DIS'] ['0.0255369237188' 'INDUS'] ['0.025890473054' 'LSTAT'] ['0.0295863020532' 'NOX'] ['0.0309240655832' 'PTRATIO'] ['0.0417999802912' 'RAD'] ['0.0463531289155' 'RM'] ['0.314967578338' 'TAX'] ['0.395439182008' 'ZN']] # 使用R-squared、MSE以及MAE指标对默认配置的梯度提升回归树在测试集上进行性能评估。print 'R-squared value of GradientBoostingRegressor:', gbr.score(X_test, y_test)print 'The mean squared error of GradientBoostingRegressor:', mean_squared_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(gbr_y_predict))print 'The mean absoluate error of GradientBoostingRegressor:', mean_absolute_error(ss_y.inverse_transform(y_test), ss_y.inverse_transform(gbr_y_predict)) R-squared value of GradientBoostingRegressor: 0.842602871434 The mean squared error of GradientBoostingRegressor: 12.2047771094 The mean absoluate error of GradientBoostingRegressor: 2.28597618665 2.2 无监督学习无监督学习着重于发现数据本身的分布特点，与监督学习不同，无监督学习不需要对数据进行标记。这样，在节省大量人工的同时，也让可以利用的数据规模变得不可限量。 从功能角度来说无监督学习模型帮助我们发现数据的“群落”（聚类，分布情况），同样也可以寻找离群的样本，另外对于特征维度非常高的数据样本，我们同样可以通过无监督学习对数据进行降维，但是保留最具有区分性的低纬度特征。这些都是在海量数据处理中非常实用的技术。 2.2.1 数据聚类数据聚类是无监督学习的主流应用之一，最为经典并且易用的聚类模型就是K-Means算法。该算法要求我们预先设定聚类的个数，然后不断更新聚类中心，经过几轮这样的迭代后，最终的目标就是让所有数据点到其所属数据类中心距离的平方和趋于稳定。 2.2.1.1 K均值算法(K-means)模型介绍：K-means的流程可以分为四个阶段。 - 1.随机分布K个特徵空间内的点作为初始的聚类中心。 - 2.然后，对于根据每个数据的特性向量从K个聚类中心中寻找距离最近的一个，并且把该数据标记为从属于这个聚类中心。 - 3.接着，在所有的数据都被标记过聚类中心之后，根据这些数据新分配的类簇，重新对K个聚类中心做计算。 - 4.如果一轮下来，所有的数据点从属的聚类中心与上一次的分配的类簇没有变化，那么迭代可以停止，否则回到步骤2继续循环。 过程如下图： 数据描述：手写体数字图像数据的完整版本。性能分析：1.如果被用来评估的数据本身带有正确的类别信息，就使用Adjusted Rand Index(ARI),这个指标与分类问题中计算准确性的方法类似，同时也兼顾到了类簇无法和分类标记一一对应的问题。特点分析：K-means聚类模型所采用的迭代算法，直观易懂并且非常实用，但有2大缺陷：1.容易收敛到局部最优解2.需要预先设定簇的数量。为了解决以上问题可以参考肘部观察法。从这个拐点对应的K开始，类簇中心的增加不会破坏数据聚类的结构。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 分别导入numpy、matplotlib以及pandas，用于数学运算、作图以及数据分析。import numpy as npimport matplotlib.pyplot as pltimport pandas as pd# 使用pandas分别读取训练数据与测试数据集。digits_train = pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/optdigits/optdigits.tra', header=None)digits_test = pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/optdigits/optdigits.tes', header=None)# 从训练与测试数据集上都分离出64维度的像素特征与1维度的数字目标。X_train = digits_train[np.arange(64)]y_train = digits_train[64]X_test = digits_test[np.arange(64)]y_test = digits_test[64]# 从sklearn.cluster中导入KMeans模型。from sklearn.cluster import KMeans# 初始化KMeans模型，并设置聚类中心数量为10。kmeans = KMeans(n_clusters=10)kmeans.fit(X_train)# 逐条判断每个测试图像所属的聚类中心。y_pred = kmeans.predict(X_test)# 从sklearn导入度量函数库metrics。from sklearn import metrics# 使用ARI进行KMeans聚类性能评估。print metrics.adjusted_rand_score(y_test, y_pred) 0.671267090907# 导入numpy。import numpy as np# 从sklearn.cluster中导入KMeans算法包。from sklearn.cluster import KMeans# 从sklearn.metrics导入silhouette_score用于计算轮廓系数。from sklearn.metrics import silhouette_scoreimport matplotlib.pyplot as plt# 分割出3*2=6个子图，并在1号子图作图。plt.subplot(3,2,1)# 初始化原始数据点。x1 = np.array([1, 2, 3, 1, 5, 6, 5, 5, 6, 7, 8, 9, 7, 9])x2 = np.array([1, 3, 2, 2, 8, 6, 7, 6, 7, 1, 2, 1, 1, 3])X = np.array(zip(x1, x2)).reshape(len(x1), 2)# 在1号子图做出原始数据点阵的分布。plt.xlim([0, 10])plt.ylim([0, 10])plt.title('Instances')plt.scatter(x1, x2)colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'b']markers = ['o', 's', 'D', 'v', '^', 'p', '*', '+']clusters = [2, 3, 4, 5, 8]subplot_counter = 1sc_scores = []for t in clusters: subplot_counter += 1 plt.subplot(3, 2, subplot_counter) kmeans_model = KMeans(n_clusters=t).fit(X) for i, l in enumerate(kmeans_model.labels_): plt.plot(x1[i], x2[i], color=colors[l], marker=markers[l], ls='None') plt.xlim([0, 10]) plt.ylim([0, 10]) sc_score = silhouette_score(X, kmeans_model.labels_, metric='euclidean') sc_scores.append(sc_score)# 绘制轮廓系数与不同类簇数量的直观显示图。 plt.title('K = %s, silhouette coefficient= %0.03f' %(t, sc_score)) # 绘制轮廓系数与不同类簇数量的关系曲线。plt.figure()plt.plot(clusters, sc_scores, '*-')plt.xlabel('Number of Clusters')plt.ylabel('Silhouette Coefficient Score')plt.show() 123456789101112131415161718192021222324252627282930313233343536373839404142# 导入必要的工具包。import numpy as npfrom sklearn.cluster import KMeansfrom scipy.spatial.distance import cdistimport matplotlib.pyplot as plt# 使用均匀分布函数随机三个簇，每个簇周围10个数据样本。cluster1 = np.random.uniform(0.5, 1.5, (2, 10))cluster2 = np.random.uniform(5.5, 6.5, (2, 10))cluster3 = np.random.uniform(3.0, 4.0, (2, 10))# 绘制30个数据样本的分布图像。X = np.hstack((cluster1, cluster2, cluster3)).Tprint X.shapeprint X.shape[0]plt.scatter(X[:,0], X[:, 1])plt.xlabel('x1')plt.ylabel('x2')plt.show()# 测试9种不同聚类中心数量下，每种情况的聚类质量，并作图。K = range(1, 10)meandistortions = []for k in K: kmeans = KMeans(n_clusters=k) kmeans.fit(X) meandistortions.append(sum(np.min(cdist(X, kmeans.cluster_centers_, 'euclidean'), axis=1))/X.shape[0]) plt.plot(K, meandistortions, 'bx-')plt.xlabel('k')plt.ylabel('Average Dispersion')plt.title('Selecting k with the Elbow Method')plt.show() [[ 0.65437221 0.60824287 1.37405521 1.06883557 0.56351077 0.83423208 0.74072001 0.76639986 1.29815858 0.54004198] [ 0.95506086 1.28734408 0.58704345 1.21770559 0.97949615 0.9624782 1.39353203 1.13024559 1.1295162 0.86733591]] (30, 2) 30 2.2.2 特征降维模型介绍：特征降维是无监督学习的另一个应用，其一我们经常在实际项目中遭遇特征维度非常高的训练样本，往往无法借助自己领域的知识人工构建有效特征，其二在数据表现上，我们无法用肉眼观测到超过3个维度的特征。因此特征将为不仅重构了有效的低纬度特征向量，同时也为数据展现提供了可能，在数据降维方法中，主成分分析（Principal Component Analysis）是最为经典和使用的特征降维技术，特别是在辅助图像识别方面，尤为突出的表现。以下示例一PCA压缩为例。 2.2.2.1 主成分分析(Principal Component Analysis:PCA)数据描述：使用手写字体图像全集数据。性能分析：可以在降维后再用数据进行训练，再用于分类，与未经过降维分类的实验来进行比较，来验证效果的好坏。会发现经过PCA特征亚索和重建后，特征数据会损失2%左右的预测准确性，但是相比于原始数据的六十四维度的特征而言，使用PCA会压缩并且降低68.75%的维度。在于海量数据时候非常有效。特点分析：降维/压缩问题则是选取数据具有代表性的特征，在保持数据多样性的基础上，规避掉大量的特征冗余和噪声，不过这个过程也很有可能会损失一些有用的模式信息，经过大量的时间证明，相较于损失的少部分模型性能，维度压缩能够节省大量用于模型训练的时间，这样一来，使得PCA所带来的模型総合効率变得更为划算。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116# 导入numpy工具包。import numpy as np# 初始化一个2*2的线性相关矩阵。M = np.array([[1, 2], [2, 4]])# 计算2*2线性相关矩阵的秩。np.linalg.matrix_rank(M, tol=None) 1 # 导入pandas用于数据读取和处理。import pandas as pd# 从互联网读入手写体图片识别任务的训练数据，存储在变量digits_train中。digits_train = pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/optdigits/optdigits.tra', header=None)# 从互联网读入手写体图片识别任务的测试数据，存储在变量digits_test中。digits_test = pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/optdigits/optdigits.tes', header=None)# 分割训练数据的特征向量和标记。X_digits = digits_train[np.arange(64)]y_digits = digits_train[64]# 从sklearn.decomposition导入PCA。 from sklearn.decomposition import PCA# 初始化一个可以将高维度特征向量（64维）压缩至2个维度的PCA。 estimator = PCA(n_components=2)X_pca = estimator.fit_transform(X_digits)# 显示10类手写体数字图片经PCA压缩后的2维空间分布。 from matplotlib import pyplot as pltdef plot_pca_scatter(): colors = ['black', 'blue', 'purple', 'yellow', 'white', 'red', 'lime', 'cyan', 'orange', 'gray'] for i in xrange(len(colors)): px = X_pca[:, 0][y_digits.as_matrix() == i] py = X_pca[:, 1][y_digits.as_matrix()== i] plt.scatter(px, py, c=colors[i]) plt.legend(np.arange(0,10).astype(str)) plt.xlabel('First Principal Component') plt.ylabel('Second Principal Component') plt.show() plot_pca_scatter()# 对训练数据、测试数据进行特征向量（图片像素）与分类目标的分隔。X_train = digits_train[np.arange(64)]y_train = digits_train[64]X_test = digits_test[np.arange(64)]y_test = digits_test[64]# 导入基于线性核的支持向量机分类器。from sklearn.svm import LinearSVC# 使用默认配置初始化LinearSVC，对原始64维像素特征的训练数据进行建模，并在测试数据上做出预测，存储在y_predict中。svc = LinearSVC()svc.fit(X_train, y_train)y_predict = svc.predict(X_test)# 使用PCA将原64维的图像数据压缩到20个维度。estimator = PCA(n_components=20)# 利用训练特征决定（fit）20个正交维度的方向，并转化（transform）原训练特征。pca_X_train = estimator.fit_transform(X_train)# 测试特征也按照上述的20个正交维度方向进行转化（transform）。pca_X_test = estimator.transform(X_test)# 使用默认配置初始化LinearSVC，对压缩过后的20维特征的训练数据进行建模，并在测试数据上做出预测，存储在pca_y_predict中。pca_svc = LinearSVC()pca_svc.fit(pca_X_train, y_train)pca_y_predict = pca_svc.predict(pca_X_test)# 从sklearn.metrics导入classification_report用于更加细致的分类性能分析。from sklearn.metrics import classification_report# 对使用原始图像高维像素特征训练的支持向量机分类器的性能作出评估。print svc.score(X_test, y_test)print classification_report(y_test, y_predict, target_names=np.arange(10).astype(str))# 对使用PCA压缩重建的低维图像特征训练的支持向量机分类器的性能作出评估。print pca_svc.score(pca_X_test, y_test)print classification_report(y_test, pca_y_predict, target_names=np.arange(10).astype(str)) 0.930996104619 precision recall f1-score support 0 0.99 0.98 0.99 178 1 0.94 0.84 0.89 182 2 0.99 0.97 0.98 177 3 0.97 0.92 0.94 183 4 0.95 0.97 0.96 181 5 0.89 0.96 0.93 182 6 0.99 0.98 0.99 181 7 0.98 0.90 0.94 179 8 0.78 0.91 0.84 174 9 0.86 0.89 0.87 180 avg / total 0.93 0.93 0.93 1797 0.909293266555 precision recall f1-score support 0 0.96 0.96 0.96 178 1 0.78 0.85 0.82 182 2 0.96 0.98 0.97 177 3 0.99 0.89 0.94 183 4 0.95 0.92 0.93 181 5 0.84 0.97 0.90 182 6 0.96 0.97 0.96 181 7 0.93 0.92 0.93 179 8 0.83 0.83 0.83 174 9 0.92 0.82 0.86 180 avg / total 0.91 0.91 0.91 1797]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java语言基础_反射、动态代理、JDK新特性]]></title>
      <url>%2F2017%2F05%2F16%2Fjava%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E3%80%81JDK%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
      <content type="text"><![CDATA[01_反射(类的加载概述和加载时机) A:类的加载概述 当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化。 加载 就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。 连接 验证 是否有正确的内部结构，并和其他类协调一致 准备 负责为类的静态成员分配内存，并设置默认初始化值 解析 将类的二进制数据中的符号引用替换为直接引用 初始化 就是我们以前讲过的初始化步骤 B:加载时机 创建类的实例 访问类的静态变量，或者为静态变量赋值 调用类的静态方法 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 02_反射(类加载器的概述和分类) A:类加载器的概述 负责将.class文件加载到内存中，并为之生成对应的Class对象。虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。 B:类加载器的分类 Bootstrap ClassLoader 根类加载器 Extension ClassLoader 扩展类加载器 Sysetm ClassLoader 系统类加载器 C:类加载器的作用 Bootstrap ClassLoader 根类加载器 也被称为引导类加载器，负责Java核心类的加载 比如System,String等。在JDK中JRE的lib目录下rt.jar文件中 Extension ClassLoader 扩展类加载器 负责JRE的扩展目录中jar包的加载。 在JDK中JRE的lib目录下ext目录 Sysetm ClassLoader 系统类加载器 负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径 03_反射(反射概述) A:反射概述 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意一个方法和属性； 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 要想解剖一个类,必须先要获取到该类的字节码文件对象。 而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的对象。 B:三种方式 a:Object类的getClass()方法,判断两个对象是否是同一个字节码文件 b:静态属性class,锁对象 c:Class类中静态方法forName(),读取配置文件 C:案例演示 获取class文件对象的三种方式 04_反射(Class.forName()读取配置文件举例) 榨汁机(Juicer)榨汁的案例 分别有水果(Fruit)苹果(Apple)香蕉(Banana)桔子(Orange)榨汁(squeeze) public class Demo2_Reflect { /** * 榨汁机(Juicer)榨汁的案例 * 分别有水果(Fruit)苹果(Apple)香蕉(Banana)桔子(Orange)榨汁(squeeze) * @throws Exception */ public static void main(String[] args) throws Exception { /*Juicer j = new Juicer(); //j.run(new Apple()); j.run(new Orange());*/ BufferedReader br = new BufferedReader(new FileReader(&quot;config.properties&quot;)); //创建输入流对象,关联配置文件 Class&lt;?&gt; clazz = Class.forName(br.readLine()); //读取配置文件一行内容,获取该类的字节码对象 Fruit f = (Fruit) clazz.newInstance(); //通过字节码对象创建实例对象 Juicer j = new Juicer(); j.run(f); } } interface Fruit { public void squeeze(); } class Apple implements Fruit { public void squeeze() { System.out.println(&quot;榨出一杯苹果汁儿&quot;); } } class Orange implements Fruit { public void squeeze() { System.out.println(&quot;榨出一杯桔子汁儿&quot;); } } class Juicer { public void run(Fruit f) { f.squeeze(); } } 05_反射(通过反射获取带参构造方法并使用) Constructor Class类的newInstance()方法是使用该类无参的构造函数创建对象, 如果一个类没有无参的构造函数, 就不能这样创建了,可以调用Class类的getConstructor(String.class,int.class)方法获取一个指定的构造函数然后再调用Constructor类的newInstance(“张三”,20)方法创建对象 06_反射(通过反射获取成员变量并使用) Field Class.getField(String)方法可以获取类中的指定字段(可见的), 如果是私有的可以用getDeclaedField(“name”)方法获取,通过set(obj, “李四”)方法可以设置指定对象上该字段的值, 如果是私有的需要先调用setAccessible(true)设置访问权限,用获取的指定的字段调用get(obj)可以获取指定对象中该字段的值 07_反射(通过反射获取方法并使用) Method Class.getMethod(String, Class…) 和 Class.getDeclaredMethod(String, Class…)方法可以获取类中的指定方法,调用invoke(Object, Object…)可以调用该方法,Class.getMethod(“eat”) invoke(obj) Class.getMethod(“eat”,int.class) invoke(obj,10) 08_反射(通过反射越过泛型检查) A:案例演示 ArrayList的一个对象，在这个集合中添加一个字符串数据，如何实现呢？ 09_反射(通过反射写一个通用的设置某个对象的某个属性为指定的值) A:案例演示 public void setProperty(Object obj, String propertyName, Object value){}，此方法可将obj对象中名为propertyName的属性的值设置为value。 10_反射(练习) 已知一个类，定义如下： package cn.itcast.heima; public class DemoClass {public void run() { System.out.println(&quot;welcome to heima!&quot;); } } (1) 写一个Properties格式的配置文件，配置类的完整名称。 (2) 写一个程序，读取这个Properties配置文件，获得类的完整名称并加载这个类，用反射的方式运行run方法。 11_反射(动态代理的概述和实现) A:动态代理概述 代理：本来应该自己做的事情，请了别人来做，被请的人就是代理对象。 举例：春节回家买票让人代买 动态代理：在程序运行过程中产生的这个对象,而程序运行过程中产生对象其实就是我们刚才反射讲解的内容，所以，动态代理其实就是通过反射来生成一个代理 在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。JDK提供的代理只能针对接口做代理。我们有更强大的代理cglib，Proxy类中的方法创建动态代理类对象 public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) 最终会调用InvocationHandler的方法 InvocationHandler Object invoke(Object proxy,Method method,Object[] args) 12345678910111213141516171819202122public interface User &#123; public void add(); public void delete();&#125;public class UserImp implements User &#123; @Override public void add() &#123; //System.out.println("权限校验"); System.out.println("添加功能"); //System.out.println("日志记录"); &#125; @Override public void delete() &#123; //System.out.println("权限校验"); System.out.println("删除功能"); //System.out.println("日志记录"); &#125;&#125; 12345678910111213141516171819import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler &#123; private Object target; public MyInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("权限校验"); method.invoke(target, args); //执行被代理target对象的方法 System.out.println("日志记录"); return null; &#125;&#125; 12345678910111213141516171819import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class MyInvocationHandler implements InvocationHandler &#123; private Object target; public MyInvocationHandler(Object target) &#123; this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("权限校验"); method.invoke(target, args); //执行被代理target对象的方法 System.out.println("日志记录"); return null; &#125;&#125; 12345678910111213141516171819202122232425import java.lang.reflect.Proxy;public class Test &#123; /** * @param args */ public static void main(String[] args) &#123; /*UserImp ui = new UserImp(); ui.add(); ui.delete(); System.out.println("-------------------------------");*/ /* * public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces, * InvocationHandler h) */ MyInvocationHandler m = new MyInvocationHandler(ui); User u = (User)Proxy.newProxyInstance(ui.getClass().getClassLoader(), ui.getClass().getInterfaces(), m); u.add(); (这样会在add前面加上校验以及日志) u.delete();(这样会在delete前面加上校验以及日志) &#125;&#125; 12_设计模式(模版(Template)设计模式概述和使用) A:模版设计模式概述 模版方法模式就是定义一个算法的骨架，而将具体的算法延迟到子类中来实现 B:优点和缺点 a:优点 使用模版方法模式，在定义算法骨架的同时，可以很灵活的实现具体的算法，满足用户灵活多变的需求 b:缺点 如果算法骨架有修改的话，则需要修改抽象类1,装饰2,单例3,简单工厂4,工厂方法5,适配器6,模版 13_JDK5新特性(自己实现枚举类) A:枚举概述 是指将变量的值一一列出来,变量的值只限于列举出来的值的范围内。举例：一周只有7天，一年只有12个月等。 B:回想单例设计模式：单例类是一个类只有一个实例 那么多例类就是一个类有多个实例，但不是无限个数的实例，而是有限个数的实例。这才能是枚举类。 C:案例演示 自己实现枚举类1,自动拆装箱2,泛型3,可变参数4,静态导入5,增强for循环6,互斥锁7,枚举 14_JDK5新特性(通过enum实现枚举类) A:案例演示 通过enum实现枚举类 15_JDK5新特性(枚举的注意事项) A:案例演示 定义枚举类要用关键字enum 所有枚举类都是Enum的子类 枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略 枚举类可以有构造器，但必须是private的，它默认的也是private的。 枚举类也可以有抽象方法，但是枚举项必须重写该方法 枚举在switch语句中的使用 16_JDK5新特性(枚举类的常见方法) A:枚举类的常见方法 int ordinal() int compareTo(E o) String name() String toString() T valueOf(Class type,String name) values() 此方法虽然在JDK文档中查找不到，但每个枚举类都具有该方法，它遍历枚举类的所有枚举值非常方便 B:案例演示 枚举类的常见方法 17_JDK7新特性(JDK7的六个新特性回顾和讲解) A:二进制字面量 B:数字字面量可以出现下划线 C:switch 语句可以用字符串 D:泛型简化,菱形泛型 E:异常的多个catch合并,每个异常用或| F:try-with-resources 语句 18_JDK8新特性(JDK8的新特性) 接口中可以定义有方法体的方法,如果是非静态,必须用default修饰 如果是静态的就不用了 class Test { public void run() { final int x = 10; class Inner { public void method() { System.out.println(x); } } Inner i = new Inner(); i.method(); } } 局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么? 因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mysql基本语法总结]]></title>
      <url>%2F2017%2F04%2F27%2Fmysql%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[新建数据库1234CREATE DATABASE &lt;数据库名字&gt;;show databases;use 数据库名; 数据库建表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758create table employee( id int(4) unique, name varchar(20), age int(4) default 15, gender enum(&apos;male&apos;,&apos;female&apos;), salary int ); insert into employee values (1,&apos;fang&apos;,23,1);//male insert into employee values (2,&apos;fang&apos;,23,2);//femalecreate table employee( id int(4) primary key not null auto_increment, name varchar(20), age int(4), salary int );create table employee( id int(4) primary key not null auto_increment, name varchar(20), age int(4) defalut , salary int );create table employee( id int(4), name varchar(20), age int(4), salary int, primary key(id) );---------------------------create table student(sid INT(10) PRIMARY KEY,sname CHAR(20),gender ENUM(&apos;male&apos;,&apos;female&apos;));CREATE TABLE course(cid INT(10) PRIMARY KEY,cname char(20));外键约束CREATE TABLE mark(mid INT(10) PRIMARY KEY,sid INT(10),cid INT(10),score INT(10),CONSTRAINT mark_sid_fk FOREIGN KEY(sid) REFERENCES student(sid),CONSTRAINT mark_cid_fk FOREIGN KEY(cid) REFERENCES course(cid)); 表查询123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104show column from student;select name,age from employee;select name,age from employee where age&gt;25;select name,age,phone from employee where name=&apos;mary&apos;;select name,age from employee where age&lt;25 or age&gt;30;select name,age from employee where age&gt;25 and age&lt;30;select name,age from employee where age between 25 and 30;select name,age,in_dpt from employee where in_dpt in (&apos;dpt3&apos;,&apos;dpt4&apos;);select name,age,in_dpt from employee where in_dpt not in (&apos;dpt1&apos;,&apos;dpt3&apos;);_代表任意一个未指定的字符，%代表不定个未指定的字符select name,age,phone from employee where phone like &apos;110__&apos;;select name,age,phone from employee where name like &apos;J%&apos;;select name,age,in_dpt from employee where in_dpt in (&apos;dpt3&apos;,&apos;dpt4&apos;);降序排列SELECT name,age,salary,phone FROM employee ORDER BY salary DESC;升序排列,默认也是升序SELECT name,age,salary,phone FROM employee ORDER BY salary ASC;SQL内置函数和计算SELECT MAX(salary) AS max_salary,MIN(salary) FROM employee;SELECT of_dpt,COUNT(proj_name) AS count_project FROM projectWHERE of_dpt IN(SELECT in_dpt FROM employee WHERE name=&apos;Tom&apos;);----------------------------------------------------以下两句等价 内连接SELECT id,name,people_numFROM employee,departmentWHERE employee.in_dpt = department.dpt_nameORDER BY id;SELECT id,name,people_numFROM employee JOIN departmentON employee.in_dpt = department.dpt_nameORDER BY id;------------------------------------------------------外联接。外联接可以是左向外联接、右向外联接或完整外部联接。 在 FROM子句中指定外联接时，可以由下列几组关键字中的一组指定： 1）LEFT JOIN或LEFT OUTER JOIN 左向外联接的结果集包括 LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。 2）RIGHT JOIN 或 RIGHT OUTER JOIN 右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。 3）FULL JOIN 或 FULL OUTER JOIN完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 3、交叉联接 交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。用 CROSS JOINFROM 子句中的表或视图可通过内联接或完整外部联接按任意顺序指定；但是，用左或右向外联接指定表或视图时，表或视图的顺序很重要。有关使用左或右向外联接排列表的更多信息，请参见使用外联接。 例子： ------------------------------------------------- a表 id name b表 id job parent_id 1 张3 1 23 1 2 李四 2 34 2 3 王武 3 34 4 a.id同parent_id 存在关系 -------------------------------------------------- 1） 内连接 select a.*,b.* from a inner join b on a.id=b.parent_id 结果是 1 张3 1 23 1 2 李四 2 34 2 2）左连接 select a.*,b.* from a left join b on a.id=b.parent_id 结果是 1 张3 1 23 1 2 李四 2 34 2 3 王武 null 3） 右连接 select a.*,b.* from a right join b on a.id=b.parent_id 结果是 1 张3 1 23 1 2 李四 2 34 2 null 3 34 4 4） 完全连接 select a.*,b.* from a full join b on a.id=b.parent_id 结果是 1 张3 1 23 1 2 李四 2 34 2 null 3 34 4 3 王武 null 数据库的修改123456789101112131415161718192021222324252627282930313233343536删除数据库DROP DATABASE test_01;重命名表名RENAME TABLE 原名 TO 新名字;ALTER TABLE 原名 RENAME 新名;ALTER TABLE 原名 RENAME TO 新名;删除表DROP TABLE 表名字;表中增加字段ALTER TABLE 表名字 ADD COLUMN 列名字 数据类型 约束;或： ALTER TABLE 表名字 ADD 列名字 数据类型 约束;增加字段在一地列ALTER TABLE employee ADD test INT(10) DEFAULT 11 FIRST;增加字段在age字段后ALTER TABLE employee ADD weight INT(4) DEFAULT 120 after age;删除某一列属性ALTER TABLE 表名字 DROP COLUMN 列名字;或： ALTER TABLE 表名字 DROP 列名字;重命名一列ALTER TABLE 表名字 CHANGE 原列名 新列名 数据类型 约束;ALTER TABLE 表名字 CHANGE height shengao int(4) default 170;改变数据类型ALTER TABLE 表名字 MODIFY 列名字 新数据类型;表中数据修改UPDATE 表名字 SET 列1=值1,列2=值2 WHERE 条件;删除表的一行记录DELETE FROM 表名字 WHERE 条件; 数据库的载入以及备份导入导出123456789101112131415161718192021222324252627282930313233343536373839数据导入恢复source /home/my.sql创建索引ALTER TABLE 表名字 ADD INDEX 索引名 (列名);CREATE INDEX 索引名 ON 表名字 (列名);ALTER TABLE employee ADD INDEX idx_id (id); #在employee表的id列上建立名为idx_id的索引CREATE INDEX idx_name ON employee (name); #在employee表的name列上建立名为idx_name的索引创建视图CREATE VIEW 视图名(列a,列b,列c) AS SELECT 列1,列2,列3 FROM 表名字;CREATE VIEW 视图名(v_name,v_age,v_phone) AS SELECT name,age,phone FROM employee;数据导入LOAD DATA INFILE &apos;文件路径&apos; INTO TABLE 表名字;数据导出SELECT 列1，列2 INTO OUTFILE &apos;文件路径和文件名&apos; FROM 表名字;SELECT * INTO OUTFILE &apos;/tmp/out.txt&apos; FROM employee;非mysql命令行下数据库备份mysqldump -u root 数据库名&gt;备份文件名; #备份整个数据库mysqldump -u root 数据库名 表名字&gt;备份文件名; #备份整个表mysqldump -u root mysql_shiyan &gt; bak.sql;数据库恢复source /tmp/SQL6/MySQL-06.sqlmysql -u root #因为在上一步已经退出了MySQL，现在需要重新登录CREATE DATABASE test; #新建一个名为test的数据库mysql -u root test &lt; bak.sql]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java GC、老年代、新生代]]></title>
      <url>%2F2017%2F04%2F11%2FJava-GC%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E3%80%81%E6%96%B0%E7%94%9F%E4%BB%A3%2F</url>
      <content type="text"><![CDATA[堆内存Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。堆的内存模型大致为： 从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。（本人使用的是 JDK1.6，以下涉及的 JVM 默认值均以该版本为准。）默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间 GC 堆Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC ( 或称为 Major GC )。Minor GC 是发生在新生代中的垃圾收集动作，所采用的是复制算法。新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。 对于年轻代，刚开始创建的对象都是放置在eden区的，而将年轻代分成3个部分，主要是为了生命周期短的对象尽量留在年轻代。当eden区申请不到空间的时候，进行minorGC，把存活的对象拷贝到survior。年老代主要存放生命周期比较长的对象，比如缓存对象。具体jvm内存回收过程描述如下：1、对象在Eden区完成内存分配；2、当Eden区满了，再创建对象，会因为申请不到空间，触发minorGC，进行young(eden+1survivor)区的垃圾回收；3、minorGC时，Eden不能被回收的对象被放入到空的survivor（Eden肯定会被清空），另一个survivor里不能被GC回收的对象也会被放入这个survivor，始终保证一个survivor是空的；4、当做第3步的时候，如果发现survivor满了，将这些对象copy到old区，或者survivor并没有满，但是有些对象已经足够Old，也被放入Old区 XX:MaxTenuringThreshold；5、当Old区被放满的之后，进行fullGC；在知道垃圾回收机制以后，大家可以在对jvm中堆的各个参数进行优化设置，来提高性能。 Java有了GC同样会出现内存泄露问题1.静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。1234567Static Vector v = new Vector(); for (int i = 1; i&lt;100; i++) &#123; Object o = new Object(); v.add(o); o = null; &#125; 在这个例子中，代码栈中存在Vector 对象的引用 v 和 Object 对象的引用 o 。在 For 循环中，我们不断的生成新的对象，然后将其添加到 Vector 对象中，之后将 o 引用置空。问题是当 o 引用被置空后，如果发生 GC，我们创建的 Object 对象是否能够被 GC 回收呢？答案是否定的。因为， GC 在跟踪代码栈中的引用时，会发现 v 引用，而继续往下跟踪，就会发现 v 引用指向的内存空间中又存在指向 Object 对象的引用。也就是说尽管o 引用已经被置空，但是 Object 对象仍然存在其他的引用，是可以被访问到的，所以 GC 无法将其释放掉。如果在此循环之后， Object 对象对程序已经没有任何作用，那么我们就认为此 Java 程序发生了内存泄漏。 2.各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。 3.监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[进程与线程以及线程区别及线程同步方法]]></title>
      <url>%2F2017%2F04%2F11%2F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[进程与线程相关知识总结 一、什么是进程与线程他们的区别1.1简介进程是程序的动态执行过程，它经历了从代码加载，执行，到执行完毕的一个完整过程。这个过程也是进程本身从产生、发展，到最终消亡的一个过程。 多线程是实现并发机制的一个有效手段。进程和线程一样都是实现并发的基本单位。 理解多线程：如果现在同时有多个任务，则所有的系统的资源是共享的，被所有线程所公用，但是程序处理需要CPU，传统单核ＣＰＵ来说同一个时间段会有多个程序执行，但是在同一个时间点上只能存在一个程序运行，也就是说所有的程序都要抢占ＣＰＵ资源。但是当ＣＰＵ已经发展到多核的状态了，在一个电脑上可能会存在多个ＣＰＵ，这个时候就可以非常清楚的发现多线程操作间是如何进行并发的执行的。 1.2 进程和线程的区别1，进程和线程都有三种基本状态：就绪，运行，阻塞 2，从资源的角度讲：进程是拥有资源的基本单位，线程可以共享其隶属进程的系统资源。 3，从调度的角度讲：线程是cpu调度的基本单位。 4，从系统开销的角度讲：进程由程序、数据、进程控制块三部分组成。每次创建进程，系统都要为之分配或回收资源，如内存、io等。 线程由线程ID、当前指令指针、寄存器集合和堆栈等组成，线程切换只需要保存和设置少量寄存器变量，因此系统开销小。 5，从通信方面：进程通信需要依靠操作系统，而线程可以直接读写进程数据段（全局变量）来进行通信。 进程通信可以采用的方法有：管道、信号、信号量、消息队列、共享内存、状态变量、套接字（socket）&lt;不同机器之间&gt; 1.3 线程实现相关方法1，线程创建 1.1继承Thread 1）定义Thread的子类，实现run（）方法 2）创建Thread子类的对象 [创建之后，线程处于新建状态] 3）调用线程对象的start方法 [线程处于就绪状态] 1.2实现runnable或者callable 1）定义类，实现runnable接口，重写run方法 2）创建上述类类的对象 [创建之后，线程处于新建状态] 3）不直接调用上述对象的start方法，而是将其作为target。new Thread(对象).start（） [线程处于就绪状态] 2，控制线程的相关方法 1）join 让一个线程等待另一个线程完成。调用后，当前线程阻塞，直到被调用的线程执行结束。 2）sleep让线程休眠，由运行态进入阻塞态。 3）yield让线程重新调度，有运行态进入就绪态。 二、线程同步与锁2.1、为什么要线程同步线程的同步是为了防止多个线程访问一个数据对象时，对数据造成的破坏。例如：两个线程ThreadA、ThreadB都操作同一个对象Foo对象，并修改Foo对象上的数据。 1234567891011121314package cn.thread;public class Foo &#123; private int x = 100; public int getX() &#123; return x; &#125; public int fix(int y) &#123; x = x - y; return x; &#125;&#125; 123456789101112131415161718192021222324252627282930package cn.thread;public class MyRunnable implements Runnable &#123; private Foo foo = new Foo(); public static void main(String[] args) &#123; MyRunnable run = new MyRunnable(); Thread ta = new Thread(run, "Thread-A"); Thread tb = new Thread(run, "Thread-B"); ta.start(); tb.start(); &#125; public void run() &#123; for (int i = 0; i &lt; 3; i++) &#123; this.fix(30); try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + " : 当前foo对象的x值= " + foo.getX()); &#125; &#125; public int fix(int y) &#123; return foo.fix(y); &#125;&#125; 运行结果： 123456Thread-B : 当前foo对象的x值= 40Thread-A : 当前foo对象的x值= 40Thread-B : 当前foo对象的x值= -20Thread-A : 当前foo对象的x值= -20Thread-B : 当前foo对象的x值= -80Thread-A : 当前foo对象的x值= -80 从结果发现，这样的输出值明显是不合理的。原因是两个线程不加控制的访问Foo对象并修改其数据所致。如果要保持结果的合理性，只需要达到一个目的，就是将对Foo的访问加以限制，每次只能有一个线程在访问。这样就能保证Foo对象中数据的合理性了。 2、synchronized实现同步在具体的Java代码中需要完成一下两个操作：把竞争访问的资源类Foo变量x标识为private；同步哪些修改变量的代码，使用synchronized关键字同步方法或代码。 1234567891011121314151617181920212223242526272829package cn.thread;public class Foo2 &#123; private int x = 100; public int getX() &#123; return x; &#125; //同步方法 public synchronized int fix(int y) &#123; x = x - y; System.out.println("线程"+Thread.currentThread().getName() + "运行结束，减少“" + y + "”，当前值为：" + x); return x; &#125; // //同步代码块// public int fix(int y) &#123;// synchronized (this) &#123;// x = x - y;// System.out.println("线程"+Thread.currentThread().getName() + "运行结束，减少“" + y// + "”，当前值为：" + x);// &#125;// // return x;// &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package cn.thread;public class MyRunnable2 &#123; public static void main(String[] args) &#123; MyRunnable2 run = new MyRunnable2(); Foo2 foo2=new Foo2(); MyThread t1 = run.new MyThread("线程A", foo2, 10); MyThread t2 = run.new MyThread("线程B", foo2, -2); MyThread t3 = run.new MyThread("线程C", foo2, -3); MyThread t4 = run.new MyThread("线程D", foo2, 5); t1.start(); t2.start(); t3.start(); t4.start(); &#125; class MyThread extends Thread &#123; private Foo2 foo2; /**当前值*/ private int y = 0; MyThread(String name, Foo2 foo2, int y) &#123; super(name); this.foo2 = foo2; this.y = y; &#125; public void run() &#123; foo2.fix(y); &#125; &#125;&#125; 1234线程线程A运行结束，减少“10”，当前值为：90线程线程C运行结束，减少“-3”，当前值为：93线程线程B运行结束，减少“-2”，当前值为：95线程线程D运行结束，减少“5”，当前值为：90 3、同步和锁1、锁的原理Java中每个对象都有一个内置锁。当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。当程序运行到synchronized同步方法或代码块时该对象锁才起作用。一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块，直到该锁被释放。释放锁是指持锁线程退出了synchronized同步方法或代码块。 关于锁和同步，有一下几个要点：1）、只能同步方法，而不能同步变量和类；2）、每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？3）、不必同步类中所有的方法，类可以同时拥有同步和非同步方法。4）、如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说：如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。5）、如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。6）、线程睡眠时，它所持的任何锁都不会释放。7）、线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。8）、同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块。9）、在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。例如：123456public int fix(int y) &#123;​ synchronized (this) &#123;​ x = x - y;​ &#125;​ return x;&#125; 当然，同步方法也可以改写为非同步方法，但功能完全一样的，例如：123public synchronized int getX() &#123;​ return x++;&#125; 与12345public int getX() &#123;​ synchronized (this) &#123;​ return x++;​ &#125;&#125; 效果是完全一样的。 4、静态方法同步要同步静态方法，需要一个用于整个类对象的锁，这个对象就是这个类（XXX.class)。例如：123public static synchronized int setName(String name)&#123;​ Xxx.name = name;&#125; 等价于12345public static int setName(String name)&#123;​ synchronized(Xxx.class)&#123;​ Xxx.name = name;​ &#125;&#125; 5、如果线程不能获得锁会怎么样如果线程试图进入同步方法，而其锁已经被占用，则线程在该对象上被阻塞。实质上，线程进入该对象的的一种池中，必须在哪里等待，直到其锁被释放，该线程再次变为可 运行或运行为止。当考虑阻塞时，一定要注意哪个对象正被用于锁定：1、调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。2、调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上。3、静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。4、对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。在同一个对象上进行同步的线程将彼此阻塞，在不同对象上锁定的线程将永远不会彼此阻塞。 6、何时需要同步在多个线程同时访问互斥（可交换）数据时，应该同步以保护数据，确保两个线程不会同时修改更改它。对于非静态字段中可更改的数据，通常使用非静态方法访问。对于静态字段中可更改的数据，通常使用静态方法访问。如果需要在非静态方法中使用静态字段，或者在静态字段中调用非静态方法，问题将变得非常复杂。已经超出SJCP考试范围了。 7、线程同步小结1、线程同步的目的是为了保护多个线程访问一个资源时对资源的破坏。2、线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。4、对于同步，要时刻清醒在哪个对象上同步，这是关键。5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使，但是，一旦程序发生死锁，程序将死掉。 二、线程同步的方法0.为何要使用同步 java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查）， 将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前被其他线程的调用， 从而保证了该变量的唯一性和准确性。 1.同步方法​ 即有synchronized关键字修饰的方法。​ 由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，​ 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。 ​ 代码如：1​ public synchronized void save()&#123;&#125; 注： synchronized关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类 2.同步代码块 即由synchronized关键字修饰的语句块。​ 被该关键字修饰的语句块会自动被加上内置锁，从而实现同步 ​ 代码如：12​ synchronized(object)&#123; ​ &#125; ​ 注：同步是一种高开销的操作，因此应该尽量减少同步的内容。​ 通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。​ 代码实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.xhj.thread; /** * 线程同步的运用 * * @author XIEHEJUN * */ public class SynchronizedThread &#123; class Bank &#123; private int account = 100; public int getAccount() &#123; return account; &#125; /** * 用同步方法实现 * * @param money */ public synchronized void save(int money) &#123; account += money; &#125; /** * 用同步代码块实现 * * @param money */ public void save1(int money) &#123; synchronized (this) &#123; account += money; &#125; &#125; &#125; class NewThread implements Runnable &#123; private Bank bank; public NewThread(Bank bank) &#123; this.bank = bank; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; // bank.save1(10); bank.save(10); System.out.println(i + "账户余额为：" + bank.getAccount()); &#125; &#125; &#125; /** * 建立线程，调用内部类 */ public void useThread() &#123; Bank bank = new Bank(); NewThread new_thread = new NewThread(bank); System.out.println("线程1"); Thread thread1 = new Thread(new_thread); thread1.start(); System.out.println("线程2"); Thread thread2 = new Thread(new_thread); thread2.start(); &#125; public static void main(String[] args) &#123; SynchronizedThread st = new SynchronizedThread(); st.useThread(); &#125; &#125; 3.使用特殊域变量(volatile)实现线程同步​ a.volatile关键字为域变量的访问提供了一种免锁机制，​ b.使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新，​ c.因此每次使用该域就要重新计算，而不是使用寄存器中的值​ d.volatile不会提供任何原子操作，它也不能用来修饰final类型的变量​ 例如：​ 在上面的例子当中，只需在account前面加上volatile修饰，即可实现线程同步。​ 代码实例： 12345678910111213//只给出要修改的代码，其余代码与上同 class Bank &#123; //需要同步的变量加上volatile private volatile int account = 100; public int getAccount() &#123; return account; &#125; //这里不再需要synchronized public void save(int money) &#123; account += money; &#125; ｝ ​ 注：多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。​ 用final域，有锁保护的域和volatile域可以避免非同步的问题。 4.使用重入锁实现线程同步​ 在JavaSE5.0中新增了一个java.util.concurrent包来支持同步。​ ReentrantLock类是可重入、互斥、实现了Lock接口的锁，​ 它与使用synchronized方法和快具有相同的基本行为和语义，并且扩展了其能力 ​ ReenreantLock类的常用方法有： ​ ReentrantLock() : 创建一个ReentrantLock实例​ lock() : 获得锁​ unlock() : 释放锁​ 注：ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用​ 例如：​ 在上面例子的基础上，改写后的代码为:​ 代码实例： 1234567891011121314151617181920//只给出要修改的代码，其余代码与上同 class Bank &#123; private int account = 100; //需要声明这个锁 private Lock lock = new ReentrantLock(); public int getAccount() &#123; return account; &#125; //这里不再需要synchronized public void save(int money) &#123; lock.lock(); try&#123; account += money; &#125;finally&#123; lock.unlock(); &#125; &#125; ｝ ​ 注：关于Lock对象和synchronized关键字的选择：​ a.最好两个都不用，使用一种java.util.concurrent包提供的机制，​ 能够帮助用户处理所有与锁相关的代码。​ b.如果synchronized关键字能满足用户的需求，就用synchronized，因为它能简化代码​ c.如果需要更高级的功能，就用ReentrantLock类，此时要注意及时释放锁，否则会出现死锁，通常在finally代码释放锁 5.使用局部变量实现线程同步​ 如果使用ThreadLocal管理变量，则每一个使用该变量的线程都获得该变量的副本，​ 副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响。 ​ ThreadLocal 类的常用方法 ​ ThreadLocal() : 创建一个线程本地变量​ get() : 返回此线程局部变量的当前线程副本中的值​ initialValue() : 返回此线程局部变量的当前线程的”初始值”​ set(T value) : 将此线程局部变量的当前线程副本中的值设置为value ​ 例如：​ 在上面例子基础上，修改后的代码为：​ 代码实例： 12345678910111213141516//只改Bank类，其余代码与上同 public class Bank&#123; //使用ThreadLocal类管理共享变量account private static ThreadLocal&lt;Integer&gt; account = new ThreadLocal&lt;Integer&gt;()&#123; @Override protected Integer initialValue()&#123; return 100; &#125; &#125;; public void save(int money)&#123; account.set(account.get()+money); &#125; public int getAccount()&#123; return account.get(); &#125; &#125; ​ 注：ThreadLocal与同步机制​ a.ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题。​ b.前者采用以”空间换时间”的方法，后者采用以”时间换空间”的方式 6.使用阻塞队列实现线程同步 ​ 前面5种同步方式都是在底层实现的线程同步，但是我们在实际开发当中，应当尽量远离底层结构。​ 使用javaSE5.0版本中新增的java.util.concurrent包将有助于简化开发。​ 本小节主要是使用LinkedBlockingQueue来实现线程的同步​ LinkedBlockingQueue是一个基于已连接节点的，范围任意的blocking queue。​ 队列是先进先出的顺序（FIFO），关于队列以后会详细讲解~ LinkedBlockingQueue 类常用方法​ LinkedBlockingQueue() : 创建一个容量为Integer.MAX_VALUE的LinkedBlockingQueue​ put(E e) : 在队尾添加一个元素，如果队列满则阻塞​ size() : 返回队列中的元素个数​ take() : 移除并返回队头元素，如果队列空则阻塞 代码实例：​ 实现商家生产商品和买卖商品的同步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 package com.xhj.thread; import java.util.Random; import java.util.concurrent.LinkedBlockingQueue; /** * 用阻塞队列实现线程同步 LinkedBlockingQueue的使用 * * @author XIEHEJUN * */ public class BlockingSynchronizedThread &#123; /** * 定义一个阻塞队列用来存储生产出来的商品 */ private LinkedBlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;Integer&gt;(); /** * 定义生产商品个数 */ private static final int size = 10; /** * 定义启动线程的标志，为0时，启动生产商品的线程；为1时，启动消费商品的线程 */ private int flag = 0; private class LinkBlockThread implements Runnable &#123; @Override public void run() &#123; int new_flag = flag++; System.out.println("启动线程 " + new_flag); if (new_flag == 0) &#123; for (int i = 0; i &lt; size; i++) &#123; int b = new Random().nextInt(255); System.out.println("生产商品：" + b + "号"); try &#123; queue.put(b); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println("仓库中还有商品：" + queue.size() + "个"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; else &#123; for (int i = 0; i &lt; size / 2; i++) &#123; try &#123; int n = queue.take(); System.out.println("消费者买去了" + n + "号商品"); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; System.out.println("仓库中还有商品：" + queue.size() + "个"); try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; BlockingSynchronizedThread bst = new BlockingSynchronizedThread(); LinkBlockThread lbt = bst.new LinkBlockThread(); Thread thread1 = new Thread(lbt); Thread thread2 = new Thread(lbt); thread1.start(); thread2.start(); &#125;&#125; 注：BlockingQueue定义了阻塞队列的常用方法，尤其是三种添加元素的方法，我们要多加注意，当队列满时： add()方法会抛出异常 offer()方法返回false put()方法会阻塞 7.使用原子变量实现线程同步需要使用线程同步的根本原因在于对普通变量的操作不是原子的。 那么什么是原子操作呢？原子操作就是指将读取变量值、修改变量值、保存变量值看成一个整体来操作即-这几种行为要么同时完成，要么都不完成。在java的util.concurrent.atomic包中提供了创建了原子类型变量的工具类，使用该类可以简化线程同步。其中AtomicInteger 表可以用原子方式更新int的值，可用在应用程序中(如以原子方式增加的计数器)，但不能用于替换Integer；可扩展Number，允许那些处理机遇数字类的工具和实用工具进行统一访问。AtomicInteger类常用方法：AtomicInteger(int initialValue) : 创建具有给定初始值的新的AtomicIntegeraddAddGet(int dalta) : 以原子方式将给定值与当前值相加get() : 获取当前值代码实例：只改Bank类，其余代码与上面第一个例子同 123456789class Bank &#123; private AtomicInteger account = new AtomicInteger(100); public AtomicInteger getAccount() &#123; return account; &#125; public void save(int money) &#123; account.addAndGet(money); &#125;&#125; 8.wait/notify方式实现同步用消费与生产最容易理解，当物品比较充足时候，生产者就不需要生产，就调用wait，而比较充足的时候当生产完就通知消费者消费notify.而消费者在物品不充足时候wait，等待生产者生产，而正常消费的时候消费结束通知生产者来生产notify。1234567891011121314151617181920212223242526272829/** * 商品类 */public class Goods &#123; private String pinpai; private String name; private int num; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; public String getPinpai() &#123; return pinpai; &#125; public void setPinpai(String pinpai) &#123; this.pinpai = pinpai; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 生产商类 */public class Producer implements Runnable &#123; private Goods goods; public Goods getGoods() &#123; return goods; &#125; public void setGoods(Goods goods) &#123; this.goods = goods; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; synchronized (goods) &#123; if(goods.getNum()&gt;0)&#123; try &#123; goods.wait();//商品数量已经大于0啦,消费者要取货咯,自己就开始等待咯 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; if (i % 2 == 0) &#123; goods.setPinpai("哇哈哈"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; goods.setName("矿泉水"); &#125; else &#123; goods.setPinpai("旺仔"); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; goods.setName("小馒头"); &#125; goods.setNum((goods.getNum()+1)); System.out.println("生产了" + goods.getPinpai() + goods.getName()); goods.notify();//商品不够啦,自己生产完,然后通知消费者取货咯 &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940/** * 消费者类 */public class Customer implements Runnable &#123; private Goods goods; public Goods getGoods() &#123; return goods; &#125; public void setGoods(Goods goods) &#123; this.goods = goods; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; synchronized (goods) &#123; if(goods.getNum()&lt;=0)&#123; try &#123;//如果商品生产的数量小于0,则开始等待.只有有货才能购物嘛 goods.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; goods.setNum((goods.getNum()-1)); System.out.println("取走了" + goods.getPinpai() + goods.getName()); goods.notify();//取走之后通知生产商继续生产商品(唤醒在对象锁等待池中的线程继续执行) &#125; &#125; &#125;&#125; 12345678910111213141516171819/** * 测试类 */public class Test &#123; public static void main(String[] args) &#123; Goods goods=new Goods(); //生产者生产商品 Producer p=new Producer(); p.setGoods(goods); //消费者取走商品 Customer c=new Customer(); c.setGoods(goods); new Thread(p).start(); new Thread(c).start(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[牛客网剑指offer刷题汇总]]></title>
      <url>%2F2017%2F04%2F04%2F%E5%89%91%E6%8C%87offer%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
      <content type="text"><![CDATA[基于牛客网刷剑指offer的全部java代码GitHub地址 00 树和链表模组各个题目中涉及的树、链表等通用定义。123456789101112131415161718class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 01 判断一个行列都递增的数组是否包含某个数题目描述在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。123456789101112131415161718192021222324252627282930313233343536373839//思路一，每一行二分查找法 //但是此方法时间复杂度为nlogn是在复杂度太大。 public boolean Find2(int target, int [][] array) &#123; for (int i = 0; i &lt; array.length; i++) &#123; int low = 0; int high = array[i].length-1; int mid = (low+high)/2; while(low&lt;=high)&#123; if(target&gt;array[i][mid])&#123; low = mid + 1; &#125;else if(target&lt;array[i][mid])&#123; high = mid - 1; &#125;else return true; &#125; &#125; return false; &#125; //思路2，根据此数组的特性， /*利用二维数组由上到下，由左到右递增的规律，那么选取右上角或者左下角的元素a[row][col]与target进行比较，当target小于元素a[row][col]时，那么target必定在元素a所在行的左边,即col--；当target大于元素a[row][col]时，那么target必定在元素a所在列的下边,即row++； * */ public boolean Find(int target, int [][] array) &#123; int row = 0; int col = array[0].length - 1;//选取右上角 while(row&lt;=array.length-1 &amp;&amp; col&gt;=0)&#123; if (target==array[row][col]) return true; else if(target&lt;array[row][col]) col--; else row++; &#125; return false; &#125; 02 替换字符串中的空格为%20请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。123456789101112public String replaceSpace(StringBuffer str) &#123; char[] c = str.toString().toCharArray(); StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; c.length; i++) &#123; if (c[i]==' ')&#123; sb.append("%20"); &#125;else &#123; sb.append(c[i]); &#125; &#125; return sb.toString(); &#125; 03 从尾到头打印链表每个节点的值输入一个链表，从尾到头打印链表每个节点的值。12345678910//递归方式实现ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; if (listNode!=null)&#123; this.printListFromTailToHead(listNode.next); arrayList.add(listNode.val); &#125; return arrayList; &#125; 04 根据中序和前序重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。12345678910111213141516171819202122232425262728//根据先序找到头结点，根据头结点在中序中找到左右子树。然后递归重建。public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; return this.reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); &#125; public TreeNode reConstructBinaryTree(int [] pre,int start1,int end1,int [] in,int start2,int end2) &#123; if (start1&gt;end1 || start2&gt;end2) return null; int rootData = pre[start1]; TreeNode head = new TreeNode(rootData); //找到根节点位置 int rootIndex = findIndexInArray(in,rootData,start2,end2); int offset = rootIndex - start2 - 1; //构建左子树 TreeNode left = reConstructBinaryTree(pre,start1+1,start1+1+offset,in,start2,start2+offset); //构建右子树 TreeNode right = reConstructBinaryTree(pre,start1+offset+2,end1,in,rootIndex+1,end2); head.left = left; head.right = right; return head; &#125; private int findIndexInArray(int[] a, int rootData, int begin, int end) &#123; for (int i = begin; i &lt;= end; i++) &#123; if(a[i]==rootData) return i; &#125; return -1; &#125; 05 两个队列模拟一个栈用两个栈实现一个队列的功能?要求给出算法和思路! &lt;分析&gt;： 入队：将元素进栈A 出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈； 如果不为空，栈B直接出栈。 用两个队列实现一个栈的功能?要求给出算法和思路! &lt;分析&gt;： 入栈：将元素进队列A 出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素以此出队列并放入队列B， 直到队列A中的元素留下一个，然后队列A出队列，再把队列B中的元素出队列以此放入队列A中。123456789101112131415161718Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; int a; if (stack2.empty())&#123; while (!stack1.empty())&#123; a = stack1.pop(); stack2.push(a); &#125; &#125; a = stack2.pop(); return a; &#125; 06 非递减数组旋转后变为递增数组输出最小元素把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。12345678910111213public int minNumberInRotateArray(int [] array) &#123; if(array.length==0) return 0; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i]&lt;=array[i+1]) continue; else &#123; int g = array[i + 1]; return g; &#125; &#125; return 0; &#125; 07 输出斐波那契数列的第n项F(0)=0，F(1)=1, F(n)=F(n-1)+F(n-2)（n&gt;=2，n∈N*）1234567891011121314151617181920212223242526272829//递归，但是递归时间复杂度过大，所思考其他方法 public int Fibonacci2(int n) &#123; if (0==n) return 0; else if (1==n)&#123; return 1; &#125;else&#123; return Fibonacci2(n-2) + Fibonacci2(n-1); &#125; &#125; //循环法 public int Fibonacci(int n) &#123; int prePreNum = 0; int preNum = 1; int sum = 0; if (0==n) return 0; else if (1==n)&#123; return 1; &#125;else&#123; for (int i = 2; i &lt;=n; i++) &#123; sum = prePreNum + preNum; prePreNum = preNum; preNum = sum; &#125; return sum; &#125; &#125; 08 青蛙跳台阶一次跳1级或者2级n级有多少种跳法一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。1234567891011121314151617181920212223242526272829303132//递归解法 public int JumpFloor(int target) &#123; if (0==target) return 0; else if (1==target) return 1; else if (2==target) return 2; else &#123; return (JumpFloor(target-1) + JumpFloor(target-2)); &#125; &#125;//迭代解法 public int JumpFloor2(int target)&#123; if (target==0 || target==1 || target==2) return target; else &#123; // 第一阶和第二阶考虑过了，初始当前台阶为第三阶，向后迭代 // 思路：当前台阶的跳法总数=当前台阶后退一阶的台阶的跳法总数+当前台阶后退二阶的台阶的跳法总数 int lastNum = 2;//第三级台阶退后一节有几种跳法 int lastlastNum = 1;//第三级台阶退后2节有几种跳法 int sum=0; for (int i = 3; i &lt;= target; i++) &#123; sum = lastlastNum + lastNum; lastlastNum = lastNum; // 后退一阶在下一次迭代变为后退两阶 lastNum = sum; // 当前台阶在下一次迭代变为后退一阶 &#125; return sum; &#125; &#125; 09 青蛙跳台阶可以调1-n级n级台阶共有多少种跳法关于本题，前提是n个台阶会有一次n阶的跳法。分析如下: f(1) = 1 f(2) = f(2-1) + f(2-2)//f(2-2) 表示2阶一次跳2阶的次数。 f(3) = f(3-1) + f(3-2) + f(3-3) … f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n) 说明： 1）这里的f(n) 代表的是n个台阶有一次1,2,…n阶的 跳法数。 2）n = 1时，只有1种跳法，f(1) = 1 3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，f(2) = f(2-1) + f(2-2) 4) n = 3时，会有三种跳得方式，1阶、2阶、3阶那么就是第一次跳出1阶后面剩下： f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) 因此结论是f(3) = f(3-1)+f(3-2)+f(3-3) 5) n = n时，会有n中跳的方式，1阶、2阶…n阶，得出结论： f(n) = f(n-1)+f(n-2)+…+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + … + f(n-1) 6) 由以上已经是一种结论，但是为了简单，我们可以继续简化：f(n-1) = f(0) + f(1)+f(2)+f(3) + … + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + … + f(n-2)f(n) = f(0) + f(1) + f(2) + f(3) + … + f(n-2) +f(n-1) = f(n-1) + f(n-1)可以得出： f(n) = 2f(n-1) 7) 得出最终结论,在n阶台阶，一次有1、2、…n阶的跳的方式时，总得跳法为： | 1 ,(n=0 ) f(n) = | 1 ,(n=1 ) | 2f(n-1),(n&gt;=2) 1234567public int JumpFloorII(int target) &#123; if (target==1 || target==2) return target; else &#123; return 2*JumpFloorII(target-1); &#125; &#125; 10 矩形覆盖问题我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 依旧是斐波那契数列 2n的大矩形，和n个21的小矩形 其中target2为大矩阵的大小 有以下几种情形： target &lt;= 0 大矩形为&lt;= 20,直接return 1； target = 1大矩形为21，只有一种摆放方法，return1； target = 2 大矩形为22，有两种摆放方法，return2； target = n 分为两步考虑： 第一次摆放一块 21 的小矩阵，则摆放方法总共为f(target - 1) 第一次摆放一块12的小矩阵，则摆放方法总共为f(target-2) 因为，摆放了一块12的小矩阵（用√√表示），对应下方的12（用××表示）摆放方法就确定了，所以为f(targte-2)123456789public int RectCover(int target) &#123; if (target==0) return 0; else if (target==2 || target==1)&#123; return target; &#125;else &#123; return RectCover(target-1) + RectCover(target-2); &#125; &#125; 11 判断一个整数二进制表示中1的个数输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。123456789101112131415161718192021/* 正常解法 */ public int NumberOf1(int n) &#123; int count = 0; if (n==0) return 0; else &#123; while (n != 0) &#123; n = n &amp; (n-1); count++; &#125; &#125; return count; &#125; /* 用java工具类 */ public int NumberOf12(int n) &#123; return Integer.toBinaryString(n).replace("0","").length(); &#125; 12 求double类型的exponent次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。12345678910111213141516171819202122232425262728293031323334public double Power(double base, int exponent) &#123; return (double)Math.pow(base,exponent);&#125;//递归方法public double Power2(double base, int exponent) &#123; int n = Math.abs( exponent ); double result = 0.0; if (n==0) return 1; if (n==1) result = base; result = Power2( base,n&gt;&gt;1 ); result *= result; if ((n&amp;1)==1) //如果指数是奇数，那就要再乘一次 result *= base; if (exponent&lt;0) //如果指数为负数，则求result的倒数 result = 1 / result; return result;&#125;//累乘法public double Power2(double base, int exponent) &#123; double result = 1.0; for (int i = 0; i &lt; Math.abs( exponent ); i++) &#123; result *= base; &#125; if (exponent&gt;= 0) return result; else return 1 / result;&#125; 13 将数组的奇数放在前半部分偶数放在数组后半部分输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。1234567891011121314public void reOrderArray(int [] array) &#123; Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;(); for (int i = 0; i &lt;= array.length-1; i++) &#123; if (array[i]%2==1) vector.add(array[i]); &#125; for (int i = 0; i &lt;= array.length-1; i++) &#123; if (array[i]%2==0) vector.add(array[i]); &#125; for (int i = 0; i &lt;= array.length-1; i++) &#123; array[i] = vector.get(i); &#125; &#125; 14 输出链表倒数第K个节点输入一个链表，输出该链表中倒数第k个结点。1234567891011121314151617181920212223/*最佳代码：Java代码，通过校验。代码思路如下：两个指针，先让第一个指针和第二个指针都指向头结点，然后再让第一个指正走(k-1)步，到达第k个节点。然后两个指针同时往后移动，当第一个结点到达末尾的时候，第二个结点所在位置就是倒数第k个节点了。。 */ public ListNode FindKthToTail(ListNode head,int k) &#123; if (head==null||k&lt;=0) return null; ListNode preNode = head; ListNode lastNode = head; for (int i = 1; i &lt; k; i++) &#123; if (preNode.next!=null)&#123; preNode = preNode.next; &#125;else &#123; return null; &#125; &#125; while (preNode.next!=null)&#123; preNode = preNode.next; lastNode = lastNode.next; &#125; return lastNode; &#125; 15 反转链表并输出链表所有元素12345678910111213141516171819202122232425262728 /*方法一：递归法 */ public ListNode ReverseList2(ListNode head) &#123; if (head==null || head.next==null) return head; ListNode h = ReverseList2(head.next); head.next.next = head; head.next = null; return h; &#125; /*方法二：正常替换法 */ public ListNode ReverseList(ListNode head) &#123; ListNode pre = null; ListNode next = null; if (head==null || head.next==null) return head; while (head!=null)&#123; next = head.next; head.next = pre; pre = head; head = next; &#125; return pre; &#125; 16 将两个单调递增的链表合并成单调不减的链表题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* 非递归版本，然而时间复杂度过大，那么考虑递归版本 */ public ListNode Merge2(ListNode list1,ListNode list2) &#123; ListNode list = null; ListNode next = null; if (list1==null &amp;&amp; list2==null) return null; else if(list1==null || list2==null)&#123; if (list1==null) return list2; else return list1; &#125;else &#123; while (list1!=null||list2!=null)&#123; if (list1.val&lt;=list2.val) &#123; if (list==null)&#123; list = list1; list.next = next; &#125;else &#123; next = list1; list.next = next; list = list.next; list1 = list1.next; &#125; &#125;else &#123; if (list==null)&#123; list = list2; list.next = next; &#125;else &#123; next = list2; list.next = next; list = list.next; list2 = list2.next; &#125; &#125; &#125; &#125; return list; &#125; /* 递归版本 */ public ListNode Merge(ListNode list1,ListNode list2) &#123; ListNode headNode = null; if (list1==null) return list2; else if (list2==null) return list1; else &#123; if(list1.val&lt;list2.val)&#123; headNode = list1; headNode.next = Merge(list1.next,list2); &#125;else &#123; headNode = list2; headNode.next = Merge(list1,list2.next); &#125; &#125; return headNode; &#125; 17 判断一个树是不是另一个树的子树输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）12345678910111213141516171819202122232425262728/*递归法求解 */ public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; boolean result = false; if (root1==null || root2==null) return false; else &#123; if(root1.val==root2.val)&#123; result = DoesTree1HaveTree2(root1,root2); &#125; if (!result) result = DoesTree1HaveTree2(root1.left,root2); if (!result) result = DoesTree1HaveTree2(root1.right,root2); &#125; return result; &#125; public boolean DoesTree1HaveTree2(TreeNode root1,TreeNode root2)&#123; if(root1 == null &amp;&amp; root2 != null) return false; if(root2 == null) return true; if(root1.val != root2.val) return false; return DoesTree1HaveTree2(root1.left, root2.left) &amp;&amp; DoesTree1HaveTree2(root1.right, root2.right); &#125; 18 将二叉树变换为镜像二叉树题目描述操作给定的二叉树，将其变换为源二叉树的镜像。输入描述:二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 512345678910111213public void Mirror(TreeNode root) &#123; TreeNode tmp = null; if (root!=null)&#123; tmp = root.left; root.left = root.right; root.right = tmp; if (root.left!=null) Mirror(root.left); if (root.right!=null) Mirror(root.right); &#125; &#125; 19 将矩阵从外到里打印出每一个数字题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵：[1 2 3 4][5 6 7 8][9 10 11 12][13 14 15 16]则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.123456789101112131415161718192021222324252627282930313233/*//主体循环部分才5行。其实是有规律可循的。将每一层的四个边角搞清楚就可以打印出来了 */ public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); if (matrix.length==0) return result; int n = matrix.length; int m = matrix[0].length; if (m==0) return result; int layer = (Math.min(n,m)-1)/2 + 1;//层数 for (int i = 0; i &lt; layer; i++) &#123; //从左到右 for (int j = i; j &lt; m - i; j++) &#123; result.add(matrix[i][j]);//左上角 &#125; //从右上到右下 for (int j = i + 1; j &lt; n - i; j++) &#123; result.add(matrix[j][m - i - 1]);//右上角 &#125; //从右到左 for (int j = m - i - 2; j &gt;= i &amp;&amp; (n - i - 1 != i); j--) &#123; result.add(matrix[n - i - 1][j]);//右下角 &#125; //左下到左上 for (int j = n - i - 2; j &gt; i &amp;&amp; (m - i - 1 != i); j--) &#123; result.add(matrix[j][i]);//左下角 &#125; &#125; return result; &#125; 20 定义一种额外的栈可得得到栈中最小元素定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。注意不能有具体的int类型12345678910111213141516171819202122232425262728293031323334思路：用一个栈data保存数据，用另外一个栈min保存依次入栈最小的数比如，data中依次入栈，5, 4, 3, 8, 10, 11, 12, 1 则min依次入栈，5, 4, 3，3,3, 3, 3, 1 */ Stack dataStack = new Stack(); Stack minStack = new Stack(); public void push(int node) &#123; dataStack.push(node); if (minStack.isEmpty()) &#123; minStack.push(node); &#125;else&#123; if (node&lt;(int)minStack.peek())&#123; minStack.add(node); &#125;else &#123; minStack.add((int)minStack.peek()); &#125; &#125; &#125; public void pop() &#123; dataStack.pop(); minStack.pop(); &#125; public int top() &#123; return (int)dataStack.peek(); &#125; public int min() &#123; return (int)minStack.peek(); &#125; 21 判断第二个栈序列是是否是第一个栈序列栈的弹出序列题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）123456789101112131415161718192021222324252627282930313233 /*【思路】借用一个辅助的栈，遍历压栈顺序，先将第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。 举例： 入栈1,2,3,4,5 出栈4,5,3,2,1 首先1入辅助栈，此时栈顶1≠4，继续入栈2 此时栈顶2≠4，继续入栈3 此时栈顶3≠4，继续入栈4 此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3 此时栈顶3≠5，继续入栈5 此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3 …. 依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。 */ public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if (pushA.length==0 || popA.length==0) return false; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); //用于标识弹出序列的位置 int popIndex = 0; for (int i = 0; i &lt; pushA.length; i++) &#123; stack.push(pushA[i]); //如果栈不为空，且栈顶元素等于弹出序列 while (!stack.isEmpty() &amp;&amp; stack.peek()==popA[popIndex])&#123; stack.pop(); popIndex++; &#125; &#125; return stack.isEmpty(); &#125; 22 层序打印二叉树题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。12345678910111213141516171819202122232425262728293031323334353637383940414243/* 用队列来实现层序遍历，然而却时间复杂度过大 */ public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); if (root == null) return arrayList; queue.add(root); while (!queue.isEmpty()) &#123; TreeNode treeNode = queue.poll(); arrayList.add(treeNode.val); if (root.left != null) queue.add(root.left); if (root.right != null) queue.add(root.right); &#125; return arrayList; &#125;/* 用ArrayList来模拟队列 */public ArrayList&lt;Integer&gt; PrintFromTopToBottom2(TreeNode root)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); ArrayList&lt;TreeNode&gt; queue = new ArrayList&lt;TreeNode&gt;(); if (root == null) &#123; return list; &#125; queue.add(root); while (queue.size() != 0) &#123; TreeNode temp = queue.remove(0); list.add(temp.val); if (temp.left != null)&#123; queue.add(temp.left); &#125; if (temp.right != null) &#123; queue.add(temp.right); &#125; &#125; return list;&#125; 23 判断一个数组是不是某二叉搜索树的后序遍历题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 /* 递归解法 */ public boolean VerifySquenceOfBST2(int [] sequence) &#123; int length = sequence.length - 1; if (length&lt;0) return false; if (length==0)&#123; return true; &#125; return juge(sequence,0,length); &#125; private boolean juge(int[] sequence, int start, int root) &#123; if (start&gt;=root) return true; int i = root; while (i&gt;start &amp;&amp; sequence[i-1]&gt;sequence[root]) i--; for (int j = start; j &lt; i-1; j++) &#123; if (sequence[j]&gt;sequence[root]) return false; &#125; return juge(sequence,start,i-1) &amp;&amp; juge(sequence,i,root-1); &#125; /*//非递归 //非递归也是一个基于递归的思想：//左子树一定比右子树小，因此去掉根后，数字分为left，right两部分，//right部分的最后一个数字是右子树的根他也比左子树所有值大，//因此我们可以每次只看有子树是否符合条件即可,//即使到达了左子树左子树也可以看出由左右子树组成的树还想右子树那样处理 //对于左子树回到了原问题，对于右子树，左子树的所有值都比右子树的根小可以暂时把他看出右子树的左子树//只需看看右子树的右子树是否符合要求即可 */ public boolean VerifySquenceOfBST(int [] sequence) &#123; int size = sequence.length-1; if (size&lt;0) return false; int i = 0; while (size&gt;=0)&#123; while(sequence[i]&lt;sequence[size])&#123; i++; &#125; while(sequence[i]&gt;sequence[size])&#123; i++; &#125; if (i&lt;size) return false; i=0; size--; &#125; return true; &#125; 24 打印二叉树的路径输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。123456789101112131415161718/*递归解法 */ ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) &#123; if (root==null) return listAll; list.add(root.val); target = target - root.val; if (target==0 &amp;&amp; root.left==null &amp;&amp; root.right==null) listAll.add(new ArrayList&lt;Integer&gt;(list)); FindPath(root.left,target); FindPath(root.right,target); //如果到叶子节点找不到那么就要回退 list.remove(list.size()-1); return listAll; &#125; 25 复杂链表的复制题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 递归法 */ public RandomListNode Clone(RandomListNode pHead) &#123; if(pHead==null) return null; RandomListNode randomListNodeHead = new RandomListNode(pHead.label); randomListNodeHead.next = pHead.next; randomListNodeHead.random = pHead.random; //递归其他节点 randomListNodeHead.next = Clone(pHead.next); return randomListNodeHead; &#125; /* 方法二：拆分法 */ public RandomListNode Clone2(RandomListNode pHead)&#123; if (pHead==null) return null; RandomListNode pCur = pHead; //在每一个节点后增加一个和他相同的节点如A&gt;B&gt;C变为A&gt;A'&gt;B&gt;B'&gt;C&gt;C' while(pCur!=null)&#123; RandomListNode node = new RandomListNode(pCur.label); node.next = pCur.next; node.random = pCur.random; pCur.next = node; pCur = node.next; &#125; pCur = pHead;//置换为头结点 RandomListNode pCloneHead = pHead.next; RandomListNode cur = pCloneHead; //链表拆分 while(pCur!=null)&#123; pCur.next = pCur.next.next; if (cur.next!=null)&#123; cur.next = cur.next.next; &#125; pCur = pCur.next; cur = cur.next; &#125; return pCloneHead; &#125; 26 二叉搜索树转换为有小到大的双向链表/题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。例如 10 / \ 6 14 / \ / \ 4 8 12 16更改为4=6=8=10=12=14=16 /1234567891011121314151617181920212223242526272829303132333435363738394041 /*1.将左子树构造成双链表，并返回链表头节点。2.定位至左子树双链表最后一个节点。3.如果左子树链表不为空的话，将当前root追加到左子树链表。4.将右子树构造成双链表，并返回链表头节点。5.如果右子树链表不为空的话，将该链表追加到root节点之后。6.根据左子树链表是否为空确定返回的节点。 */ public TreeNode Convert(TreeNode pRootOfTree) &#123; if (pRootOfTree==null) return null; if (pRootOfTree.left==null &amp;&amp; pRootOfTree.right==null)&#123; return pRootOfTree; &#125; // 1.将左子树构造成双链表，并返回链表头节点 TreeNode left = Convert(pRootOfTree.left); //2.定位至左子树双链表最后一个节点。 TreeNode pLeftLastNode = left; while (pLeftLastNode!=null&amp;&amp;pLeftLastNode.right!=null)&#123; //因为最后一个要么是叶子节点的右节点要么就是无右子树的左子树根节点 pLeftLastNode = pLeftLastNode.right; &#125; // 3.如果左子树链表不为空的话，将当前root追加到左子树链表 if (left!=null)&#123; pLeftLastNode.right = pRootOfTree; pRootOfTree.left = pLeftLastNode; &#125; // 4.将右子树构造成双链表，并返回链表头节点 TreeNode right = Convert(pRootOfTree.right); // 5.如果右子树链表不为空的话，将该链表追加到root节点之后 if (right!=null)&#123; pRootOfTree.right = right; right.left = pRootOfTree; &#125; return left!=null?left:pRootOfTree; &#125; 27 得到abc字符的全排列/题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 /123456789101112131415161718192021222324252627282930public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); HashSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;(); if (str!=null &amp;&amp; str.toCharArray().length&gt;0)&#123; PermutationHelper(str.toCharArray(),0,hashSet); &#125; arrayList.addAll(hashSet); Collections.sort(arrayList); return arrayList;&#125;public void PermutationHelper(char[] chars, int i, HashSet&lt;String&gt; hashSet) &#123; if (i==chars.length-1)&#123; hashSet.add(new String(chars)); &#125;else &#123; for (int j = i; j &lt; chars.length; j++) &#123; swap(chars,i,j); PermutationHelper(chars,i+1,hashSet); swap(chars,i,j); &#125; &#125;&#125;public void swap(char[] chars, int i, int j) &#123; if (i!=j)&#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp; &#125;&#125; 28 查找一个出现次数超过数组一半的数字/题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 /123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/* 时间复杂度为O(N)利用数组的特性来进行 在遍历数组时保存两个值：一是数组中一个数字，一是次数。 遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1； 若次数为0，则保存下一个数字，并将次数置为1。 遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。 */ public int MoreThanHalfNum_Solution(int [] array) &#123; int result = array[0]; int times = 1; if(array==null||array.length&lt;=0)&#123; return 0; &#125; for (int i = 1; i &lt; array.length; i++) &#123; if (times==0)&#123; result = array[i]; times = 1; &#125;else if (array[i]==result)&#123; times++; &#125;else &#123; times--; &#125; &#125; times = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (result==array[i])&#123; times++; &#125; &#125; if (times*2 &lt;= array.length) result = 0; return result; &#125; /* 用HashMap O(N)，用桶排序方法也可 */ public int MoreThanHalfNum_Solution2(int [] array) &#123; HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; array.length; i++) &#123; if (!map.containsKey(array[i]))&#123; map.put(array[i],1); &#125;else &#123; int count = map.get(array[i]); count++; map.put(array[i],count); &#125; &#125; Iterator iterator = map.entrySet().iterator(); while (iterator.hasNext())&#123; Map.Entry entry = (Map.Entry) iterator.next(); int key = (int) entry.getKey(); int val = (int) entry.getValue(); if (val&gt;array.length/2)&#123; return key; &#125; &#125; return 0; &#125; /* 用快排思想，也就是找到中位数,时间复杂度过大 */ public int MoreThanHalfNum_Solution3(int [] array) &#123; if (array.length&lt;=0) return 0; int start = 0; int end = array.length - 1; int mid = (end-start)/2; int index = partition(array,start,end); while (index!=mid)&#123; if (index&gt;mid)&#123; index = partition(array,start,index-1); &#125;else &#123; index = partition(array,index+1,end); &#125; &#125; int result = array[mid]; int times = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (result==array[i])&#123; times++; &#125; &#125; if (times*2 &lt;= array.length) result = 0; return result; &#125; private int partition(int[] array, int start, int end) &#123; int flag = array[start]; int ff = start; while (start!=end) &#123; while (array[end] &gt;= flag &amp;&amp; start &lt; end) &#123; end--; &#125; while (array[start] &lt; flag &amp;&amp; start &lt; end) &#123; flag++; &#125; if (start &lt; end) &#123; int t = array[start]; array[start] = array[end]; array[end] = t; &#125; &#125; int temp = array[start]; array[start] = flag; array[ff] = temp; return start; &#125; 29 找出数组中最小的k个数字/输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 /123456789101112131415161718192021/*冒泡排序 */public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); if (input.length&lt;k) return arrayList; for (int i = 0; i &lt; k; i++) &#123; for (int j = input.length-i-1; j &gt;0 ; j--) &#123; if (input[j]&lt;input[j-1])&#123; int temp = input[j]; input[j] = input[j-1]; input[j-1] = temp; &#125; &#125; &#125; for (int j = 0; j &lt; k; j++) &#123; arrayList.add(input[j]); &#125; return arrayList;&#125; 30 寻找连续向量的最大值/题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1) / 123456789101112131415161718 public int FindGreatestSumOfSubArray(int[] array) &#123; if (array.length==0 || array==null) return 0; int curSum = 0; int greatestSum = Integer.MIN_VALUE; for (int i = 0; i &lt; array.length; i++) &#123; if (curSum&lt;0)&#123; curSum = array[i]; &#125;else &#123; curSum = curSum + array[i]; &#125; if (curSum&gt;greatestSum)&#123; greatestSum = curSum; &#125; &#125; return greatestSum;&#125; 31 求一个范围内1出现的次数求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。123456789101112131415161718192021222324252627 /* //主要思路：设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析 //根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i//当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），//每一次都包含100个连续的点，即共有(a%10+1)*100个点的百位为1//当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a%10(最高两位0-30)次是包含100个连续点，//当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a%10*100）+(b+1)，这些点百位对应为1 //当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）//综合以上三种情况，当百位对应0或&gt;=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1//之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1) */ public int NumberOf1Between1AndN_Solution(int n) &#123; if (n&lt;=0) return 0; int count = 0; for (int i = 1; i &lt;= n; i=i*10) &#123;//i表示当前分析哪一个 int a = n/i; int b = n%i; if (a%10==1)&#123; count+= b+1; &#125; count+= (a+8)/10*i; &#125; return count; &#125; 32 数组内所有数字拼在一起选出最小数/题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 /123456789101112131415161718192021public String PrintMinNumber(int [] numbers) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); String s = ""; for (int i = 0; i &lt; numbers.length; i++) &#123; arrayList.add(numbers[i]); &#125; Collections.sort(arrayList,new Comparator&lt;Integer&gt;()&#123; @Override public int compare(Integer o1, Integer o2) &#123; String str1 = o1 + "" + o2; String str2 = o2 + "" + o1; return str1.compareTo(str2); &#125; &#125;); for(int j:arrayList)&#123; s+=j; &#125; return s; &#125; 33 查找第N个丑数/题目描述把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 /12345678910111213141516171819202122232425262728 /*该思路： 我们只用比较3个数：用于乘2的最小的数、用于乘3的最小的数，用于乘5的最小的 */ public int GetUglyNumber_Solution(int index) &#123; if (index==0 || index==1) return index; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); arrayList.add(1); int i2=0,i3=0,i5=0; while (arrayList.size()&lt;index)&#123; int m2 = arrayList.get(i2)*2; int m3 = arrayList.get(i3)*3; int m5 = arrayList.get(i5)*5; int min = Math.min(m2,Math.min(m3,m5)); arrayList.add(min); if (min==m2)&#123; i2++; &#125; if (min==m3)&#123; i3++; &#125; if (min==m5)&#123; i5++; &#125; &#125; return arrayList.get(arrayList.size()-1); &#125; 34 找到字符串中只出现一次的字符题目描述在一个字符串(1&lt;=字符串长度&lt;=10000，全部由大写字母组成)中找到第一个只出现一次的字符,并返回它的位置1234567891011121314151617181920 /*HashMap法 */ public int FirstNotRepeatingChar(String str) &#123; HashMap&lt;Character,Integer&gt; hashMap = new HashMap&lt;Character, Integer&gt;(); char c[] = str.toCharArray(); for (int i = 0; i &lt; c.length; i++) &#123; if (hashMap.containsKey(c[i]))&#123; int times = hashMap.get(c[i]); hashMap.put(c[i],++times); &#125;else &#123; hashMap.put(c[i],1); &#125; &#125; for (int i = 0; i &lt; c.length; i++) &#123; if (hashMap.get(c[i])==1) return c[i]; &#125; return -1; &#125; 35 求逆序对总数/题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007输入描述:题目保证输入的数组中没有的相同的数字数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=210^5输入例子:1,2,3,4,5,6,7,0输出例子:7 */1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*归并排序的改进，把数据分成前后两个数组(递归分到每个数组仅有一个数据项)，合并数组，合并时，出现前面的数组值array[i]大于后面数组值array[j]时；则前面数组array[i]~array[mid]都是大于array[j]的，count += mid+1 - i */ int cnt = 0; public int InversePairs(int [] array) &#123; if (array==null) return 0; mergesort(array,0,array.length-1); return cnt%1000000007; &#125; public void mergesort(int[] array, int start, int end) &#123; if (start&gt;=end) return; int mid = start+(end-start)/2; mergesort(array,start,mid); mergesort(array,mid+1,end); merge(array,start,mid,end); &#125; public void merge(int[] array, int start, int mid, int end) &#123; int []tmp = new int[end-start+1]; int i = start, j=mid+1,k=0; while (i&lt;=mid&amp;&amp;j&lt;=end)&#123; if (array[i]&lt;array[j])&#123; tmp[k++] = array[i++]; &#125;else &#123; tmp[k++] = array[j++]; cnt = cnt + mid - i + 1; //防止测试例过大 if (cnt&gt;1000000007) cnt = cnt % 1000000007; &#125; &#125; while (i&lt;=mid)&#123; tmp[k++] = array[i++]; &#125; while (j&lt;=end)&#123; tmp[k++] = array[j++]; &#125; for (int l = 0; l &lt; tmp.length ; l++) &#123; array[start+l] = tmp[l]; &#125; &#125; 36 找出链表的第一个公共点题目描述输入两个链表，找出它们的第一个公共结点。1234567891011121314151617181920212223242526272829303132333435363738394041 /*找出2个链表的长度，然后让长的先走两个链表的长度差，然后再一起走（因为2个链表用公共的尾部） */ public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; if (pHead1==null||pHead2==null) return null; int l1 = 1; int l2 = 1; ListNode ph1 = pHead1; ListNode ph2 = pHead2; while(ph1!=null)&#123; ph1 = ph1.next; l1++; &#125; while(ph2!=null)&#123; ph2 = ph2.next; l2++; &#125; if (l1&gt;=l2)&#123; int step = l1-l2; while (step--&gt;0)&#123; pHead1 = pHead1.next; &#125; &#125;else &#123; int step = l2-l1; while (step--&gt;0)&#123; pHead2 = pHead2.next; &#125; &#125; while (pHead1!=null)&#123; if (pHead1==pHead2) return pHead1; pHead1 = pHead1.next; pHead2 = pHead2.next; &#125; return pHead1; &#125; 37 统计一个数字在排序数组中出现的次数题目描述统计一个数字在排序数组中出现的次数。1234567891011121314151617181920212223242526272829303132333435363738public int GetNumberOfK(int[] array, int k) &#123; int first = getFirstK( array, k, 0, array.length - 1 ); int end = getLastK( array, k, 0, array.length - 1 ); if (first!=-1 &amp;&amp; end!=-1) return end - first + 1; else return 0; &#125; public int getFirstK(int[] array, int k, int start, int end) &#123; if (end &lt; start) return -1; int mid = (start + end) &gt;&gt; 1; if (k&gt;array[mid])&#123; return getFirstK( array,k,mid+1,end ); &#125;else if (k&lt;array[mid])&#123; return getFirstK( array,k,start,mid-1 ); &#125;else if (mid-1&gt;=0 &amp;&amp; array[mid-1]==k)&#123; return getFirstK( array,k,start,mid-1 ); &#125;else &#123; return mid; &#125; &#125; public int getLastK(int[] array, int k, int start, int end) &#123; if (end &lt; start) return -1; int mid = (start + end) &gt;&gt; 1; if (k &gt; array[mid]) &#123; return getLastK( array, k, mid + 1, end ); &#125; else if (k &lt; array[mid]) &#123; return getLastK( array, k, start, mid - 1 ); &#125; else if (mid + 1 &lt;= array.length - 1 &amp;&amp; array[mid + 1] == k) &#123; return getLastK( array, k, mid + 1, end ); &#125; else &#123; return mid; &#125; &#125; 38 求树的深度/输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度 /12345678public int TreeDepth(TreeNode root) &#123; if (root==null) return 0; int nLeft = TreeDepth( root.left ); int nRight = TreeDepth( root.right ); return (nLeft &gt; nRight ? nLeft+1 : nRight + 1); &#125; 39 判断树是否为平衡二叉树题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 12345678910111213141516171819202122232425262728293031323334353637383940public boolean IsBalanced_Solution(TreeNode root) &#123; if (root==null) return true; int left = TreeDepth( root.left ); int right = TreeDepth( root.right ); int diff = left -right; if (diff&gt;1 || diff &lt;-1)&#123; return false; &#125; return IsBalanced_Solution( root.left ) &amp;&amp; IsBalanced_Solution( root.right ); &#125; public int TreeDepth(TreeNode root) &#123; if (root==null) return 0; int nLeft = TreeDepth( root.left ); int nRight = TreeDepth( root.right ); return (nLeft &gt; nRight ? nLeft+1 : nRight + 1); &#125; //方法二只需遍历一次//后续遍历时，遍历到一个节点，其左右子树已经遍历 依次自底向上判断，每个节点只需要遍历一次 private boolean isBalanced=true; public boolean IsBalanced_Solution2(TreeNode root) &#123; getDepth(root); return isBalanced; &#125; public int getDepth(TreeNode root)&#123; if(root==null) return 0; int left=getDepth(root.left); int right=getDepth(root.right); if(Math.abs(left-right)&gt;1)&#123; isBalanced=false; &#125; return right&gt;left ?right+1:left+1; &#125; 40 数组中只出现一次的两个数字一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。123456789101112131415161718192021222324252627282930313233 /*//num1,num2分别为长度为1的数组。传出参数//将num1[0],num2[0]设置为返回结果 */ int index = 0; public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) &#123; int result = 0; for (int i = 0; i &lt; array.length; i++) &#123; result = result^array[i]; &#125; index = findBit1(result); for (int i = 0; i &lt; array.length; i++) &#123; if (hasBit1(array[i]))&#123; num1[0] = num1[0]^array[i]; &#125;else &#123; num2[0] = num2[0]^array[i]; &#125; &#125; &#125; public int findBit1(int a)&#123; int temp = a; while ((temp &amp; 1)==0 &amp;&amp; index&lt;= 32)&#123; temp = temp &gt;&gt; 1; index++; &#125; return index; &#125; public boolean hasBit1(int a)&#123; a = a &gt;&gt; index; return (a &amp; 1)==1; &#125; 41 求和为S的连续正数序列题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!输出描述:输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序1234567891011121314151617181920212223242526272829303132333435363738/* 用两个数small、big分别表示序列的最小值和最大值，首先把small初始为1，big初始为2，如果small到big的和大于s, 就从序列中去掉最小的值，也就是增大small的值，如果small到big的和小于s，那么就增大big的值，又因为序列至少2个数， 所以small小于（s+1)/2。寻找small和big之间的序列和看是否满足条件即可。 */public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayLists = new ArrayList&lt;&gt;( ); if (sum &lt; 3) return arrayLists; int small = 1; int big = 2; int mid = (sum+1)/2; int curSum = small + big; while (small&lt;mid)&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;( ); if (curSum==sum)&#123; for (int i = small ; i &lt;= big; i++) &#123; list.add( i ); &#125; arrayLists.add( list ); &#125; while (curSum &gt; sum &amp;&amp; small &lt; mid)&#123; curSum = curSum - small; small++; if (curSum==sum)&#123; for (int i = small ; i &lt;= big; i++) &#123; list.add( i ); &#125; arrayLists.add( list ); &#125; &#125; big++; curSum += big; &#125; return arrayLists;&#125; 42 递增数组两个数和为S求乘积最小的两个数题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。（乘积最小的两个数就是离得最远的两个数）输出描述:对应每个测试案例，输出两个数，小的先输出。12345678910111213141516171819202122public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array, int sum) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;( ); if (array==null || sum==0) return arrayList; int start = 0; int end = array.length-1; int curSum = array[start] + array[end]; while (start&lt;=end) &#123; if (curSum == sum) &#123; arrayList.add( array[start] ); arrayList.add( array[end] ); break; &#125; else if (curSum &gt; sum) &#123; end--; &#125; else &#123; start++; &#125; curSum = array[start] + array[end]; &#125; return arrayList; &#125; 43 字符串移位题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！1234567891011121314151617181920212223242526272829303132333435363738394041/* 方法一直接翻转 */ public String LeftRotateString2(String str,int n) &#123; if (str==null||n&gt;str.length()) return ""; else &#123; char[] c = str.toCharArray(); StringBuffer sb = new StringBuffer(); for (int i = n; i &lt; c.length; i++) &#123; sb.append( c[i] ); &#125; for (int i = 0; i &lt; n; i++) &#123; sb.append( c[i] ); &#125; return sb.toString(); &#125; &#125; /* 方法二：三次翻转 */ public String LeftRotateString(String str,int n) &#123; int l = str.length(); if (str==null||n&gt;l) return ""; char[] c = str.toCharArray(); swap( c,0,n-1 ); swap( c,n,c.length-1 ); swap( c,0,c.length-1 ); String s = new String( c ); return s; &#125; public static void swap(char[] cArr,int front,int end)&#123; while(front &lt; end)&#123; char tmp = cArr[end]; cArr[end] = cArr[front]; cArr[front] = tmp; front++; end--; &#125; &#125; 44 翻转字符串及每个单词牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？123456789101112131415161718192021222324public String ReverseSentence(String str) &#123; char[] cArr = str.toCharArray(); //对整个字符串进行字符翻转 swap(cArr, 0, cArr.length - 1); int begin = 0; //对每个单词进行字符串翻转操作 for (int i = 1; i &lt; cArr.length; i++)&#123; if (cArr[i]==' ')&#123; swap(cArr,begin,i-1); begin = i+1; &#125; &#125; swap(cArr,begin,cArr.length-1); return new String(cArr);&#125;public static void swap(char[] cArr,int front,int end)&#123; while(front &lt; end)&#123; char tmp = cArr[end]; cArr[end] = cArr[front]; cArr[front] = tmp; front++; end--; &#125;&#125; 增：骰子各个点数出现的概率题目：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。1234567891011121314151617181920212223242526272829303132333435public class Problem43 &#123; public static void main(String[] args) &#123; Problem43 p=new Problem43(); p.printProbability(2); &#125; public void printProbability(int number)&#123; if(number&lt;1) return; int gMaxValue=6; int[][] probabilities=new int[2][]; probabilities[0]=new int[gMaxValue*number+1]; probabilities[1]=new int[gMaxValue*number+1]; int flag=0; for(int i=1;i&lt;gMaxValue;i++)&#123; probabilities[flag][i]=1; &#125; for(int k=2;k&lt;=number;++k)&#123; for(int i=0;i&lt;k;i++)&#123; probabilities[1-flag][i]=0; &#125; for(int i=k;i&lt;=gMaxValue*k;i++)&#123; probabilities[1-flag][i]=0; for(int j=1;j&lt;=i&amp;&amp;j&lt;=gMaxValue;j++) probabilities[1-flag][i]+=probabilities[flag][i-j]; &#125; flag=1-flag; &#125; double total=Math.pow(gMaxValue, number); for(int i=number;i&lt;gMaxValue*number;i++)&#123; double ratio=(double)probabilities[flag][i]/total; System.out.print(i+" "); System.out.println(ratio); &#125; &#125;&#125; 45 判断带通配符序列的是否连续题目描述LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。1234567891011121314151617181920212223public boolean isContinuous(int [] numbers) &#123; if (numbers==null || numbers.length &lt; 5) return false; Arrays.sort( numbers ); int numZero = 0; int numGap = 0; for (int i = 0; i &lt; numbers.length&amp;&amp;numbers[i]==0; i++) &#123; numZero++; &#125; int small = numZero; int big = small + 1; while (big &lt; numbers.length)&#123; if (numbers[small]==numbers[big]) return false; numGap += numbers[big]-numbers[small]-1; small=big; big++; &#125; return (numGap&gt;numZero) ? false : true;&#125; 46 约瑟夫环题目描述每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*如果只求最后一个报数胜利者的话，我们可以用数学归纳法解决该问题，为了讨论方便，先把问题稍微改变一下，并不影响原意：问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人继续从0开始报数。求胜利者的编号。我们知道第一个人(编号一定是m%n-1) 出列之后，剩下的n-1个人组成了一个新的约瑟夫环（以编号为k=m%n的人开始）:k k+1 k+2 ... n-2, n-1, 0, 1, 2, ... k-2并且从k开始报0。现在我们把他们的编号做一下转换：k --&gt; 0k+1 --&gt; 1k+2 --&gt; 2......k-2 --&gt; n-2k-1 --&gt; n-1变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解：例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情况的解吗？！！变回去的公式很简单，相信大家都可以推出来：x'=(x+k)%n。令f[i]表示i个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]。递推公式f[1]=0;f[i]=(f[i-1]+m)%i; (i&gt;1)有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。因为实际生活中编号总是从1开始，我们输出f[n]+1。*/ //递归法 public int LastRemaining_Solution2(int n, int m) &#123; if (n&lt;1 || m &lt; 1) return -1; if (n==1) return 1; else return (LastRemaining_Solution2(n-1,m)+m)%n; &#125; //循环法 public int LastRemaining_Solution(int n, int m) &#123; if (n&lt;1 || m &lt; 1) return -1; int last = 0; for (int i = 2; i &lt;= n ; i++) &#123; last = (last + m)% i; &#125; return last; &#125; //正常法 //数组来模拟环 public int LastRemaining_Solution3(int n, int m) &#123; if (n&lt;1 || m &lt;1) return -1; int []arrary = new int[n]; int i = -1,step = 0, count = n; while (count&gt;0)&#123;//跳出循环时将最后一个元素也设置为了-1 i++; //指向上一个被删除对象的下一个元素。 if (i&gt;=n) //模拟环 i=0; if (arrary[i]==-1) continue; //跳过已经删除的对象 step++; if (step==m)&#123; arrary[i] = -1; step = 0; count--; &#125; &#125; return i; &#125; //运用ArrayList public int LastRemaining_Solution4(int n, int m) &#123; if (n&lt;1 || m &lt; 1) return -1; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;( ); for (int i = 0; i &lt; n; i++) &#123; arrayList.add( i ); &#125; int index = -1; while (arrayList.size()&gt;1)&#123; index = (index+m)%arrayList.size(); arrayList.remove( index ); index--; &#125; return arrayList.get( 0 ); &#125; 47 1+2+3+…+n不得使用判断条件及乘除法题目描述求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。123456789 /*&amp;&amp;就是逻辑与，逻辑与有个短路特点，前面为假，后面不计算 */ public int Sum_Solution(int n) &#123; int ans = n; boolean a; a= ans&gt;=1 &amp;&amp; (ans+=Sum_Solution( n-1 ))&gt;=0; return ans; &#125; 48 不用加法求两个数之和题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。1234567891011121314151617181920212223242526/*首先看十进制是如何做的： 5+7=12，三步走第一步：相加各位的值，不算进位，得到2。第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。 继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。 */ public int Add(int num1,int num2) &#123; while (num2!=0)&#123; int sum = num1^num2; //不考虑进位相加 int carry = (num1&amp;num2)&lt;&lt;1; //进位 num1 = sum; num2 = carry; &#125; return num1; &#125; 49 字符串转为数字题目描述将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0输入描述:输入一个字符串,包括数字字母符号,可以为空 输出描述:如果是合法的数值表达则返回该数字，否则返回0 输入例子:+2147483647 1a33 输出例子:2147483647 01234567891011121314151617181920public int StrToInt(String str) &#123; if (str=="" || str.length()==0) return 0; int flag = 0; char [] a = str.toCharArray(); if (a[0]=='-') &#123; flag = 1; a[0] = '0'; &#125; if (a[0]=='+') &#123; a[0] = '0'; &#125; int sum = 0; for (int i = 0; i &lt; a.length; i++) &#123; if (a[i]&gt;'9' || a[i]&lt;'0') return 0; sum = sum*10 + a[i] - '0'; &#125; return flag==0?sum : sum*-1; &#125; 50 找出数组内任意一个重复的数字在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。12345678910111213141516171819// Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation; // Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++ // 这里要特别注意~返回任意重复的一个，赋值duplication[0] // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false public boolean duplicate(int numbers[],int length,int [] duplication) &#123; boolean[] k = new boolean[length]; for (int i = 0; i &lt; length; i++) &#123; if (k[numbers[i]]==true)&#123; duplication[0] = numbers[i]; return true; &#125; k[numbers[i]] = true; &#125; return false; &#125; 51 乘积数组的构建题目描述给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。12345678910111213141516171819202122232425262728293031323334353637383940414243 /*B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]由此可知B[i]可拆分成两部分，一部分为C[i]=A[0]*A[1]*...*A[i-1];D[i]=A[i+1]*...*A[n-1]。B0 1 A1 A2 ... An-2 An-1B1 A0 1 A2 ... An-2 An-1B2 A0 A1 1 ... An-2 An-1... A0 A1 ... 1 An-2 An-1Bn-2 A0 A1 A2 ... 1 An-1Bn-1 A0 A1 Aw ... An-2 1又根据C[i]和D[i]的特性可以得知。C[i]=C[i-1]*A[i-1]; //左下角部分D[i]=D[i+1]*A[i+1]; //右上角部分 */ public int[] multiply(int[] A) &#123; int len = A.length; int forward[] = new int[len]; int backward[] = new int[len]; int B[] = new int[len]; forward[0] = 1; backward[len-1] = 1; //下三角求C for (int i = 1 ; i &lt; len; i++) &#123; forward[i] = forward[i-1]*A[i-1]; &#125; //上三角求D for (int i = len-2; i&gt;=0; i--) &#123; backward[i] = backward[i+1]*A[i+1]; &#125; for (int i = 0; i &lt; len; i++) &#123; B[i] = forward[i] * backward[i]; &#125; return B; &#125; 52 正则表达式的匹配题目描述请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 /*当模式中的第二个字符不是“*”时： 1、如果字符串第一个字符和模式中的第一个字符相匹配，那么字符串和模式都后移一个字符，然后匹配剩余的。 2、如果 字符串第一个字符和模式中的第一个字符相不匹配，直接返回false。 而当模式中的第二个字符是“*”时： 如果字符串第一个字符跟模式第一个字符不匹配，则模式后移2个字符，继续匹配。 如果字符串第一个字符跟模式第一个字符匹配，可以有3种匹配方式： 1、模式后移2字符，相当于x*被忽略； 2、字符串后移1字符，模式后移2字符；相当于匹配一个 3、字符串后移1字符，模式不变，即继续匹配字符下一位，因为*可以匹配多位；相当于匹配多位 这里需要注意的是：Java里，要时刻检验数组是否越界。 */ public boolean match(char[] str, char[] pattern) &#123; if (pattern==null || str==null) return false; int strIndex = 0; int patternIndex = 0; return matchCore(str,strIndex,pattern,patternIndex); &#125; private boolean matchCore(char[] str, int strIndex, char[] pattern, int patternIndex) &#123; //有效性检查二者都到达尾部，匹配成功 if (str.length==strIndex &amp;&amp; pattern.length==patternIndex) &#123; return true; &#125; //pattern先到尾部匹配失败 if (strIndex!=str.length &amp;&amp; patternIndex==pattern.length) return false; //正则第二个字符是*，且字符串第1个跟正则第1个匹配,分3种匹配模式； // 如不匹配，模式后移2位 if (patternIndex+1&lt;pattern.length &amp;&amp; pattern[patternIndex+1]=='*')&#123; if ((strIndex!=str.length &amp;&amp; str[strIndex]==pattern[patternIndex]) ||(strIndex!=str.length &amp;&amp; pattern[patternIndex]=='.'))&#123; //字符串第一个和正则第一个匹配 //模式忽略x*直接后移 return matchCore(str,strIndex,pattern,patternIndex+2)|| //字符后移1，正则后移2相当于只匹配一个 matchCore(str,strIndex+1,pattern,patternIndex+2) //字符后移1，正则不懂，相当于匹配多个 ||matchCore(str,strIndex+1,pattern,patternIndex); &#125;else&#123; return matchCore(str,strIndex,pattern,patternIndex+2); &#125; &#125; //正则第二个字符不是*,如果第一个字符匹配，则都后移以为，否则返回false if ((strIndex!=str.length &amp;&amp; pattern[patternIndex]==str[strIndex])|| (strIndex!=str.length&amp;&amp;pattern[patternIndex]=='.'))&#123; return matchCore(str,strIndex+1,pattern,patternIndex+1); &#125; return false; &#125; 53 判断字符串是否用来表示数值题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean isNumeric2(char[] str) &#123; //正则 String string = String.valueOf(str); return string.matches("[\\+-]?[0-9]*(\\.[0-9]*)?([eE][\\+-]?[0-9]+)?");&#125;public boolean isNumeric(char[] s) &#123; if (s == null) return false; if(s.length==0) return false; if((s.length==1)&amp;&amp;(s[0]&lt;'0'||s[0]&gt;'9')) return false; if(s[0]=='+'||s[0]=='-')&#123; if(s.length==2&amp;&amp;(s[1]=='.')) return false; &#125;else if((s[0]&lt;'0'||s[0]&gt;'9')&amp;&amp;s[0]!='.') return false;//首位既不是符号也不是数字还不是小数点，当然是false int i = 1; while((i&lt;s.length)&amp;&amp;(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9')) i++; if(i&lt;s.length&amp;&amp;s[i]=='.')&#123; i++; if(i&gt;=s.length) return false; while((i&lt;s.length)&amp;&amp;(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9')) i++; &#125; if(i&lt;s.length&amp;&amp;(s[i]=='e'||s[i]=='E'))&#123; i++; if((i&lt;s.length)&amp;&amp;(s[i]=='+'||s[i]=='-'))&#123; i++; if(i&lt;s.length) while((i&lt;s.length)&amp;&amp;(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9')) i++; else return false; &#125; else if(i&lt;s.length)&#123; while((i&lt;s.length)&amp;&amp;(s[i]&gt;='0'&amp;&amp;s[i]&lt;='9')) i++; &#125;else return false; &#125; if(i&lt;s.length) return false; return true;&#125; 54 找出字符流中第一个只出现一次的字符题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。输出描述:如果当前字符流没有存在出现一次的字符，返回#字符。123456789101112131415161718192021int hashtable[] = new int[256];StringBuffer stringBuffer = new StringBuffer();//Insert one char from stringstreampublic void Insert(char ch)&#123; stringBuffer.append(ch); if (hashtable[ch]==0) hashtable[ch]=1; else hashtable[ch] += 1;&#125;//return the first appearence once char in current stringstreampublic char FirstAppearingOnce()&#123; char str[] = stringBuffer.toString().toCharArray(); for (char c : str) &#123; if (hashtable[c]==1) return c; &#125; return '#';&#125; 55 在一个有环链表中找到链表环的入口题目描述一个链表中包含环，请找出该链表的环的入口结点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*1.第一步，找环中相汇点。分别用p1，p2指向链表头部，p1每次走一步，p2每次走二步，直到p1==p2找到在环中的相汇点。2.第二步，找环的入口。接上步，当p1==p2时，p2所经过节点数为2x,p1所经过节点数为x,设环中有n个节点,p2比p1多走一圈有2x=n+x;n=x;可以看出p1实际走了一个环的步数，再让p2指向链表头部，p1位置不变，p1,p2每次走一步直到p1==p2;此时p1指向环的入口。 */public ListNode EntryNodeOfLoop(ListNode pHead) &#123; ListNode meetNode = meetingNode(pHead); if (meetNode==null) return null; //先找到走到相交结点时候走了多少部 ListNode l1 = pHead; int step = 1; while (l1.next!=meetNode)&#123; step++; l1 = l1.next; &#125; //快指针先走一个环的步数 l1 = pHead; for (int i = 0; i &lt; step; i++) &#123; l1 = l1.next; &#125; ListNode l2 = pHead; while(l1!=l2)&#123; l1 = l1.next; l2 = l2.next; &#125; return l1;&#125;public ListNode meetingNode(ListNode pHead)&#123; if (pHead==null) return null; ListNode pSlow = pHead.next; if (pSlow==null) return null; ListNode pFast = pSlow.next; while (pSlow!=null &amp;&amp; pFast!=null)&#123; if (pFast==pSlow) return pFast; pSlow = pSlow.next; pFast = pFast.next; if (pFast!=null) pFast = pFast.next;//快指针走两步慢指针走一步 &#125; return null;&#125; 56 删除链表中重复的结点题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5123456789101112131415161718192021222324public ListNode deleteDuplication(ListNode pHead) &#123; if (pHead==null) return null; if (pHead!=null&amp;&amp;pHead.next==null) return pHead; ListNode first = new ListNode(-1); //trick标志 first.next = pHead; ListNode p = pHead; ListNode last = first; while (p!=null&amp;&amp;p.next!=null)&#123; if (p.val==p.next.val)&#123; int val = p.val; while (p!=null&amp;&amp;p.val==val) p = p.next; last.next = p; &#125;else &#123; last = p; p = p.next; &#125; &#125; return first.next;&#125; 57 找出中序遍历的下一个结点题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。12345678910111213141516171819202122232425262728293031/* a / \ b c / \ / \ d e f g / \ h i 中序遍历为 d,b,h,e,i,a,f,c,g 情况1：如结点b存在右孩子，他的下一个结点为右子树里面最左结点为h 情况2：结点d下一个结点为b,结点h下一个结点为e,i的下一个结点为a。 情况2总结起来就是向上遍历直到当前结点为父节点的左孩子结点 */public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if (pNode==null) return null; if (pNode.right!=null)&#123;//如果结点存在右子树就找右子树里面的最左结点 pNode = pNode.right; while (pNode.left!=null)&#123; pNode = pNode.left; &#125; return pNode; &#125; while(pNode.next!=null)&#123;//如果不存在右子树结点就找第一个当前结点为父结点左孩子的父节点 if (pNode.next.left==pNode) return pNode.next; pNode = pNode.next; &#125; return null;//知道根节点也没有找到&#125; 58 判断二叉树是否是对称的题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。123456789101112131415boolean isSymmetrical(TreeNode pRoot)&#123; return isSymmetrical(pRoot,pRoot); &#125; private boolean isSymmetrical(TreeNode pRoot, TreeNode pRoot1) &#123; if (pRoot==null&amp;&amp;pRoot1==null) return true; if (pRoot==null||pRoot1==null) return false; if (pRoot.val!=pRoot1.val) return false; return isSymmetrical(pRoot.left,pRoot1.right) &amp;&amp;isSymmetrical(pRoot.right,pRoot1.left); &#125; 59 之字形打印二叉树题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* */public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayLists = new ArrayList&lt;&gt;(); if (pRoot==null) return arrayLists; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(pRoot); int start=0,end = 1; boolean leftToRght = true; while (!queue.isEmpty())&#123; TreeNode p = queue.poll(); arrayList.add(p.val); start++; if (p.left!=null) queue.add(p.left); if (p.right!=null) queue.add(p.right); if (start==end)&#123; end = queue.size(); start = 0; if (leftToRght) &#123; arrayLists.add(arrayList); &#125; if (!leftToRght)&#123; arrayLists.add(reverse(arrayList)); &#125; leftToRght=!leftToRght; arrayList = new ArrayList&lt;&gt;(); &#125; &#125; return arrayLists;&#125;public ArrayList&lt;Integer&gt; reverse(ArrayList&lt;Integer&gt; arrayList) &#123; int len = arrayList.size(); ArrayList&lt;Integer&gt; reverseArrayList = new ArrayList&lt;&gt;(); for (int i = len-1; i &gt;=0 ; i--) &#123; reverseArrayList.add(arrayList.get(i)); &#125; return reverseArrayList;&#125; 60 层序打印二叉树题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。12345678910111213141516171819202122232425262728ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayLists = new ArrayList&lt;&gt;(); if (pRoot==null) return arrayLists; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.add(pRoot); int start=0,end = 1; while (!queue.isEmpty())&#123; TreeNode p = queue.poll(); arrayList.add(p.val); start++; if (p.left!=null) queue.add(p.left); if (p.right!=null) queue.add(p.right); if (start==end)&#123; end = queue.size(); start = 0; arrayLists.add(arrayList); arrayList = new ArrayList&lt;&gt;(); &#125; &#125; return arrayLists;&#125; 61 序列化反序列化二叉树题目描述请实现两个函数，分别用来序列化和反序列化二叉树123456789101112131415161718192021222324252627public int index = -1;String Serialize(TreeNode root) &#123; StringBuffer stringBuffer = new StringBuffer( ); if (root==null)&#123; stringBuffer.append( "#," ); return stringBuffer.toString(); &#125; stringBuffer.append( root.val + "," ); stringBuffer.append( Serialize( root.left ) ); stringBuffer.append( Serialize( root.right ) ); return stringBuffer.toString();&#125;TreeNode Deserialize(String str) &#123; index++; int len = str.length(); if (index&gt;=len) return null; String []strr = str.split( "," ); TreeNode node = null; if (!strr[index].equals( "#" ))&#123; node = new TreeNode( Integer.valueOf( strr[index] ) ); node.left = Deserialize(str); node.right = Deserialize(str); &#125; return node;&#125; 62 寻找儿茶搜索树第K大的结点题目描述给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。1234567891011121314151617181920/* 中序遍历得到的就是一个递增序列，只要我们按照中序遍历，第K个元素就是我们要找的元素 */ int index = 0;//计数器 TreeNode KthNode(TreeNode pRoot, int k) &#123; if (pRoot==null||k&lt;=0) return null; if (pRoot!=null)&#123; TreeNode node = KthNode( pRoot.left,k ); if (node!=null) return node; index++; if (index==k) return pRoot; node = KthNode( pRoot.right,k ); if (node!=null) return node; &#125; return null; &#125; 63 大顶堆小顶堆综合求数据流的中位数题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。123456789101112131415161718192021222324252627282930313233343536373839 /*Java的PriorityQueue是从JDK1.5开始提供的新的数据结构接口，默认内部是自然排序，结果为小顶堆，也可以自定义排序器，比如下面反转比较，完成大顶堆。思路：为了保证插入新数据和取中位数的时间效率都高效，这里使用大顶堆+小顶堆的容器，并且满足：1、两个堆中的数据数目差不能超过1，这样可以使中位数只会出现在两个堆的交接处；2、大顶堆的所有数据都小于小顶堆，这样就满足了排序要求。 */ private int count = 0; private PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); private PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(15, new Comparator&lt;Integer&gt;() &#123; public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125;&#125;); public void Insert(Integer num) &#123; if (count %2 == 0) &#123;//当数据总数为偶数时，新加入的元素，应当进入小根堆 // （注意不是直接进入小根堆，而是经大根堆筛选后取大根堆中最大元素进入小根堆） // 1.新加入的元素先入到大根堆，由大根堆筛选出堆中最大的元素 maxHeap.offer(num); int filteredMaxNum = maxHeap.poll(); //2.筛选后的【大根堆中的最大元素】进入小根堆 minHeap.offer(filteredMaxNum); &#125; else &#123;//当数据总数为奇数时，新加入的元素，应当进入大根堆 // （注意不是直接进入大根堆，而是经小根堆筛选后取小根堆中最大元素进入大根堆） //1.新加入的元素先入到小根堆，由小根堆筛选出堆中最小的元素 minHeap.offer(num); int filteredMinNum = minHeap.poll(); //2.筛选后的【小根堆中的最小元素】进入小根堆 maxHeap.offer(filteredMinNum); &#125; count++; &#125; public Double GetMedian() &#123; if (count %2 == 0) &#123; return new Double((minHeap.peek() + maxHeap.peek())) / 2; &#125; else &#123; return new Double(minHeap.peek()); &#125; &#125; 64 滑动窗口的最大值题目描述给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/*队列序可以从两端删除元素，因此使用双端队列。 * 原则： * 对新来的元素k，将其与双端队列中的元素相比较 * 1）前面比k小的，直接移出队列（因为不再可能成为后面滑动窗口的最大值了!）, * 2）前面比k大的X，比较两者下标，判断X是否已不在窗口之内，不在了，直接移出队列 * 队列的第一个元素是滑动窗口中的最大值 */ public ArrayList&lt;Integer&gt; maxInWindows(int [] num, int size) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;( ); if (size==0) return res; int begin; ArrayDeque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;( ); for (int i = 0; i &lt; num.length; i++) &#123; begin = i - size + 1; if (q.isEmpty()) q.add( i ); else if (begin&gt;q.peekFirst()) q.pollFirst();//清除前端过期不在滑动窗口内的元素 while ((!q.isEmpty()) &amp;&amp; num[q.peekLast()]&lt;=num[i]) q.pollLast(); //去掉前面小于后面值的前端元素，因为前面值不可能是滑动窗口的最大元素了 q.add( i );//最大数下标加入队列 if (begin&gt;=0) res.add( num[q.peekFirst()] ); &#125; return res; &#125; /* * 思路：滑动窗口应当是队列，但为了得到滑动窗口的最大值，队列序可以从两端删除元素，因此使用双端队列。 * 原则： * 对新来的元素k，将其与双端队列中的元素相比较 * 1）前面比k小的，直接移出队列（因为不再可能成为后面滑动窗口的最大值了!）, * 2）前面比k大的X，比较两者下标，判断X是否已不在窗口之内，不在了，直接移出队列 * 队列的第一个元素是滑动窗口中的最大值 */public ArrayList&lt;Integer&gt; maxInWindows2(int [] num, int size) &#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (num == null) &#123; return ret; &#125; if (num.length &lt; size || size &lt; 1) &#123; return ret; &#125; LinkedList&lt;Integer&gt; indexDeque = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; size - 1; i++) &#123; while (!indexDeque.isEmpty() &amp;&amp; num[i] &gt; num[indexDeque.getLast()]) &#123; indexDeque.removeLast(); &#125; indexDeque.addLast(i); &#125; for (int i = size - 1; i &lt; num.length; i++) &#123; while (!indexDeque.isEmpty() &amp;&amp; num[i] &gt; num[indexDeque.getLast()]) &#123; indexDeque.removeLast(); &#125; indexDeque.addLast(i); if (i - indexDeque.getFirst() + 1 &gt; size) &#123; indexDeque.removeFirst(); &#125; ret.add(num[indexDeque.getFirst()]); &#125; return ret; &#125; 65 回溯判断矩阵内是否存在符合条件的字符串路径题目描述请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如[a b c e s f c s a d e e]是3*4矩阵，其包含字符串”bcced”的路径，但是矩阵中不包含“abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。123456789101112131415161718192021222324252627282930313233343536373839/** 用一个状态数组保存之前访问过的字符，然后再分别按上，下，左，右递归，找不到就回溯 */ public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; int flag[] = new int[matrix.length]; for(int i=0;i&lt;rows;i++)&#123; for (int j = 0; j&lt;cols; j++)&#123; if(helper(matrix,rows,cols,i,j,str,0,flag)) return true; &#125; &#125; return false; &#125; public boolean helper(char[] matrix, int rows, int cols, int i, int j, char[] str, int k, int[] flag) &#123; int index = i*cols + j; if(i&lt;0||i&gt;=rows||j&lt;0||j&gt;=cols||matrix[index]!=str[k]||flag[index]==1)&#123;//不符合条件或者是该格子字符不是要找的，或者该格子已经走过 return false; &#125; //如果该格子是下一个要找的 if(k==str.length - 1)//长度达到要找的长度，证明全找到路径存在 return true; //没有到达末尾 flag[index] = 1; //判断下一步上下左右能否找到,分别在上下左右寻找 if(helper(matrix,rows,cols,i-1,j,str,k+1,flag) ||helper(matrix,rows,cols,i+1,j,str,k+1,flag) ||helper(matrix,rows,cols,i,j-1,str,k+1,flag) ||helper(matrix,rows,cols,i,j+1,str,k+1,flag) )&#123; return true; &#125; //如果找不到回溯 flag[index] = 0; return false; &#125; 66 判断机器人能走到多少个格子题目描述地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？12345678910111213141516171819202122232425262728293031323334public int movingCount(int threshold, int rows, int cols) &#123; int flag[][] = new int[rows][cols]; return helper(0,0,rows,cols,flag,threshold); &#125; /* 递归思想走下去 */ public int helper(int i,int j,int rows,int cols,int flag[][],int threshold)&#123; int count = 0; //首先判断是否在超过边界，或者不满足条件，或者已经走过 if(threshold&lt;=0||i&lt;0||i&gt;=rows||j&lt;0||j&gt;=cols||(sum(i)+sum(j))&gt;threshold||flag[i][j]==1) return 0; //如果一切符合条件变为1表示已经走过 flag[i][j] = 1; //当前步加上向其他4个方向各能走的步数 count = helper(i+1,j,rows,cols,flag,threshold) +helper(i-1,j,rows,cols,flag,threshold) +helper(i,j+1,rows,cols,flag,threshold) +helper(i,j-1,rows,cols,flag,threshold)+1; return count; &#125; //判断位数之和 public int sum(int i)&#123; int sum = 0; while(i&gt;0)&#123; sum += i%10; i = i/10; &#125; return sum; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[8皇后]]></title>
      <url>%2F2017%2F03%2F14%2F8%E7%9A%87%E5%90%8E%2F</url>
      <content type="text"><![CDATA[8皇后之间需满足： 1.不在同一行上 2.不在同一列上 3.不在同一斜线上 4.不在同一反斜线上 ​ 这为我们提供一种遍历的思路，我们可以逐行或者逐列来进行可行摆放方案的遍历，每一行（或列）遍历出一个符合条件的位置，接着就到下一行或列遍历下一个棋子的合适位置，这种遍历思路可以保证我们遍历过程中有一个条件是绝对符合的——就是下一个棋子的摆放位置与前面的棋子不在同一行（或列）。接下来，我们只要判断当前位置是否还符合其他条件，如果符合，就遍历下一行（或列）所有位置，看看是否继续有符合条件的位置，以此类推，如果某一个行（或列）的所有位置都不合适，就返回上一行（或列）继续该行（或列）的其他位置遍历，当我们顺利遍历到最后一行（或列），且有符合条件的位置时，就是一个可行的8皇后摆放方案，累加一次八皇后可行方案的个数，然后继续遍历该行其他位置是否有合适的，如果没有，则返回上一行，遍历该行其他位置，依此下去。这样一个过程下来，我们就可以得出所有符合条件的8皇后摆放方案了。这是一个深度优先遍历的过程，同时也是经典的递归思路。 ​ 接下来，我们以逐列遍历，具体到代码，进一步说明。首先，从第一列开始找第一颗棋子的合适位置，我们知道，此时第一列的任何一个位置都是合适的，当棋子找到第一个合适的位置后，就开始到下一列考虑下一个合适的位置，此时，第二列的第一行及第二行显然就不能放第二颗棋子了，因为其与第一个棋子一个同在一行，一个同在一条斜线上。第二列第三行成为第二列第一个合适的位置，以此类推，第三列的第5行又会是一个合适位置，这个过程中，我们注意到，每一列的合适位置都是受到前面几列的位置所影响，归纳如下： ​ 假设前面1列的棋子放在第3行，那当前列不能放的位置就一定是3行，2行，4行。因为如果放在这三行上就分别跟前一列的棋子同在一行、同在斜线、同在反斜线上，不符合我们的要求。现在我们用cols数组来表示8个列棋子所放的行数，数组下标从0开始，其中数组下标表示列数，数组的元素值表示该列棋子所在行数，当前列为N（N&gt;=0,N&lt;8），即cols[N-1]=3,则有： ​ cols[N] != cols[N-1]（=3，表示不在同一行） ​ cols[N] != cols[N-1]-1（=3-1=2，表示不在同一斜线上) ​ cols[N]!=cols[N-1]+1(=3+1,表示不在同一反斜线上) ​ 这里我们注意到，如果N-2列存在的话，那么我们还要考虑当前列N不与N-2列的棋子同行，同斜线，同反斜线。把当前列N的前面的某一列设为m,则m的所有取值为｛m&gt;=0,m&lt;N｝的集合,故又可在上面式子的基础，归纳为如下： ​ cols[N] != cols[m]（与第m列的棋子不在同一行） ​ cols[N] != cols­­[m] -（N-m）(&gt;=0 ,与第m列的棋子不在同一斜线上) ​ cols[N] != cols­­[m] + (N-m) (&lt;=8-1,与第m列的棋子不在同一反斜线上) ​ 具体到代码，很显然，取m的所有值只需要一句循环，同时我们为每一列定义一个长度为8的布尔数组row[],下标同样是从0开始，我们规定当row[i]=true时，表示该列第i行不能放棋子。这样我们就能写成下列程序段了： 1234567boolean[] rows = new boolean[8]; for(int m=0;m&lt;N;i++)&#123; rows[cols[m­]]=true;//当前列N的棋子不能放在前面列m的棋子所在行。 int d = N-m;//该句用于设置当前列N的棋子不能放在前面列m的棋子的斜线上 if(cols­­-d &gt;= 0)rows[cols­-d]=true； // 该句用于设置当前列N的棋子不能放在前面列m的棋子的反斜线上if(cols+d &lt;=8-1)rows[cols­+d]=true; &#125; ​ 好了，到此为止，我们程序的核心内容都具备了，一个基于深度优先的遍历流程和一个判断位置是否合适的算法。下面贴出运行后算出的所有可行方案（即92种，“+”号代表空棋位，“0”代表皇后所在位置），源码（注源码变量名定义与上述略有不同，打印效果也不是图片所显示的效果，代码有做些微改动）。 ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Queen8 &#123; public static int num = 0; //累计方案总数 public static final int MAXQUEEN = 8;//皇后个数，同时也是棋盘行列总数 public static int[] cols = new int[MAXQUEEN]; //定义cols数组，表示8列棋子摆放情况 public Queen8() &#123; //核心函数 getArrangement(0); System.out.print("\n"); System.out.println(MAXQUEEN+"皇后问题有"+num+"种摆放方法。"); &#125; public void getArrangement(int n)&#123; //遍历该列所有不合法的行，并用rows数组记录，不合法即rows[i]=true boolean[] rows = new boolean[MAXQUEEN]; for(int i=0;i&lt;n;i++)&#123; rows[cols[i]]=true; int d = n-i; if(cols[i]-d &gt;= 0)rows[cols[i]-d]=true; if(cols[i]+d &lt;= MAXQUEEN-1)rows[cols[i]+d]=true; &#125; for(int i=0;i&lt;MAXQUEEN;i++)&#123; //判断该行是否合法 if(rows[i])continue; //设置当前列合法棋子所在行数 cols[n] = i; //当前列不为最后一列时 if(n&lt;MAXQUEEN-1)&#123; getArrangement(n+1); &#125;else&#123; //累计方案个数 num++; //打印棋盘信息 printChessBoard(); &#125; &#125; &#125; public void printChessBoard()&#123; System.out.print("第"+num+"种走法 \n"); for(int i=0;i&lt;MAXQUEEN;i++)&#123; for(int j=0;j&lt;MAXQUEEN;j++)&#123; if(i==cols[j])&#123; System.out.print("0 "); &#125;else System.out.print("+ "); &#125; System.out.print("\n"); &#125; &#125; public static void main(String args[])&#123; Queen8 queen = new Queen8(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图的深度优先搜索和广度优先搜索]]></title>
      <url>%2F2017%2F03%2F14%2F%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%2F</url>
      <content type="text"><![CDATA[遍历图的遍历，所谓遍历，即是对结点的访问。一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略： 深度优先遍历 广度优先遍历 深度优先深度优先遍历，从初始访问结点出发，我们知道初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点。总结起来可以这样说：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。 我们从这里可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。 具体算法表述如下： 访问初始结点v，并标记结点v为已访问。 查找结点v的第一个邻接结点w。 若w存在，则继续执行4，否则算法结束。 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。 查找结点v的w邻接结点的下一个邻接结点，转到步骤3。 例如下图，其深度优先遍历顺序为 1-&gt;2-&gt;4-&gt;8-&gt;5-&gt;3-&gt;6-&gt;7 广度优先类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点。 具体算法表述如下： 访问初始结点v并标记结点v为已访问。 结点v入队列 当队列非空时，继续执行，否则算法结束。 出队列，取得队头结点u。 查找结点u的第一个邻接结点w。 若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤： 1231). 若结点w尚未被访问，则访问结点w并标记为已访问。2). 结点w入队列3). 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6。 如下图，其广度优先算法的遍历顺序为：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8 Java实现邻接矩阵图模型类 AMWGraph.java，在原先类的基础上增加了两个遍历的函数，分别是 depthFirstSearch() 和 broadFirstSearch() 分别代表深度优先和广度优先遍历。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139import java.util.ArrayList;import java.util.LinkedList;/** * @description 邻接矩阵模型类 * @author beanlam * @time 2015.4.17 */public class AMWGraph &#123; private ArrayList vertexList;//存储点的链表 private int[][] edges;//邻接矩阵，用来存储边 private int numOfEdges;//边的数目 public AMWGraph(int n) &#123; //初始化矩阵，一维数组，和边的数目 edges=new int[n][n]; vertexList=new ArrayList(n); numOfEdges=0; &#125; //得到结点的个数 public int getNumOfVertex() &#123; return vertexList.size(); &#125; //得到边的数目 public int getNumOfEdges() &#123; return numOfEdges; &#125; //返回结点i的数据 public Object getValueByIndex(int i) &#123; return vertexList.get(i); &#125; //返回v1,v2的权值 public int getWeight(int v1,int v2) &#123; return edges[v1][v2]; &#125; //插入结点 public void insertVertex(Object vertex) &#123; vertexList.add(vertexList.size(),vertex); &#125; //插入结点 public void insertEdge(int v1,int v2,int weight) &#123; edges[v1][v2]=weight; numOfEdges++; &#125; //删除结点 public void deleteEdge(int v1,int v2) &#123; edges[v1][v2]=0; numOfEdges--; &#125; //得到第一个邻接结点的下标 public int getFirstNeighbor(int index) &#123; for(int j=0;j&lt;vertexList.size();j++) &#123; if (edges[index][j]&gt;0) &#123; return j; &#125; &#125; return -1; &#125; //根据前一个邻接结点的下标来取得下一个邻接结点 public int getNextNeighbor(int v1,int v2) &#123; for (int j=v2+1;j&lt;vertexList.size();j++) &#123; if (edges[v1][j]&gt;0) &#123; return j; &#125; &#125; return -1; &#125; //私有函数，深度优先遍历 private void depthFirstSearch(boolean[] isVisited,int i) &#123; //首先访问该结点，在控制台打印出来 System.out.print(getValueByIndex(i)+" "); //置该结点为已访问 isVisited[i]=true; int w=getFirstNeighbor(i);// while (w!=-1) &#123; if (!isVisited[w]) &#123; depthFirstSearch(isVisited,w); &#125; w=getNextNeighbor(i, w); &#125; &#125; //对外公开函数，深度优先遍历，与其同名私有函数属于方法重载 public void depthFirstSearch() &#123; for(int i=0;i&lt;getNumOfVertex();i++) &#123; //因为对于非连通图来说，并不是通过一个结点就一定可以遍历所有结点的。 if (!isVisited[i]) &#123; depthFirstSearch(isVisited,i); &#125; &#125; &#125; //私有函数，广度优先遍历 private void broadFirstSearch(boolean[] isVisited,int i) &#123; int u,w; LinkedList queue=new LinkedList(); //访问结点i System.out.print(getValueByIndex(i)+" "); isVisited[i]=true; //结点入队列 queue.addlast(i); while (!queue.isEmpty()) &#123; u=((Integer)queue.removeFirst()).intValue(); w=getFirstNeighbor(u); while(w!=-1) &#123; if(!isVisited[w]) &#123; //访问该结点 System.out.print(getValueByIndex(w)+" "); //标记已被访问 isVisited[w]=true; //入队列 queue.addLast(w); &#125; //寻找下一个邻接结点 w=getNextNeighbor(u, w); &#125; &#125; &#125; //对外公开函数，广度优先遍历 public void broadFirstSearch() &#123; for(int i=0;i&lt;getNumOfVertex();i++) &#123; if(!isVisited[i]) &#123; broadFirstSearch(isVisited, i); &#125; &#125; &#125;&#125; 上面的public声明的depthFirstSearch()和broadFirstSearch()函数，是为了应对当该图是非连通图的情况，如果是非连通图，那么只通过一个结点是无法完全遍历所有结点的。 下面根据上面用来举例的图来构造测试类： 123456789101112131415161718192021222324252627282930313233343536public class TestSearch &#123; public static void main(String args[]) &#123; int n=8,e=9;//分别代表结点个数和边的数目 String labels[]=&#123;"1","2","3","4","5","6","7","8"&#125;;//结点的标识 AMWGraph graph=new AMWGraph(n); for(String label:labels) &#123; graph.insertVertex(label);//插入结点 &#125; //插入九条边 graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); graph.insertEdge(3, 7, 1); graph.insertEdge(4, 7, 1); graph.insertEdge(2, 5, 1); graph.insertEdge(2, 6, 1); graph.insertEdge(5, 6, 1); graph.insertEdge(1, 0, 1); graph.insertEdge(2, 0, 1); graph.insertEdge(3, 1, 1); graph.insertEdge(4, 1, 1); graph.insertEdge(7, 3, 1); graph.insertEdge(7, 4, 1); graph.insertEdge(6, 2, 1); graph.insertEdge(5, 2, 1); graph.insertEdge(6, 5, 1); System.out.println("深度优先搜索序列为："); graph.depthFirstSearch(); System.out.println(); System.out.println("广度优先搜索序列为："); graph.broadFirstSearch(); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数组相关算法]]></title>
      <url>%2F2017%2F03%2F07%2F%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[寻找数组中最小值与最大值。方法一：维持2个变量min与max，每次取一个元素分别与两个变量比较，最后通过一次数组遍历找到最大值与最小值，虽然时间复杂度是O（n）但是比较次数是2.方法二：维持2个变量min和max,每次取相邻的两个数，较大者和max比，较小者和min比，以这样的方式找到最大值与最小值，时间复杂度为O（n/2）=O(n),但是比较次数为1.5N方法三：分治法。方法二代码如下：12345678910111213141516171819202122232425262728293031323334353637public class MaxAndMin &#123; static int max; static int min; public static void getMaxAndMin(int[] a)&#123; max = a[0]; min = a[0]; int n = a.length; for (int i = 1; i &lt; n-1; i=i+2) &#123; if(i+1&gt;n)&#123; if (a[i]&gt;max) max = a[i]; if (a[i]&lt;min) min = a[i]; &#125; if (a[i]&gt;a[i+1])&#123; if (a[i]&gt;max) max = a[i]; if (a[i+1]&lt;min) min = a[i+1]; &#125; if (a[i]&lt;a[i+1])&#123; if (a[i+1]&gt;max) max = a[i+1]; if(a[i]&lt;min) min = a[i]; &#125; &#125; &#125; public static void main(String[] args)&#123; int[] a = &#123;7,3,19,40,4,7,1&#125;; getMaxAndMin(a); System.out.println("Max=" + max); System.out.println("Min=" + min); &#125;&#125; 找出数组中第二大的数方法一：可以用快排将里面的数进行排序，时间复杂度O(nlogn)，然后根据下标遍历数组，时间复杂度O(n),所以总的时间复杂度为O(nlogn)。方法二：可用两个变量分别记录最大值与第二大值，若出现新变量比最大值大那么第二大值记录原最大值，最大值记录新变量，如果比最大变量小，那么直接与第二大变量比较大小，这样遍历一遍数组就可以得到第二大数。方法二代码如下：12345678910111213141516171819202122232425public class SecondMax &#123; public static int findSecMax(int[] data)&#123; int count = data.length; int max_Number = data[0]; int sec_Number = Integer.MIN_VALUE; for (int i = 1 ; i &lt; count; i++) &#123; if (data[i]&gt;max_Number) &#123; sec_Number = max_Number; max_Number = data[i]; &#125;else &#123; if (data[i]&gt;sec_Number)&#123; sec_Number = data[i]; &#125; &#125; &#125; return sec_Number; &#125; public static void main(String[] args)&#123; int[] arry = &#123;7,3,19,40,4,7,1,2&#125;; System.out.println(findSecMax(arry)); &#125;&#125; 如何求最大子数组之和（动态规划）方法一：暴力法，时间复杂度O(n^2)代码如下：1234567891011121314151617181920public class MaxSubArray &#123; public static void main(String[] args)&#123; int[] a = &#123;1,-2,4,8,-4,7,-1,5&#125;; System.out.println(maxSubArrayMethod1(a)); &#125; private static int maxSubArrayMethod1(int[] a) &#123; int size = a.length; int max_sum = 0; for (int i = 0; i &lt; size; i++) &#123; int sum = 0; for (int j = i; j &lt; size; j++) &#123; sum += a[j]; if (sum&gt;max_sum)&#123; max_sum = sum; &#125; &#125; &#125; return max_sum; &#125; 方法二：动态规划法思路如下：1.最大子数组包含arr[n-1],即是以数组最后一个元素arr[n-1]结尾。2.arr[n-1]自己单独构成最大数组。3.最大数组不包含arr[n-1]，那么求arr[1,…,n-1]的最大子字符串可以转换为求arr[1,…,n-2]的最大子字符串。通过以上可以的出结论，架设已经计算出（arr[0],…,arr[i-1]）最大的一段数组和为ALL[i-1]，同时也计算出（arr[0],…,arr[i-1]）中包含arr[i-1]的最大的一段数组和为End[i-1]。则可以得出如下关系ALL[i-1] = max {arr[i-1],End[i-1],arr[i-2]}。利用这个公式和动态规划的思想可以得出如下代码：123456789101112131415161718192021222324public class MaxSubArray &#123; public static void main(String[] args) &#123; int[] a = &#123;1, -2, 4, 8, -4, 7, -1, -5 &#125;; System.out.println(maxSubArrayMethod2(a)); &#125; public static int max(int m, int n) &#123; return m &gt; n ? m : n; &#125; private static int maxSubArrayMethod2(int[] a) &#123; int n = a.length; int End[] = new int[n]; int All[] = new int[n]; End[n - 1] = a[n - 1]; All[n - 1] = a[n - 1]; End[0] = All[0] = a[0]; for (int i = 1; i &lt; n; i++) &#123; End[i] = max(End[i - 1]+a[i], a[i]); All[i] = max(End[i], All[i - 1]); &#125; return All[n - 1]; &#125;&#125; 上文的动态规划方法可以优化因为每次只用到End[i-1]与All[i-1]而不是整个数组中的值，所以可以定义两个变量来保存End[i-1]与All[i-1]的值，并且可以反复利用，这样就可以保证在时间复杂度为O(n)的同时降低空间复杂度。只要nEnd=max(nEnd+arr[i],arr[i]); nAll=max(nEnd,nALL); 替换上文的如上代码即可。 知道子数组的最大和之后，如何确定最大子数组的位置？为了得到最大的子数组，从公式End[i]=max(End(i-1)+a[i],a[i])的分析可以看出，当End[i-1]&lt;0的时候，End[i]=a[i],其中End[i]表示包含a[i]的子数组和，如果某一个值是的End[i-1]&lt;0,那么就从a[i]位置重新开始编号。 123456789101112131415161718192021222324252627282930public class MaxSubArrayIndex &#123; private static int begin = 0; private static int end = 0; public static void main(String[] args)&#123; int[] a = &#123;1,-2,4,8,-4,7,-1,-5&#125;; System.out.println("max=" + maxSubway(a)); System.out.println("begin=" + begin + " end=" + end); &#125; public static int maxSubway(int a[] )&#123; int maxSum = Integer.MIN_VALUE;//子数组的最大值 int nSum = 0;//包含子数组最后一位的最大值 int nStart = 0; for (int i = 0; i &lt; a.length; i++) &#123; if (nSum&lt;0)&#123; nSum = a[i]; nStart = i; &#125;else &#123; nSum += a[i]; &#125; if (nSum &gt; maxSum)&#123; maxSum = nSum; begin = nStart; end = i; &#125; &#125; return maxSum; &#125;&#125; 如何找到数组中重复最多的元素对于数组{1,1,2,2,4,4,4,4,5,5,6,6,6},元素1出现的次数为2，元素2出现次数为2，元素4出现次数为4,5出现次数2,6出现次数3。找出数组中出现重复次数最多的数。上述问题中，程序的输出应该为元素4。方法一：空间换时间。定义一个数组int count[MAX]先都初始化为0，然后每次遇到a[i]，那么cout[a[i]]++。之后找到count中值最大的，即是要找的数值。方法二：使用Map映射表。Map中第一个字记录值为关键字，第二个字记录出现次数。方法二代码如下：1234567891011121314151617181920212223242526272829303132333435363738public class MostFrequentInArray &#123; public static void main(String[] args)&#123; int a[] = &#123;1,1,2,2,4,4,4,4,5,5,6,6,6&#125;; int max_frequent = findMostFrequent(a); System.out.println(max_frequent); &#125; private static int findMostFrequent(int[] a) &#123; int result = 0; int n = a.length; if(0==n) return Integer.MAX_VALUE; //记录给个元素出现的次数 Map&lt;Integer,Integer&gt; m = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; n; i++) &#123; if (m.containsKey(a[i]))&#123; m.put(a[i],m.get(a[i])+1); &#125;else &#123; m.put(a[i],1); &#125; &#125; //找出出现次数最多的元素 int most = 0; Iterator iterator = m.entrySet().iterator(); while (iterator.hasNext())&#123; Map.Entry entry = (Map.Entry)iterator.next(); int key = (Integer)entry.getKey(); int val = (Integer)entry.getValue(); if (val&gt;most)&#123; result = key; most = val; &#125; &#125; return result; &#125;&#125; 如何求数组中两两相加等于20的组合种类给定一个数组{1,7,17,2,6,3,14}，这个数组中满足条件的有两组 17+3=20,6+14=20。方法一：蛮力法用双重循环遍历数组来判断两个数之和是否是20。时间复杂度为O(n^2)。方法二：排序法先对数组进行排序，可以用堆排序或者快速排序，时间复杂度O(nlogn)，然后对数组从前到后和从后向前遍历，假设从前向后遍历的下标为begin，从后往前的下标为end，如果arr[begin]+arr[end]20时，如果存在两个数的和为20，那么这两个数一定在[begin,end-1]之间，这个过程时间复杂度为O(n),因此整个算法的时间复杂度为O(nlogn)。1234567891011121314151617181920212223public class FindSum &#123; public static void main(String[] args)&#123; int arr[] = &#123;1,7,17,2,6,3,14&#125;; find(arr,20); &#125; private static void find(int[] arr,int sum) &#123; Arrays.sort(arr); int begin = 0; int end = arr.length - 1; while (begin&lt;end)&#123; if(arr[begin]+arr[end]&lt;sum) begin++; else if(arr[begin]+arr[end]&gt;sum) end--; else &#123; System.out.println(arr[begin] + " " + arr[end]); begin++; end--; &#125; &#125; &#125;&#125; 如何把一个数组循环右移k位假设要把数组序列12345678右移2位变为78123456。比较移位前后数组序列的形式，不难看出，其中两段的序列是不变的，即78和123456。可以把这两段看做整体，右移k位就是把数组两部分交换一下，鉴于此，可以设计这样一种算法，步骤如下：1.逆序数组子序列123456，数组序列的形式变为65432178。2.逆序数组子序列78，数组序列的形式变为65432187。3.全部逆序，数组序列的形式变为78123456。该算法进行了3次逆序操作，因此时间复杂度为O(n)。123456789101112131415161718192021222324public class ShiftK &#123; public static void main(String[] args)&#123; int arr[] = &#123;1,2,3,4,5,6,7,8&#125;; shift_k(arr,2); for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i] + " "); &#125; &#125; private static void shift_k(int[] a, int k) &#123; int n = a.length; k = k % n; reverse(a,n-k,n-1); reverse(a,0,n-k-1); reverse(a,0,n-1); &#125; public static void reverse(int[] a,int b,int e)&#123; for (;b&lt;e;b++,e--)&#123; int temp = a[e]; a[e] = a[b]; a[b] = temp; &#125; &#125;&#125; 找出数组中第K个最小的数给定一个无序的数组，从一个数组中找出第K个最小的数。对于给力定数组序列{1,5,2,6,8,0,6}，其中第4小的数为5.方法一：最简单的方法是对数组进行排序，排序后的数组中第k-1个位置的数字即为数组的第k个最小的数，最好的时间复杂度为O(nlogn)。方法二：剪枝法，运用快排的思想选定一个数tmp=a[n-1]作为枢纽，把比它都小的数放在它的左边，把比它大的数放在它的右边，然后判断tmp的位置。如果他的位置是k-1，那么他就是第K小的数。如果它的位置小于k-1，那么说明k元素一定在数组的右边，采用递归方法在数组的右半边继续查找，否则在左半部分，采用递归在左半部分数组中继续查找。时间复杂度比上一个要小。1234567891011121314151617181920212223242526272829303132333435363738public class GetKMin &#123; public static void main(String[] args)&#123; int a[] = &#123;1,5,2,6,8,0,6&#125;; int k_min = getKMinNumber(a,4); System.out.print(k_min); &#125; public static int quickSort(int a[],int low,int high,int k)&#123; int i,j; int tmp; i = low+1; j = high; tmp = a[i]; while (i&lt;j)&#123; while(i&lt;j &amp;&amp; a[j]&gt;tmp) j--; while (i&lt;j &amp;&amp; a[i]&lt;tmp) i++; if(i&lt;j)&#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; a[low] = a[i]; a[i] = tmp; if(i+1==k) return tmp; else if(i+1&gt;k) return quickSort(a,low,i-1,k); else return quickSort(a,i+1,high,k); &#125; private static int getKMinNumber(int[] a, int i) &#123; return quickSort(a,0,a.length-1,i); &#125;&#125; 如何找出数组中只出现一次的数字一个整型数组里除了一个数字之外，其他数字都出现两次，找出这个只出现1次的数字。要求时间复杂度为O(n)，空间复杂度O（1）。如果没有时间复杂度的要求那么可以将数组进行排序，时间复杂度O(nlogn)，然后从第一个数开始遍历，比较相邻的两个数，从而找到这个只出现一次的数字，这种方法复杂度最快为O(nlogn)。由于时间复杂度与空间复杂度的限制，该方法不可取，因此需要一种更高效的方式。题目强调只有一个数字出现1次，其他数字出现了2次，首先想到的是异或运算，因为异或运算的定义，任何一个数字异或它自己都等于0，所以从头到尾一次异或数组中的每一个数字，那些出现两个的都会抵消掉。最终的结果刚好是只出现一次的数。代码如下：1234567891011121314151617public class FindNotDouble &#123; public static void main(String[] args)&#123; int arr[] = &#123;1,2,3,2,4,3,5,4,1&#125;; int num = findNotDoubleNum(arr); System.out.print(num); &#125; private static int findNotDoubleNum(int[] arr) &#123; int n = arr.length; int result = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; result ^= arr[i]; &#125; return result; &#125;&#125; 上述异或运算的方法只适用于其他数字出现的次数为偶数的情况，如果其他数字出现次数为奇数，上述方法不再适用。如果数组中所有数都出现n次，那么这个数组中的所有数对应的二进制数中各个位上的1出现的个数均可以被n整除。所以对于本题，架设a只出现一次，那么去除a,后其他所有数字对应的二进制数的每个位置上1的个数为n的倍数。所以对数组中的所有数组对应二进制数中各个位置上的1的个数对3取余数，就可以得到出现1次的这个数的二进制表示。从而找到这个数。123456789101112131415161718192021222324252627public class FindOnce &#123; public static void main(String[] args)&#123; int arr[] = &#123;1,2,1,2,4,2,4,4,1,3&#125;; int num = findOnceNum(arr, 3); System.out.println(num); &#125; private static int findOnceNum(int[] arr, int appearTimes) &#123; int n = arr.length; int []bitCount = new int[32];//int类型的4个字节最多32位 //计算数组中所有数组对应的二进制数各个位置上出现1的次数。 for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; 32; k++) &#123; bitCount[k] += ((arr[j]&gt;&gt;k)&amp;1); &#125; &#125; //若某位上的结果不能被整除，则肯定目标数字在这一位上为1 int appearOne=0; for (int j = 0; j &lt; 32; j++) &#123; if (bitCount[j]% appearTimes !=0)&#123; appearOne += (1&lt;&lt;j); &#125; &#125; return appearOne; &#125;&#125; 查找数组中唯一重复的元素/数组A[N],1~N-1这个N-1个数存在a[N]中，其中某个数字重复一次。找出数组中唯一重复的元素要求每个数只能访问一次并且不用辅助空间 /12345678910111213//方法一累加求和法因为只有一个数重复累加后减去1~N-1的和就是结果 public static int findDup1(int[] a)&#123; int n = a.length; int sum1 = 0; int sum2 = 0; for (int i = 0; i &lt; n-1; i++) &#123; sum1 += a[i]; sum2 += (i+1); &#125; sum1 = sum1 + a[n-1]; int result = sum1 - sum2; return result; &#125; 用递归方式求一个整形数组的最大元素1234567891011121314151617181920public class MaxNum &#123; public static int max(int a,int b)&#123; return (a&gt;b) ? a: b; &#125; public static int getMaxNum(int [] a,int begin)&#123; int n = a.length; if(1==n)&#123; return a[begin]; &#125;else&#123; if (begin&lt;=n-2) return max(a[begin],getMaxNum(a,begin+1)); else return 0; &#125; &#125; public static void main(String[] args)&#123; int [] a = &#123;0,16,2,3,4,5,10,7,8,9&#125;; System.out.println(getMaxNum(a,0)); &#125;&#125; 求一个数组数对之差的最大值（动态规划）数组中的一个数字减去他右边子数组的中的一个数字可以得到一个差值，求所有可能的差值中的最大值。例如数组{1，4，17，3，2，9}中，最大差值为17-2=15。方法一：蛮力法。双重循环遍历数组找到所有可能的差值然后找到差值中最大的值。方法二：二分法。思想如下:把数组分为两个子数组，那么最大的差值只有3种可能1.最大的差值对应的被减数和减数都在左子数组中，假设最大的差值为leftMax。2.被减数和减数都在右子数组中，假设最大的差值为rightMax。3.被减数是在左子数组中的最大值，减数是右子数组中的最小值，假设差值为mixMax。那么由上文就可以知道最大的差值为这三个差值的最大值即max(leftMax,rightMax,mixMax)。方法三：动态规划。思路如下：给以给定数组a,申请额外的数组diff和max，diff[i]是以数组中第i个数组为减数时，当前数组所有数对之差的最大值(也就是前i+1个数组成的子数组中最大的差值)，max[i]为前i+1个数的最大值。假设已经得到diff[i]，diff[i+1]的值有两种可能，diff[i]或者max[i]-diff[i]。由上面的所有分析可以得到的计算表达式diff[i+1]=max(diff[i],max[i-1]-a[i]); max[i+1]=max(max[i],a[i+1])123456789101112131415161718192021222324252627public class MaxSub &#123; public static void main(String[] args)&#123; int [] a = &#123;1,4,17,3,2,9&#125;; System.out.println(getMax(a)); &#125; public static int max(int m,int n)&#123; return m &gt; n ? m : n; &#125; private static int getMax(int[] a) &#123; int n = a.length; if(a==null) return Integer.MIN_VALUE; if(n&lt;=1) return Integer.MIN_VALUE; int[] diff = new int[n]; int[] max = new int[n]; diff[0] = 0; max[0] = 0; for (int i = 1; i &lt; n ; i++) &#123; diff[i] = max(diff[i-1],max[i-1] - a[i]); max[i] = max(max[i-1],a[i]); &#125; return diff[n-1]; &#125;&#125; 上文还可以优化因为无需diff与max数组只是两个变量来保存前i+1个数的最大差值，和最大值即可。 求数组中绝对值最小的数有一个升序排列的数组，数组中可能有正数、负数或者为0.求数组中元素的绝对值最小的数，例如，数组{-10，-5，-2，7，15，50}，绝对值最小的是-2。绝对值最小可以分为三种情况考虑：1.数组从第一个元素开始就是非负数，那么绝对值最小的数肯定是数组的第一个元素。2.数组的最后一个元素为负数，那么绝对值最小的数一定是数组中的最后一个元素。3.数组中既有整数又有负数，那么久需要找到正数与负数的分界点，如果分界点为0，那么0就是绝对值最小的数，如果分界点不为0，那么就要看分界点左右两个正负数的绝对值来比较大小了。那么确定分界点最简单的方法就是顺序遍历数组，找出第一个非负数，时间复杂度最坏情况为O(n)。二分法解决这个比较契合，主要思想如下：1.取数组的中间位置的值a[mid]2.如果a[mid]=0，那么这个数就是绝对值最小的值3.a[mid]&gt;0，如果a[mid-1]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树相关算法]]></title>
      <url>%2F2017%2F03%2F06%2F%E6%A0%91%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[二叉树的常见概念 结点的度：节点所拥有的子树个数称为该节点的度。 叶节点：度为0的节点称为叶子节点，或者终端节点（即是树的最下层） 分枝节点：度部位0的结点称为分枝结点。一棵树的结点除叶结点以外，其余的都是分枝结点。 左孩子、右孩子、双亲：树中一个结点的子树的根节点称为这个结点的孩子，这个结点称为孩子结点的双亲，具有同一个双亲的孩子结点互称为兄弟。 祖先、子孙：在树种如果一条路径是从结点M到结点N，那么M就称为N的祖先。而N是M的子孙。 结点的层数：规定树的根节点层数为1，其余结点的层数等于他的双亲结点的层数+1。 树的深度：树中所有结点的最大层数称为树的深度。 树的度。树中所有节点度的最大值称为树的度，叶子结点的度为0. 满二叉树：在一棵树中，如果所有的分枝结点都存在左子树右子树，并且所有叶子结点都在用一层，这样的一棵二叉树称为满二叉树。 ​ 二叉树的基本性质1.性质一：一棵非空的二叉树第i层最多有2的i-1次方个结点(i&gt;&gt;1) 2.性质二：一棵深度为k的二叉树中，最多具有2的k次方然后-1个节点。 3.性质三：对于一个非空的二叉树。度为0的结点（即叶子结点）总是比度为2的结点多一个，即如果叶子结点为n_0,度为2的结点为n_2，则有n_0=n_2+1。 ​ 性质三证明：用n表示二叉树的总结点树，n_0表示度为0的结点数，n_1表示度为1的结点数，n_2表示度为2的结点数。则有n=n_0+n_1+n_2,而根据二叉树的性质可知n=n1+2*n_2+1(所有结点的度数之和+1=总结点个数)，根据两个等式就可以得出n_0=n_2+1。 性质四：具有n个结点的完全二叉树的深度为log2n+1。 ​ 性质四证明：根据性质2，深度为k的二叉树最多有2的k次方减1个结点，且完全二叉树的定义与通深度的满二叉树的前面编号相同，即他的总结点个数位于k层和k-1层的满二叉树容量之间，即2的k-1次方-1&lt;&lt;n&lt;&lt;2的k次方-1,三个同时取对数，于是又k-1&lt;&lt;log2n&lt;&lt;k，又因为k是整数，所以k=log2n+1。 性质5：如果根结点从1开始编号，左孩子编号2i,右孩子2i+1,如果从0开始编号，左孩子编号2i+1，右孩子2i+2。 二叉排序树（二叉查找树）[包含先序、后序、中序、层序]二叉排序树或者是一个空树，或者是具有下列性质的二叉树：（1） 如果左子树不空，那么左子树上所有结点的值均小于它的根节点的值。 （2）如果右子树不为空，那么右子树所有结点的值都均大于它的根节点的值。 （3）左右子树也分别为二叉排序树。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166/** * Created by fangheart on 2017/3/6. */public class Node &#123; public int data; public Node left; public Node right; public Node(int data)&#123; this.data = data; this.left = null; this.right = null; &#125;&#125;/** * Created by fangheart on 2017/3/6. */public class BinaryTree &#123; private Node root; public void BinartTree()&#123; root = null; &#125; public static void main(String[] args)&#123; BinaryTree binaryTree = new BinaryTree(); int[] data = &#123;2,8,7,4,9,3,1,6,7,5&#125;; binaryTree.buildTree(data); System.out.println("二叉树的先序遍历："); binaryTree.preOrder(binaryTree.root); System.out.println(); System.out.println("二叉树的中序遍历："); binaryTree.inOrder(binaryTree.root); System.out.println(); System.out.println("二叉树的后序遍历："); binaryTree.postOrder(binaryTree.root); System.out.println(); &#125; //将data插入到排序二叉树中 public void insert(int data)&#123; Node newNode = new Node(data); if(root == null)&#123; root = newNode; &#125;else &#123; Node current = root; Node parent; while(true)&#123;//寻找插入位置 parent = current; if (data &lt; current.data)&#123; current = current.left; if (current==null)&#123; parent.left = newNode; return; &#125; &#125;else &#123; current = current.right; if (current==null)&#123; parent.right = newNode; return; &#125; &#125; &#125; &#125; &#125; //将数值插入构建二叉树 public void buildTree(int[] data)&#123; for (int i = 0; i &lt; data.length; i++) &#123; insert(data[i]); &#125; &#125; //中序遍历输出 public void inOrder(Node localRoot)&#123; if (localRoot != null)&#123; inOrder(localRoot.left); System.out.print(localRoot.data + " "); inOrder(localRoot.right); &#125; &#125; //中序遍历非递归版本 public void inOrder2(Node localRoot)&#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); while(localRoot!=null||!stack.isEmpty())&#123; while (localRoot!=null)&#123; stack.push(localRoot); localRoot = localRoot.left; &#125; localRoot = stack.pop(); System.out.print(localRoot.data + " "); localRoot = localRoot.right; &#125; &#125; //先序遍历 public void preOrder(Node localRoot)&#123; if(localRoot != null )&#123; System.out.print(localRoot.data+" "); preOrder(localRoot.left); preOrder(localRoot.right); &#125; &#125; //先序遍历非递归版本 public void preOrder2(Node localRoot)&#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); while(localRoot!=null||!stack.isEmpty())&#123; while (localRoot!=null)&#123; System.out.print(localRoot.data + " "); stack.push(localRoot); localRoot = localRoot.left; &#125; localRoot = stack.pop(); localRoot = localRoot.right; &#125; &#125; //后续遍历 public void postOrder(Node localRoot)&#123; if(localRoot != null)&#123; postOrder(localRoot.left); postOrder(localRoot.right); System.out.print(localRoot.data + " "); &#125; &#125; //后序遍历非递归版本 public void postOrder2(Node localRoot)&#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); Stack&lt;Node&gt; outStack = new Stack&lt;Node&gt;();//后续是左右中 那我们就按中右左的方式先存入栈里 while(localRoot!=null||!stack.isEmpty())&#123; while (localRoot!=null)&#123; outStack.push(localRoot); stack.push(localRoot); localRoot = localRoot.right; &#125; localRoot = stack.pop(); localRoot = localRoot.left; &#125; while(!outStack.isEmpty())&#123; localRoot = outStack.pop(); System.out.print(localRoot.data + " "); &#125; &#125; //层序遍历 //层序遍历的主要思路是将根节点放入队列，然后每次都从队列中取出一个节点打印， //如这个节点有子节点，则将子节点放入队列，直到队列为空 public void layerTranverse()&#123; if(this.root==null) return; Queue&lt;Node&gt; q = new LinkedList&lt;Node&gt;(); q.add(this.root); while(!q.isEmpty())&#123; Node n = q.poll(); System.out.print(n.data+" "); if (n.left!=null) q.add(n.left); if(n.right!=null) q.add(n.right); &#125; &#125;&#125; 已知先序遍历和中序遍历，求后序遍历（已知中序和后序也可以求先序但已知先序和后序不能求中序，因为先序或者后序可以得知根节点，而中序用来区分左右子树）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * Created by FangHeart on 2017/3/6. */public class Node &#123; public int data; public Node left; public Node right; public Node()&#123; &#125; public Node(int data)&#123; this.data = data; this.left = null; this.right = null; &#125;&#125;/** * Created by FangHeart on 2017/3/6. */public class BinaryTree &#123; private Node root; public BinaryTree()&#123; root = null; &#125; public static void main(String[] args)&#123; BinaryTree binaryTree = new BinaryTree(); int[] preOrder = &#123;1,2,4,8,9,5,10,3,6,7&#125;; int[] inOrder = &#123;8,4,9,2,10,5,1,6,3,7&#125;; binaryTree.initTree(preOrder,inOrder); System.out.print("二叉树的后序遍历："); binaryTree.postOrder(binaryTree.root); &#125; //后序遍历方法递归实现 public void postOrder(Node localRoot)&#123; if(localRoot != null)&#123; postOrder(localRoot.left); postOrder(localRoot.right); System.out.print(localRoot.data + " "); &#125; &#125; public void initTree(int[] preOrder,int[] inOrder)&#123; this.root = this.initTree(preOrder,0,preOrder.length-1,inOrder,0,inOrder.length-1); &#125; public Node initTree(int[] preOrder,int start1,int end1,int[] inOrder,int start2,int end2)&#123; if(start1&gt;end1 || start2&gt;end2)&#123; return null; &#125; int rootData = preOrder[start1]; Node head = new Node(rootData); //找到根节点所在位置 int rootIndex = findIndexInArray(inOrder,rootData,start2,end2); int offSet = rootIndex - start2 - 1; //构建左子树 Node left = initTree(preOrder,start1+1,start1+1+offSet,inOrder,start2,start2+offSet); //构建右子树 Node right = initTree(preOrder,start1+offSet+2,end1,inOrder,rootIndex+1,end2); head.left = left; head.right = right; return head; &#125; private int findIndexInArray(int[] a, int rootData, int begin, int end) &#123; for (int i = begin; i &lt;= end; i++) &#123; if(a[i]==rootData) return i; &#125; return -1; &#125;&#125; 如何求二叉树中节点的最大距离节点的距离是指着两个节点之间边的个数，写一个程序求一棵二叉树中相距最远的两个节点之间的距离。一般而言，对二叉树的操作通过递归方法比较容易。求最大距离的主要思想如下：首先求左子树距根节点的最大距离，记录为leftMaxDistance；其次求右子树距根节点的最大距离，记录为rightMaxDistance。那么二叉树中节点的最大距离maxDistance = leftMaxDistance + rightMaxDistance;123456789101112131415161718192021222324252627282930public class BinaryTree &#123; private int maxLen = 0; private int max (int a, int b)&#123; return a &gt; b ? a:b; &#125; public void FindMaxDistance(Node root)&#123; if(root == null) return; if (root.left==null) root.leftMaxDistance = 0; if (root.right==null) root.rightMaxDistance = 0; if(root.left!=null) FindMaxDistance(root.left); if (root.right!=null) FindMaxDistance(root.right); //计算左子树中距离根节点最大距离 if(root.left!=null) root.leftMaxDistance = max(root.left.leftMaxDistance,root.left.rightMaxDistance)+1; //计算右子树距离根节点最大的距离 if(root.right!=null) root.rightMaxDistance = max(root.right.leftMaxDistance,root.right.rightMaxDistance); //获取二叉树所有节点的最大距离 if(root.leftMaxDistance+root.rightMaxDistance&gt;maxLen)&#123; maxLen = root.leftMaxDistance + root.rightMaxDistance; &#125; &#125;&#125; 平衡二叉树平衡二叉树（Balanced Binary Tree）是二叉查找树的一个进化体，也是第一个引入平衡概念的二叉树。1962年，G.M. Adelson-Velsky 和 E.M. Landis发明了这棵树，所以它又叫AVL树。平衡二叉树要求对于每一个节点来说，它的左右子树的高度之差不能超过1，如果插入或者删除一个节点使得高度之差大于1，就要进行节点之间的旋转，将二叉树重新维持在一个平衡状态。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。 旋转对于一个平衡的节点，由于任意节点最多有两个儿子，因此高度不平衡时，此节点的两颗子树的高度差2.容易看出，这种不平衡出现在下面四种情况： 1、6节点的左子树3节点高度比右子树7节点大2，左子树3节点的左子树1节点高度大于右子树4节点，这种情况成为左左。 2、6节点的左子树2节点高度比右子树7节点大2，左子树2节点的左子树1节点高度小于右子树4节点，这种情况成为左右。 3、2节点的左子树1节点高度比右子树5节点小2，右子树5节点的左子树3节点高度大于右子树6节点，这种情况成为右左。 4、2节点的左子树1节点高度比右子树4节点小2，右子树4节点的左子树3节点高度小于右子树6节点，这种情况成为右右。 从图2中可以可以看出，1和4两种情况是对称的，这两种情况的旋转算法是一致的，只需要经过一次旋转就可以达到目标，我们称之为单旋转。2和3两种情况也是对称的，这两种情况的旋转算法也是一致的，需要进行两次旋转，我们称之为双旋转。 ###：单旋转 单旋转是针对于左左和右右这两种情况的解决方案，这两种情况是对称的，只要解决了左左这种情况，右右就很好办了。图3是左左情况的解决方案，节点k2不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的左子树X子树，所以属于左左情况。 为使树恢复平衡，我们把k2变成这棵树的根节点，因为k2大于k1，把k2置于k1的右子树上，而原本在k1右子树的Y大于k1，小于k2，就把Y置于k2的左子树上，这样既满足了二叉查找树的性质，又满足了平衡二叉树的性质。 这样的操作只需要一部分指针改变，结果我们得到另外一颗二叉查找树，它是一棵AVL树，因为X向上一移动了一层，Y还停留在原来的层面上，Z向下移动了一层。整棵树的新高度和之前没有在左子树上插入的高度相同，插入操作使得X高度长高了。因此，由于这颗子树高度没有变化，所以通往根节点的路径就不需要继续旋转了。 双旋转对于左右和右左这两种情况，单旋转不能使它达到一个平衡状态，要经过两次旋转。双旋转是针对于这两种情况的解决方案，同样的，这样两种情况也是对称的，只要解决了左右这种情况，右左就很好办了。图4是左右情况的解决方案，节点k3不满足平衡特性，因为它的左子树k1比右子树Z深2层，而且k1子树中，更深的一层的是k1的右子树k2子树，所以属于左右情况。为使树恢复平衡，我们需要进行两步，第一步，把k1作为根，进行一次右右旋转，旋转之后就变成了左左情况，所以第二步再进行一次左左旋转，最后得到了一棵以k2为根的平衡二叉树树。 插入插入的方法和二叉查找树基本一样，区别是，插入完成后需要从插入的节点开始维护一个到根节点的路径，每经过一个节点都要维持树的平衡。维持树的平衡要根据高度差的特点选择不同的旋转算法。 查找和二叉查找树相比，查找方法没有变法，不过根据存储的特性，AVL树能维持在一个O(logN)的稳定的时间，而二叉查找树则相当不稳定。 删除删除的方法也和二叉查找树的一致，区别是，删除完成后，需要从删除节点的父亲开始向上维护树的平衡一直到根节点。 效率此数据结构插入、查找和删除的时间复杂度均为O(logN)，但是插入和删除需要额外的旋转算法需要的时间，有时旋转过多也会影响效率。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592package com.utils; import java.util.Iterator; import java.util.NoSuchElementException; /** * 平衡二叉树 * 定义:首先它是一种特殊的二叉排序树，其次它的左子树和右子树都是平衡二叉树， * 且左子树和右子树的深度之差不超过1 * 平衡因子:可以定义为左子树的深度减去右子树的深度 * * 平衡二叉树是对二叉排序树的优化，防止二叉排序树在最坏情况下平均查找时间为n， * 二叉排序树在此时形如一个单链表 * 平衡二叉树查找元素的次数不超过树的深度，时间复杂度为logN */ public class AVLTree&lt;E&gt; &#123; /** * 根节点 */ private Entry&lt;E&gt; root = null; /** * 树中元素个数 */ private int size = 0; public AVLTree()&#123; &#125; public int size()&#123; return size; &#125; /** * @param p 最小旋转子树的根节点 * 向左旋转之后p移到p的左子树处，p的右子树B变为此最小子树根节点， * B的左子树变为p的右子树 * 比如： A(-2) B(1) * \ 左旋转 / \ * B(0) ----&gt; A(0) \ * / \ \ \ * BL(0) BR(0) BL(0) BR(0) * 旋转之后树的深度之差不超过1 */ private void rotateLeft(Entry&lt;E&gt; p) &#123; System.out.println("绕"+p.element+"左旋"); if(p!=null)&#123; Entry&lt;E&gt; r = p.right; p.right = r.left; //把p右子树的左节点嫁接到p的右节点，如上图，把BL作为A的右子节点 if (r.left != null) //如果B的左节点BL不为空，把BL的父节点设为A r.left.parent = p; r.parent = p.parent; //A的父节点设为B的父节点 if (p.parent == null) //如果p是根节点 root = r; //r变为父节点，即B为父节点 else if (p.parent.left == p) //如果p是左子节点 p.parent.left = r; //p的父节点的左子树为r else //如果p是右子节点 p.parent.right = r; //p的父节点的右子树为r r.left = p; //p变为r的左子树，即A为B的左子树 p.parent = r; //同时更改p的父节点为r，即A的父节点为B &#125; &#125; /** * @param p 最小旋转子树的根节点 * 向右旋转之后，p移到p的右子节点处，p的左子树B变为最小旋转子树的根节点 * B的右子节点变为p的左节点、 * 例如: A(2) B(-1) * / 右旋转 / \ * B(0) ------&gt; / A(0) * / \ / / * BL(0) BR(0) BL(0) BR(0) */ private void rotateRight(Entry&lt;E&gt; p)&#123; System.out.println("绕"+p.element+"右旋"); if(p!=null)&#123; Entry&lt;E&gt; l = p.left; p.left = l.right; //把B的右节点BR作为A的左节点 if (l.right != null) //如果BR不为null，设置BR的父节点为A l.right.parent = p; l.parent = p.parent; //A的父节点赋给B的父节点 if (p.parent == null) //如果p是根节点 root = l; //B为根节点 else if (p.parent.right == p) //如果A是其父节点的左子节点 p.parent.right = l; //B为A的父节点的左子树 else //如果A是其父节点的右子节点 p.parent.left = l; //B为A的父节点的右子树 l.right = p; //A为B的右子树 p.parent = l; //设置A的父节点为B &#125; &#125; /** * 平衡而二叉树的插入操作 * 基本原理为： * 1.首先如同二叉排序树一般，找到其要插入的节点的位置，并把元素插入其中； * 2.自下向上进行回溯，回溯做两个事情： * (1)其一是修改祖先节点的平衡因子，当插入 一个节点时只有根节点到插入节点 * 的路径中的节点的平衡因子会被改变，而且改变的原则是当插入节点在某节点(称为A) * 的左子树 中时，A的平衡因子(称为BF)为BF+1,当插入节点在A的右子树中时A的BF-1， * 而判断插入节点在左子树中还是右子树中只要简单的比较它与A的大小 * (2)在改变祖先节点的平衡因子的同时，找到最近一个平衡因子大于2或小于-2的节点， * 从这个节点开始调整最小不平衡树进行旋转调整，关于如何调整见下文。 * 由于调整后，最小不平衡子树的高度与插入节点前的高度相同，故不需继续要调整祖先节点。 * 这里还有一个特殊情况，如果调整BF时，发现某个节点的BF变为0了，则停止向上继续调整， * 因为这表明此节点中高度小的子树增加了新节点，高度不变，那么祖先节点的BF自然不变。 * * */ public boolean add(E element)&#123; Entry&lt;E&gt; t = root; if(t == null)&#123; root = new Entry&lt;E&gt;(element,null); size = 1; return true; &#125; int cmp; Entry&lt;E&gt; parent; //保存t的父节点 Comparable&lt;? super E&gt; e = (Comparable&lt;? super E&gt;) element; //从根节点向下搜索，找到插入位置 do &#123; parent = t; cmp = e.compareTo(t.element); if(cmp &lt; 0)&#123; t = t.left; &#125;else if(cmp &gt; 0)&#123; t = t.right; &#125;else&#123; return false; &#125; &#125; while (t!=null); Entry&lt;E&gt; child = new Entry(element,parent); if(cmp &lt; 0)&#123; parent.left = child; &#125;else&#123; parent.right = child; &#125; //自下向上回溯，查找最近不平衡节点 while(parent!=null)&#123; cmp = e.compareTo(parent.element); if(cmp &lt; 0)&#123; //插入节点在parent的左子树中 parent.balance++; &#125;else&#123; //插入节点在parent的右子树中 parent.balance--; &#125; if(parent.balance == 0)&#123; //此节点的balance为0，不再向上调整BF值，且不需要旋转 break; &#125; if(Math.abs(parent.balance) == 2)&#123; //找到最小不平衡子树根节点 fixAfterInsertion(parent); break; //不用继续向上回溯 &#125; parent = parent.parent; &#125; size ++; return true; &#125; /** * 调整的方法： * 1.当最小不平衡子树的根(以下简称R)为2时，即左子树高于右子树： * 如果R的左子树的根节点的BF为1时，做右旋； * 如果R的左子树的根节点的BF为-1时，先左旋然后再右旋 * * 2.R为-2时，即右子树高于左子树： * 如果R的右子树的根节点的BF为1时，先右旋后左旋 * 如果R的右子树的根节点的BF为-1时，做左旋 * * 至于调整之后，各节点的BF变化见代码 */ private void fixAfterInsertion(Entry&lt;E&gt; p)&#123; if(p.balance == 2)&#123; leftBalance(p); &#125; if(p.balance == -2)&#123; rightBalance(p); &#125; &#125; /** * 做左平衡处理 * 平衡因子的调整如图： * t rd * / \ / \ * l tr 左旋后右旋 l t * / \ -------&gt; / \ / \ * ll rd ll rdl rdr tr * / \ * rdl rdr * * 情况2(rd的BF为0) * * * t rd * / \ / \ * l tr 左旋后右旋 l t * / \ -------&gt; / \ \ * ll rd ll rdl tr * / * rdl * * 情况1(rd的BF为1) * * * t rd * / \ / \ * l tr 左旋后右旋 l t * / \ -------&gt; / / \ * ll rd ll rdr tr * \ * rdr * * 情况3(rd的BF为-1) * * * t l * / 右旋处理 / \ * l ------&gt; ll t * / \ / * ll rd rd * 情况4(L等高) */ private boolean leftBalance(Entry&lt;E&gt; t)&#123; boolean heightLower = true; Entry&lt;E&gt; l = t.left; switch (l.balance) &#123; case LH: //左高，右旋调整,旋转后树的高度减小 t.balance = l.balance = EH; rotateRight(t); break; case RH: //右高，分情况调整 Entry&lt;E&gt; rd = l.right; switch (rd.balance) &#123; //调整各个节点的BF case LH: //情况1 t.balance = RH; l.balance = EH; break; case EH: //情况2 t.balance = l.balance = EH; break; case RH: //情况3 t.balance = EH; l.balance = LH; break; &#125; rd.balance = EH; rotateLeft(t.left); rotateRight(t); break; case EH: //特殊情况4,这种情况在添加时不可能出现，只在移除时可能出现，旋转之后整体树高不变 l.balance = RH; t.balance = LH; rotateRight(t); heightLower = false; break; &#125; return heightLower; &#125; /** * 做右平衡处理 * 平衡因子的调整如图： * t ld * / \ / \ * tl r 先右旋再左旋 t r * / \ --------&gt; / \ / \ * ld rr tl ldl ldr rr * / \ * ldl ldr * 情况2(ld的BF为0) * * t ld * / \ / \ * tl r 先右旋再左旋 t r * / \ --------&gt; / \ \ * ld rr tl ldl rr * / * ldl * 情况1(ld的BF为1) * * t ld * / \ / \ * tl r 先右旋再左旋 t r * / \ --------&gt; / / \ * ld rr tl ldr rr * \ * ldr * 情况3(ld的BF为-1) * * t r * \ 左旋 / \ * r -------&gt; t rr * / \ \ * ld rr ld * 情况4(r的BF为0) */ private boolean rightBalance(Entry&lt;E&gt; t)&#123; boolean heightLower = true; Entry&lt;E&gt; r = t.right; switch (r.balance) &#123; case LH: //左高，分情况调整 Entry&lt;E&gt; ld = r.left; switch (ld.balance) &#123; //调整各个节点的BF case LH: //情况1 t.balance = EH; r.balance = RH; break; case EH: //情况2 t.balance = r.balance = EH; break; case RH: //情况3 t.balance = LH; r.balance = EH; break; &#125; ld.balance = EH; rotateRight(t.right); rotateLeft(t); break; case RH: //右高，左旋调整 t.balance = r.balance = EH; rotateLeft(t); break; case EH: //特殊情况4 r.balance = LH; t.balance = RH; rotateLeft(t); heightLower = false; break; &#125; return heightLower; &#125; /** * 查找指定元素，如果找到返回其Entry对象，否则返回null */ private Entry&lt;E&gt; getEntry(Object element) &#123; Entry&lt;E&gt; tmp = root; Comparable&lt;? super E&gt; e = (Comparable&lt;? super E&gt;) element; int c; while (tmp != null) &#123; c = e.compareTo(tmp.element); if (c == 0) &#123; return tmp; &#125; else if (c &lt; 0) &#123; tmp = tmp.left; &#125; else &#123; tmp = tmp.right; &#125; &#125; return null; &#125; /** * 平衡二叉树的移除元素操作 * */ public boolean remove(Object o)&#123; Entry&lt;E&gt; e = getEntry(o); if(e!=null)&#123; deleteEntry(e); return true; &#125; return false; &#125; private void deleteEntry(Entry&lt;E&gt; p)&#123; size --; //如果p左右子树都不为空，找到其直接后继，替换p，之后p指向s，删除p其实是删除s //所有的删除左右子树不为空的节点都可以调整为删除左右子树有其一不为空，或都为空的情况。 if (p.left != null &amp;&amp; p.right != null) &#123; Entry&lt;E&gt; s = successor(p); p.element = s.element; p = s; &#125; Entry&lt;E&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123; //如果其左右子树有其一不为空 replacement.parent = p.parent; if (p.parent == null) //如果p为root节点 root = replacement; else if (p == p.parent.left) //如果p是左孩子 p.parent.left = replacement; else //如果p是右孩子 p.parent.right = replacement; p.left = p.right = p.parent = null; //p的指针清空 //这里更改了replacement的父节点，所以可以直接从它开始向上回溯 fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; // 如果全树只有一个节点 root = null; &#125; else &#123; //左右子树都为空 fixAfterDeletion(p); //这里从p开始回溯 if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125; &#125; /** * 返回以中序遍历方式遍历树时，t的直接后继 */ static &lt;E&gt; Entry&lt;E&gt; successor(Entry&lt;E&gt; t) &#123; if (t == null) return null; else if (t.right != null) &#123; //往右，然后向左直到尽头 Entry&lt;E&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123; //right为空，如果t是p的左子树，则p为t的直接后继 Entry&lt;E&gt; p = t.parent; Entry&lt;E&gt; ch = t; while (p != null &amp;&amp; ch == p.right) &#123; //如果t是p的右子树，则继续向上搜索其直接后继 ch = p; p = p.parent; &#125; return p; &#125; &#125; /** * 删除某节点p后的调整方法： * 1.从p开始向上回溯，修改祖先的BF值，这里只要调整从p的父节点到根节点的BF值， * 调整原则为，当p位于某祖先节点(简称A)的左子树中时，A的BF减1，当p位于A的 * 右子树中时A的BF加1。当某个祖先节点BF变为1或-1时停止回溯，这里与插入是相反的， * 因为原本这个节点是平衡的，删除它的子树的某个节点并不会改变它的高度 * * 2.检查每个节点的BF值，如果为2或-2需要进行旋转调整，调整方法如下文， * 如果调整之后这个最小子树的高度降低了，那么必须继续从这个最小子树的根节点(假设为B)继续 * 向上回溯，这里和插入不一样，因为B的父节点的平衡性因为其子树B的高度的改变而发生了改变， * 那么就可能需要调整，所以删除可能进行多次的调整。 * */ private void fixAfterDeletion(Entry&lt;E&gt; p)&#123; boolean heightLower = true; //看最小子树调整后，它的高度是否发生变化，如果减小，继续回溯 Entry&lt;E&gt; t = p.parent; Comparable&lt;? super E&gt; e = (Comparable&lt;? super E&gt;)p.element; int cmp; //自下向上回溯，查找不平衡的节点进行调整 while(t!=null &amp;&amp; heightLower)&#123; cmp = e.compareTo(t.element); /** * 删除的节点是右子树，等于的话，必然是删除的某个节点的左右子树不为空的情况 * 例如： 10 * / \ * 5 15 * / \ * 3 6 * 这里删除5，是把6的值赋给5，然后删除6，这里6是p，p的父节点的值也是6。 * 而这也是右子树的一种 */ if(cmp &gt;= 0 )&#123; t.balance ++; &#125;else&#123; t.balance --; &#125; if(Math.abs(t.balance) == 1)&#123; //父节点经过调整平衡因子后，如果为1或-1，说明调整之前是0，停止回溯。 break; &#125; Entry&lt;E&gt; r = t; //这里的调整跟插入一样 if(t.balance == 2)&#123; heightLower = leftBalance(r); &#125;else if(t.balance==-2)&#123; heightLower = rightBalance(r); &#125; t = t.parent; &#125; &#125; private static final int LH = 1; //左高 private static final int EH = 0; //等高 private static final int RH = -1; //右高 /** * 树节点，为方便起见不写get，Set方法 */ static class Entry&lt;E&gt;&#123; E element; Entry&lt;E&gt; parent; Entry&lt;E&gt; left; Entry&lt;E&gt; right; int balance = EH; //平衡因子，只能为1或0或-1 public Entry(E element,Entry&lt;E&gt; parent)&#123; this.element = element; this.parent = parent; &#125; public Entry()&#123;&#125; @Override public String toString() &#123; return element+" BF="+balance; &#125; &#125; //返回中序遍历此树的迭代器,返回的是一个有序列表 private class BinarySortIterator implements Iterator&lt;E&gt;&#123; Entry&lt;E&gt; next; Entry&lt;E&gt; lastReturned; public BinarySortIterator()&#123; Entry&lt;E&gt; s = root; if(s !=null)&#123; while(s.left != null)&#123; //找到中序遍历的第一个元素 s = s.left; &#125; &#125; next = s; //赋给next &#125; @Override public boolean hasNext() &#123; return next!=null; &#125; @Override public E next() &#123; Entry&lt;E&gt; e = next; if (e == null) throw new NoSuchElementException(); next = successor(e); lastReturned = e; return e.element; &#125; @Override public void remove() &#123; if (lastReturned == null) throw new IllegalStateException(); // deleted entries are replaced by their successors if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; deleteEntry(lastReturned); lastReturned = null; &#125; &#125; public Iterator&lt;E&gt; itrator()&#123; return new BinarySortIterator(); &#125; private int treeHeight(Entry&lt;E&gt; p)&#123; if(p == null)&#123; return -1; &#125; return 1 + Math.max(treeHeight(p.left), treeHeight(p.right)); &#125; //测试，你也可以任意测试 public static void main(String[] args) &#123; AVLTree&lt;Integer&gt; tree = new AVLTree&lt;Integer&gt;(); System.out.println("------添加------"); tree.add(50); System.out.print(50+" "); tree.add(66); System.out.print(66+" "); for(int i=0;i&lt;10;i++)&#123; int ran = (int)(Math.random() * 100); System.out.print(ran+" "); tree.add(ran); &#125; System.out.println("------删除------"); tree.remove(50); tree.remove(66); System.out.println(); Iterator&lt;Integer&gt; it = tree.itrator(); while(it.hasNext())&#123; System.out.print(it.next()+" "); &#125; &#125; &#125; B-树是一种多路搜索树（并不是二叉的）： 1.定义任意非叶子结点最多只有M个儿子；且M&gt;2； 2.根结点的儿子数为[2, M]； 3.除根结点以外的非叶子结点的儿子数为[M/2, M]； 4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字） 5.非叶子结点的关键字个数=指向儿子的指针个数-1； 6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]； 7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； 8.所有叶子结点位于同一层； 如：（M=3） B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点。 B-树的特性： 1.关键字集合分布在整颗树中； 2.任何一个关键字出现且只出现在一个结点中； 3.搜索有可能在非叶子结点结束； 4.其搜索性能等价于在关键字全集内做一次二分查找； 5.自动层次控制； 由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为： 其中，M为设定的非叶子结点最多子树个数，N为关键字总数； 所以B-树的性能总是等价于二分查找（与M值无关），也就没有B树平衡的问题； 由于M/2的限制，在插入结点时，如果结点已满，需要将结点分裂为两个各占M/2的结点；删除结点时，需将两个不足M/2的兄弟结点合并； B+树B+树是B-树的变体，也是一种多路搜索树： 1.其定义基本与B-树同，除了： 2.非叶子结点的子树指针与关键字个数相同； 3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）； 5.为所有叶子结点增加一个链指针； 6.所有关键字都在叶子结点出现； 如：（M=3） B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在 非叶子结点命中），其性能也等价于在关键字全集做一次二分查找； B+的特性： 1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的； 2.不可能在非叶子结点命中； 3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层； 4.更适合文件索引系统； B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针； B 树定义了非叶子结点关键字个数至少为(2/3) M，即块的最低使用率为2/3（代替B+树的1/2）；B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；B 树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；所以，B树分配新结点的概率比B+树要低，空间使用率更高； 小结 B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点； B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点； 所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中； B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中； B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符串相关算法]]></title>
      <url>%2F2017%2F03%2F01%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[1.字符串翻转//实现字符串的反转 ，例如how are you 变 you are how// 以及单词的反转，单词的反转即是先全部反转，然后在把每个单词反转123456789101112131415161718192021222324252627282930313233343536public class StringReverse &#123; public static void main(String[] args)&#123; String str = "how are you";// StringBuffer sb =new StringBuffer();// sb.append(str);// String str2 = sb.reverse().toString();// System.out.println(str2); System.out.println(swapWords(str)); &#125; public static void swap(char[] cArr,int front,int end)&#123; while(front &lt; end)&#123; char tmp = cArr[end]; cArr[end] = cArr[front]; cArr[front] = tmp; front++; end--; &#125; &#125; public static String swapWords(String s) &#123; char[] cArr = s.toCharArray(); //对整个字符串进行字符翻转 swap(cArr, 0, cArr.length - 1); int begin = 0; //对每个单词进行字符串翻转操作 for (int i = 1; i &lt; cArr.length; i++)&#123; if (cArr[i]==' ')&#123; swap(cArr,begin,i-1); begin = i+1; &#125; &#125; swap(cArr,begin,cArr.length-1); return new String(cArr); &#125;&#125; 2.统计字符串中单词个数/统计一个字符串中出现单词的个数单词的前一个字符为空才代表出现的是单词。只需要用一个标志位记录前一个是否是空格即可 /123456789101112131415161718192021public class StringWordCount &#123; public static void main(String[] args)&#123; String s = " hello wolrd"; System.out.println(wordCount(s)); &#125; public static int wordCount(String s)&#123; int count = 0; int word=0;//word为0表示前一个字符是空格，1表示非空格 for (int i = 0; i &lt; s.length(); i++) &#123; if(s.charAt(i)==' ')&#123; word = 0; &#125;else if (word==0)&#123; //只有前一位是空格意味着是一个单词，如果去掉word==0条件就变成统计字符了 word = 1; count++; &#125; &#125; return count; &#125;&#125; 3.字符串去重/ 删除字符串中重复的字符如good应该变成god 此问题也有两种办法第一蛮力遍历把重复的先变为’\0’，再去掉 方法二空间换时间因为字符个数也是256，也可以根据记录个数去重(另提供更节省空间的法三) /1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class StringRemoveDuplicate &#123; public static void main(String[] args)&#123; String s = "ggooddgg"; System.out.println(removeDuplicate1(s)); System.out.println(removeDuplicate2(s)); &#125; //方法三在方法二的基础上知道我们需要256大小的空间，每1bit记录一个字符是否存在， //更好的方案是我们申请一个大小为8的int型数组，每个int 32位，32x8=256 public static String removeDuplicate3(String s)&#123; char[] c = s.toCharArray(); int len = c.length; int []flags = new int[8]; for (int i = 0; i &lt; 8; i++) &#123; flags[i] = 0; &#125; for (int i = 0; i &lt; len; i++) &#123; int index = (int)c[i]/32; int shift = (int)c[i]%32; if((flags[index]&amp;(1&lt;&lt;shift))!=0)&#123; c[i] = '\0'; &#125; flags[index] |= (1&lt;&lt;shift); &#125; int l=0; for (int i = 0; i &lt; len; i++) &#123; if(c[i]!=0)&#123; c[l++] = c[i]; &#125; &#125; return new String(c,0,1); &#125; //方法二空间换时间 public static String removeDuplicate2(String s1)&#123; char[] c = s1.toCharArray(); StringBuffer sb = new StringBuffer(); int[] cCout = new int[256]; //初始化都为0，如果后面的遇到为1那么说明前面已经存在 for (int i = 0; i &lt; 256; i++) &#123; cCout[i] = 0; &#125; for (int i = 0; i &lt; c.length; i++) &#123; if (cCout[c[i]] == 1)&#123; continue; &#125; sb.append(c[i]); cCout[c[i]] = 1; &#125; return sb.toString(); &#125; //方法一蛮力法 public static String removeDuplicate1(String s1)&#123; char[] c = s1.toCharArray(); //重复的数字置换为'\0' for (int i = 0; i &lt; c.length; i++) &#123; for (int j = i+1; j &lt; c.length; j++) &#123; if (c[i]==c[j])&#123; c[j]= '\0'; &#125; &#125; &#125; //去掉‘\0’ int k=0; for (int i = 0; i &lt; c.length; i++) &#123; if (c[i]!='\0')&#123; c[k++] = c[i]; &#125; &#125; return new String(c,0,k); &#125;&#125; 4.字符的组合/求例如输入字符串abc，那么a、b、c三个字符共有多少种组合（假设字符串中所有字符都不重复）a、b、c、ab、ac、bc、abc此题我们就不考虑暴力的解法了//方法一：递归//方法二：用二进制数来表示字符的出现与不出现如011代表bc,111代表abc,100代表a /123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class StringCombine &#123; public static void main(String[] args)&#123; String s = "abc"; char[] c = s.toCharArray(); StringBuffer sb = new StringBuffer(""); int len = c.length; for (int i = 1; i &lt;= len; i++) &#123; combineRecursiveImpl(c,0,i,sb); &#125; System.out.println("-------------------------------"); combine(c); &#125; private static void combine(char[] c) &#123; if (c==null) return; int len = c.length; boolean used[] = new boolean[len]; char cache[] = new char[len]; int result = len; while (true)&#123; int index = 0; while(used[index])&#123; used[index] = false; ++result; if(++index==len) return; &#125; used[index] = true; cache[--result] = c[index]; System.out.print(new String(cache).substring(result) + " " ); &#125; &#125; private static void combineRecursiveImpl(char[] c, int begin, int len, StringBuffer sb) &#123; if(len==0)&#123; System.out.println(sb+" "); return; &#125; if (begin==c.length)&#123; return; &#125; sb.append(c[begin]); combineRecursiveImpl(c,begin+1,len-1,sb);//取该字符的情况 sb.deleteCharAt(sb.length()-1); combineRecursiveImpl(c,begin+1,len,sb);//不取该字符的情况 &#125;&#125; 5.字符串大小比较/ 判断两个字符串是否有相同的字符组成 如aaaabbc与abcbaaa就是。组成字符及个数都相同 解决此问题有两种方法法一就是将他们排序，然后比较两个字符串是否相等 方法二：时间换空间也就是桶记录他们每个字符的个数以及是否存在来确定 /1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class StringCompare &#123; public static void main(String[] args)&#123; String s1 = "aaaabc"; String s2 = "abcaaa"; compareMethod1(s1,s2); compareMethod2(s1,s2); &#125; public static void compareMethod2(String s1, String s2)&#123; byte[] b1 = s1.getBytes(); byte[] b2 = s2.getBytes(); int cCout[] = new int[256];//因为字符数一共256个，所以足够了 for (int i = 0; i &lt; 256; i++) &#123; cCout[i] = 0; &#125; for (int i = 0; i &lt; b1.length; i++) &#123; cCout[b1[i] - '0']++; &#125; for (int i = 0; i &lt; b2.length; i++) &#123; cCout[b1[i] - '0']--; &#125; for (int i = 0; i &lt; 256; i++) &#123; if (cCout[i]!=0)&#123; System.out.println("not euqal 2"); return; &#125; &#125; System.out.println("euqal 2"); &#125; public static void compareMethod1(String a,String b)&#123; byte[] b1 = a.getBytes(); byte[] b2 = a.getBytes(); Arrays.sort(b1); Arrays.sort(b2); a = new String(b1); b = new String(b2); if(a.equals(b))&#123; System.out.println("equal!"); &#125;else &#123; System.out.println("not equal!"); &#125; &#125;&#125; 6.字符的全排列针对1,2,2,3,4,5这六个数字，写成一个函数，打印出所有不同的排列，例如512234,215432,要求“4”不能在第三位，“3”与“5”不能相连。 另给出 1,2，3组成全排列无限制方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import java.util.HashSet;import java.util.Iterator;import java.util.Set;/** * Created by FangHeart on 2017/3/1. *//* 针对1,2,2,3,4,5这六个数字，写成一个函数，打印出所有不同的排列，例如512234,215432, 要求“4”不能在第三位，“3”与“5”不能相连。 *//** 另给出 1,2，3组成全排列无限制方法* */public class StringCobinations &#123; private int[] numbers = new int[]&#123;1,2,2,3,4,5&#125;; private int n = numbers.length; //用来标记图中的节点是否被便利过 private boolean[] visted = new boolean[n]; //图中的二维数组表示 private int [][]graph = new int[n][n]; //数字的组合 private String combination = ""; public Set &lt;String&gt; getAllCombinations()&#123; //构造图 buildGraph(); //用来存放所有组合 Set&lt;String&gt; set = new HashSet&lt;String&gt;(); //分别从不同的节点出发深度遍历图 for (int i = 0; i &lt; n; i++) &#123; this.depthFirstSearch(i,set); &#125; return set; &#125; private void buildGraph()&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i==j)&#123; graph[i][i] = 0; &#125;else &#123; graph[i][j] = 1; &#125; &#125; &#125; //确保在遍历时3与5是不可达的 graph[3][5]=0; graph[5][3]=0; &#125; //对树从节点start位置开始进行深度遍历 private void depthFirstSearch(int start,Set&lt;String&gt; set)&#123; visted[start] = true; combination = combination + numbers[start]; if (combination.length()==n)&#123; //4不能出现在第三个位置 if (combination.indexOf("4")!=2) set.add(combination); &#125; for (int i = 0; i &lt; n; i++) &#123; if (graph[start][i]==1 &amp;&amp; visted[i]==false) depthFirstSearch(i,set); &#125; combination = combination.substring(0,combination.length()-1); visted[start]=false; &#125; public static void main(String[] args)&#123; StringCobinations stringCobinations = new StringCobinations(); Set&lt;String&gt; set = stringCobinations.getAllCombinations(); Iterator&lt;String&gt; it = set.iterator(); while(it.hasNext())&#123; String string = (String)it.next(); System.out.println(string); &#125; int a[] = new int[]&#123;1,2,3&#125;; perm(a,0,a.length-1); &#125; //算法思路n各元素全排列= （n-1个元素的全排列）+另一个元素为前缀 //出口：如果只有一个元素全排列，说明已经完成 public static void perm(int arr[], int begin,int end) &#123; if(end==begin)&#123; //一到递归的出口就输出数组，此数组为全排列 for(int i=0;i&lt;=end;i++)&#123; System.out.print(arr[i]+" "); &#125; System.out.println(); return; &#125; else&#123; for(int j=begin;j&lt;=end;j++)&#123; swap(arr,begin,j); //for循环将begin~end中的每个数放到begin位置中去 perm(arr,begin+1,end); //假设begin位置确定，那么对begin+1~end中的数继续递归 swap(arr,begin,j); //换过去后再还原 &#125; &#125; &#125; private static void swap(int[] a,int s,int i) &#123; int t=a[s]; a[s]=a[i]; a[i]=t; &#125;&#125; 7.字符串的全排列/* 题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述:输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 / */123456789101112131415161718192021222324252627282930public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); HashSet&lt;String&gt; hashSet = new HashSet&lt;String&gt;(); if (str!=null &amp;&amp; str.toCharArray().length&gt;0)&#123; PermutationHelper(str.toCharArray(),0,hashSet); &#125; arrayList.addAll(hashSet); Collections.sort(arrayList); return arrayList;&#125;public void PermutationHelper(char[] chars, int i, HashSet&lt;String&gt; hashSet) &#123; if (i==chars.length-1)&#123; hashSet.add(new String(chars)); &#125;else &#123; for (int j = i; j &lt; chars.length; j++) &#123; swap(chars,i,j); PermutationHelper(chars,i+1,hashSet); swap(chars,i,j); &#125; &#125;&#125;public void swap(char[] chars, int i, int j) &#123; if (i != j) &#123; char temp = chars[i]; chars[i] = chars[j]; chars[j] = temp; &#125;&#125; 8.字符串是否含有子字符串(KMP算法)12345678910111213141516171819202122232425262728293031323334353637383940public static boolean KMP(String str,String subStr)&#123; String newStr = "x" + str; String newSubStr = "x" + subStr; int i = 1; int j = 1; int []K = calK(subStr); while (i&lt;=str.length()&amp;&amp;j&lt;=subStr.length())&#123; if (j==0||newStr.charAt(i)==newSubStr.charAt(j))&#123; i++; j++; &#125;else &#123; j = K[j]; &#125; &#125; if (j&gt;subStr.length()) return true; else return false; &#125; public static int[] calK(String subString)&#123; String newSubStr = "x" + subString; int K[] = new int[newSubStr.length()]; int i = 1; K[1] = 0; int j = 0; while (i&lt;subString.length())&#123; if (j==0||newSubStr.charAt(i)==newSubStr.charAt(j))&#123; i++; j++; K[i] = j; &#125;else &#123; j = K[j]; &#125; &#125; return K; &#125; 9.动态规划解决最大公共子串/*这是一道标准的动态规划问题，求两个字符串的最大公共子串例如 String a = “abcde” String b = “abc” 那么最长公共子串为abc 可以建立一个二维数组p[i][j]代表到达字符串1的位置，字符串j位置时候的最大公共字符串 可以得到如下公式 | &quot;&quot; (String1char[i]!=String2char[j]) p[i][j]= | String1char[i]或者String2char[j] (i=0或者j=0) | p[i-1][j-1] + char (String1char[i]==String2char[j]) */12345678910111213141516171819202122232425262728293031323334353637383940414243public class MaxSubString &#123; @Test public void test()&#123; System.out.println(getSubString("abcdaasdjhjkasdaa","abcasfsadsdaa")); &#125; public String getSubString(String str1,String str2)&#123; int len1 = str1.length(); int len2 = str2.length(); int maxLen = 0; String lcs = ""; char char1,char2; String p[][] = new String[len1][len2]; for (int i = 0; i &lt; len1; i++) &#123; for (int j = 0; j &lt; len2; j++) &#123; char1 = str1.charAt(i); char2 = str2.charAt(j); if (char1!=char2) p[i][j] = ""; else &#123; if (i == 0) p[i][j] = String.valueOf(char1); else if (j == 0) p[i][j] = String.valueOf(char2); else p[i][j] = p[i - 1][j - 1] + String.valueOf(char1); if (p[i][j].length()&gt;maxLen)&#123; maxLen = p[i][j].length(); lcs = p[i][j]; &#125;else if (p[i][j].length()==maxLen)&#123; lcs = lcs +","+p[i][j]; &#125; &#125; &#125; &#125; return lcs; &#125;&#125; 10.动态规划解决最长回文长度/*题目：所谓回文字符串，就是一个字符串，从左到右读和从右到左读是完全一样的，比如：”aba”，”abba”.对于一个字符串，可以通过删除某些字符二编程回文字符串，如：“cabebaf”,删除“c,e,f”后剩下子串“abba”就是回文字符串。要求：给定任意一个字符串，字符串的最大长度1000，计算出最长的回文字符串长度。输入：字符串输出：最大的回文字符串的长度。 分析：回文即是从前到中和从后到中完全一致那么如果第一个字符和最后一个字符相等，那么最长回文串长度就是中间的最长回文串+2如果第一个字符和最后一个字符不相等，那么最长子串的长度就是去掉头字符的最长子字符串和去掉尾结点的最长子字符串长度既有方程 |p[i+1][j-1] + 2;(char[i]==char[j] i&lt;j)p[i][j]= |p[i+1][j-1] + 1;(char[i]==char[j] i==j中间单个字符) |max(p[i+1][j],p[i][j-1]) 为了方便写循环 p[i][j]代表j-i之间最大回文的长度， */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class MaxlengthHuiWen &#123; @Test public void test()&#123; getLen("cabebaf"); getLen2("cabebaf"); &#125; public void getLen2(String s)&#123; char c[] = (" "+s + " ").toCharArray(); int n = c.length; int p[][] = new int[n][n]; int maxLen = 0; for (int i = n-2; i &gt;= 1; i--) &#123; for (int j = 1; j &lt;= i; j++) &#123; if (c[i]==c[j]&amp;&amp;i&gt;j)&#123; p[i][j]= p[i+1][j-1] + 2; &#125;else if (c[i]==c[j]&amp;&amp;i==j)&#123; p[i][j] = p[i+1][j-1] + 1; &#125;else if(p[i+1][j]&gt;=p[i][j-1])&#123; p[i][j] = p[i+1][j]; &#125;else p[i][j] = p[i][j-1]; if (p[i][j] &gt; maxLen) maxLen = p[i][j]; &#125; &#125; System.out.println(maxLen); &#125; public void getLen(String s)&#123; char c[] = (" "+s + " ").toCharArray(); int n = c.length; int p[][] = new int[n][n]; int maxLen = 0; for (int i = 1; i &lt; n-1; i++) &#123; for (int j = n-2; j &gt;=i ; j--) &#123; if (c[i]==c[j]&amp;&amp;i&lt;j)&#123; p[i][j]= p[i-1][j+1] + 2; &#125;else if (c[i]==c[j]&amp;&amp;i==j)&#123; p[i][j] = p[i-1][j+1] + 1; &#125;else if(p[i-1][j]&gt;=p[i][j+1])&#123; p[i][j] = p[i-1][j]; &#125;else p[i][j] = p[i][j+1]; if (p[i][j] &gt; maxLen) maxLen = p[i][j]; &#125; &#125; System.out.println(maxLen); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式]]></title>
      <url>%2F2017%2F02%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F01%E3%80%81%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[设计模式原则1. 封装变化 2.多用组合少用继承（01）【使用组合建立系统具有很大的弹性，不禁可以讲算法族封装成类，更可以“在运行时动态的改变行为”，只要组合的行为对象符合正确的接口标准即可】 3.针对接口编程，不针对实现编程（01）【一种理解即使真实的针对interface的编程，也可理解成利用多态针对超类进行编程，根据具体的情况执行真正的行为，不会绑死在超类上，针对超类进行编程可以更明确的说成变量的声明类型应该是超类型，通常是一个抽象类或者是一个接口，如此只要是具体实现此超类型的类所产生的对象度可以指定给这个变量，也意味着，声明类时不用理会以后执行时的真正对象类型。】 4.为了交互对象之间松耦合设计而努力，即两者可以交互，但不必清楚彼此的细节，并且当改变两种交互对象，或者在其他地方可以复用，对另一种对象无影响。（02） 5.类应该对扩展开放，对修改关闭。（03） 6.要依赖抽象，不要依赖于具体类。（04）【代码里减少对具体类的依赖是个好事，还有一个专有名词叫做依赖倒置原则，其中有几个关键点（并非都要遵从）（1）变量不可以持有具体类的引用（2）不要让类派生自己的具体类（3）不要覆盖基类中已经实现的方法】 7.最少知识原则，只和紧密相关的对象交互。（07） 8.好莱坞原则，低层组件尽量不调用高层组件【父类】，让高层组件来调用低层。（08） 01、策略模式（Strategy）[对象行为型]策略模式定义了算法族，分别封装起来，让他们各个之间可以相互替换，此模式让算法的变化独立于使用算法的客户之外。 02、观察者模式（Observer）观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态，他的所有依赖者都会受到通知并自动更新。即一个subject对应多个observer.观察者依赖于主题，只要主题状态一有变化，观察者就会被通知，根据通知的风格，观察者可能因此新值而更新。 javaAPI中内置了观察者者模式，不仅可以发生变化时推送给观察者，还可以观察者自己像主题索取，在java.util中的Observer接口（是类需要继承）与Observable接口（是一个类）。 03、 装饰者模式（Decorator）装饰者模式动态的将责任附加到对象上，若要拓展功能，装饰者提供了比继承更有弹性的替代方案。【目标即使允许类容易扩展，在不修改现有代码的情况下，就可以搭配新的行为，这样设计更具有弹性可以应对改变，可以接受新的功能来应对改变的需求。注意装饰和被装饰者应该是同样的类型的，即拥有同样的超类。】 04、 工厂模式工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。 * 工厂方法用来出处理对象的创建，并将这样的行为封装在子类中，这样客户程序中关于超类的代码就和子类对象创建代码解耦了。 * 所有工厂模式都用来封装对象的创建。工厂方法模式（Factory Method Pattern）通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。 #### 抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不要明确指定具体类。 ####工厂方法与抽象工厂的区别 * 工厂方法运用的是类的继承，而抽象方法是对象的组合 * 工厂方法创建对象需要扩展一个类，并且覆盖他的工厂方法，通过子类来创建对象，客户只需要知道所使用的的抽象类型就可以，由子类来决定具体的类型，只负责将客户从具体类型中解耦。而抽象工厂是创建一个产品家族的抽象类型，这个类型的子类定义了产品被产生的方法。所以要使用这个工厂，必须实例化它。 * 总结：当需要创建产品家族或者想要制造相关产品集合起来时，就使用抽象工厂。当想将客户代码从实例化的具体类中解耦或者目前还不知道将来需要实例化哪些具体类时，就用工厂方法。 05、 单件模式（Singleton pattern）确保一个类只有一个实例，并提供一个全局访问点。原理即是构造函数私有化，如果想使用到实例对象，那么通过调用类的静态方法getInstance来实现。那么久可以向全局变量一样简单的访问，但是还有它的优点单件可以延迟实例化，并且具有一般类的方法和变量【用来管理共享资源如数据库的连接或者线程池】 代码示例 123456789101112131415161718// NOTE: This is not thread safe!public class Singleton &#123; private static Singleton uniqueInstance;//静态私有变量 // other useful instance variables here private Singleton() &#123;&#125;//私有构造函数 public static Singleton getInstance() &#123; if (uniqueInstance == null) &#123; uniqueInstance = new Singleton();//通过类内方法调用私有构造函数产生实例 &#125; return uniqueInstance; &#125; // other useful methods here&#125; 但上面的代码如果是多线程的可能还存在一些问题，因为多线程可能是不安全的，因为我们需要保证在多线程模式下可以正常工作，不要产生多个uniqueInstance静态实例化对象。所以又有了如下几种考虑。 12345678910111213141516public class Singleton &#123; private static Singleton uniqueInstance;//静态私有变量 // other useful instance variables here private Singleton() &#123;&#125;//私有构造函数 public static synchronized Singleton getInstance() &#123;//方法加同步修饰 if (uniqueInstance == null) &#123; uniqueInstance = new Singleton();//通过类内方法调用私有构造函数产生实例 &#125; return uniqueInstance; &#125; // other useful methods here&#125; 上述这种写法每次调用都要需要同步这个方法，而实际我门只需要第一次执行的时候才需要此方法，那么性能就有点低了，如果不考虑性能，可以接受getInstance的额外负担，那么久可以使用synchronized同步。 如果你非常急切的需要创建单件实例，而又不想延迟实例化那么可以看下如下做法。 12345678910111213public class Singleton &#123; private static Singleton uniqueInstance = new Singleton();//直接创建静态私有变量单件实例 // other useful instance variables here private Singleton() &#123;&#125;//私有构造函数 public static Singleton getInstance() &#123; return uniqueInstance; &#125; // other useful methods here &#125; 利用如上方法，我们依赖JVM在加载这个类的时候马上创建此唯一单件实例，这样任何线程访问unniqueInstance静态变量之前，一定会创建此实例。 其实还有更高端的办法是运用双重检查加锁，原理是首先检查是否实例已经创建，如果尚未创建，才进行同步。只有第一次会同步，这也真是我们所期盼的。 1234567891011121314151617181920public class Singleton &#123; private volatile static Singleton uniqueInstance;//volatile关键词确保当uniqueInstance变量被初始化成实例时候，多个线程能正确的处理uniqueInstance。 // other useful instance variables here private Singleton() &#123;&#125;//私有构造函数 public static Singleton getInstance() &#123; if (uniqueInstance == null) &#123;//检查实例如果不存在就进入同步区块 synchronized（Singleton.class）&#123; if (uniqueInstance == null)&#123;//进入同步块后再检查一次 uniqueInstance = new Singleton();//只有第一次才彻底执行这里的代码 &#125; &#125; &#125; return uniqueInstance; &#125; // other useful methods here&#125; 06.命令模式（Comand）封装调用命令模式将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也可以支持撤销的操作。【命令模式可以将动作的请求者从动作的执行者对象中解耦；在被解耦的两者之间是通命令进行沟通的。命令对象封装了接收者和一个或一组动作；调用者通过调用命令对象的execute()发出请求，这会使接收者的动作被调用；调用者可以接受命令当做参数，甚至在运行时动态进行；命令可以支持撤销，做法是一个undo()来与excute相反执行；命令也可以用来实现日志事务系统】。 07-1.适配器模式（adaper-pattern）适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 07-2.外观模式(Facede-Pattern)外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。 适配器模式与外观模式都可以包装许多类，但他们的区别在于适配器的意图是改变接口符合客户的期望，而外观模式的意图是提供子系统的一个简化接口（不禁简化接口，也将客户从组件的子系统中解耦）。【当需要使用一个现有的类而其接口并部分符合你的需求时，就需要使用适配器；当需要简化并统一一个很大的接口或者一群复杂的借口时，使用外观；适配器改变接口以符合客户的期望；外观将客户从一个复杂的子系统中解耦；实现一个适配器的复杂程度视目标接口的大小与复杂度决定；实现一个外观需要将子系统组合进外观，然后将工作委托给子系统执行；适配器有两种形式对象适配器和类适配器，类适配器需要用到多重继承；适配器将一个对象包装起来以改变其接口，装饰者是将一个对象包装起来以增加新的行为和责任，外观将一群对象包装起来以简化其接口。】 08. 模板方法模式（templateMethod）模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。【模板方法模式为我们提供了一种代码复用的重要技巧；模板方法的抽象类可以定义具体的方法、抽象方法和钩子。抽象方法由子类来实现；钩子是一种方法，他在抽象类中不做任何事，或者做默认的事情，子类可以选择要不要去覆盖它；为了防止子类改变模板方法中的算法，可以把模板方法定义为final;好莱坞原则，应该讲决策权放在高层模块中，以便决定如何以及何时调用低层模块;策略模式和模板方法都是封装算法，但是一个用于组合，一个用于继承。工厂方法可以看做成模板方法的一个特殊版本。】 09.迭代器与组合模式（Iterator）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[正则表达式pattern、match、math、random、System、Date、Calendar等]]></title>
      <url>%2F2017%2F01%2F14%2Fjava%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8012%E3%80%81%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fpattern%E3%80%81match%E3%80%81math%E3%80%81random%E3%80%81System%E3%80%81Date%E3%80%81Calendar%E7%AD%89%2F</url>
      <content type="text"><![CDATA[01_常见对象(正则表达式的概述和简单使用) A:正则表达式 是指一个用来描述或者匹配一系列符合某个语法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。 作用:比如注册邮箱,邮箱有用户名和密码,一般会对其限制长度,这个限制长度的事情就是正则表达式做的 B:案例演示 需求：校验qq号码. 1:要求必须是5-15位数字 2:0不能开头 3:必须都是数字 a:非正则表达式实现 b:正则表达式实现 02_常见对象(字符类演示) A:字符类 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） [0-9] 0到9的字符都包括03_常见对象(预定义字符类演示) A:预定义字符类 . 任何字符。 \d 数字：[0-9] \w 单词字符：[a-zA-Z_0-9]04_常见对象(数量词) A:Greedy 数量词 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 05_常见对象(正则表达式的分割功能) A:正则表达式的分割功能 String类的功能：public String[] split(String regex) B:案例演示 正则表达式的分割功能 06_常见对象(把给定字符串中的数字排序) A:案例演示 需求：我有如下一个字符串:”91 27 46 38 50”，请写代码实现最终输出结果是：”27 38 46 50 91” 07_常见对象(正则表达式的替换功能) A:正则表达式的替换功能 String类的功能：public String replaceAll(String regex,String replacement) B:案例演示 正则表达式的替换功能 08_常见对象(正则表达式的分组功能) A:正则表达式的分组功能 捕获组可以通过从左到右计算其开括号来编号。例如，在表达式 ((A)(B(C))) 中，存在四个这样的组： 1 ((A)(B(C))) 2 (A 3 (B(C)) 4 (C) 组零始终代表整个表达式。 B:案例演示 a:切割 例如 高高兴兴 regex = &quot;(.)\\1(.)\\2&quot;; 括号内表示为组，\\1表示第一组再出现一次,若为1+代表出现一次或者多次 高兴高兴 regex = &quot;(..)\\1&quot;; 需求：请按照叠词切割： &quot;sdqqfgkkkhjppppkl&quot;; b:替换 需求：我我....我...我.要...要要...要学....学学..学.编..编编.编.程.程.程..程 将字符串还原成:“我要学编程”。 1. 去除点 s.repalceAll(&quot;\\.+&quot;,&quot;&quot;); 2. 多个字符替换成一个 s2.replaceAll(&quot;(.)\\1+&quot;,&quot;$1&quot;); 09_常见对象(Pattern和Matcher的概述) A:Pattern和Matcher的概述 B:模式和匹配器的典型调用顺序 通过JDK提供的API，查看Pattern类的说明 典型的调用顺序是 Pattern p = Pattern.compile(“a*b”); Matcher m = p.matcher(“aaaaab”); boolean b = m.matches(); 10_常见对象(正则表达式的获取功能) A:正则表达式的获取功能 Pattern和Matcher的结合使用 B:案例演示 需求：把一个字符串中的手机号码获取出来 String s = “我的手机是18988888888,我曾用过18987654321,还用过18812345678”; String regex = &quot;1[3578]\\d{9}&quot;; Pattern p = Pattern.compile(regex); Matcher m = p.matcher(s); while(m.find()) System.out.println(m.group()); 11_常见对象(Math类概述和方法使用) A:Math类概述 Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。 B:成员方法 public static int abs(int a) public static double ceil(double a) public static double floor(double a) public static int max(int a,int b) min自学 public static double pow(d ouble a,double b) public static double random() public static int round(float a) 参数为double的自学 public static double sqrt(double a) 12_常见对象(Random类的概述和方法使用) A:Random类的概述 此类用于产生随机数如果用相同的种子创建两个 Random 实例， 则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列。 B:构造方法 public Random() public Random(long seed) C:成员方法 public int nextInt() public int nextInt(int n)(重点掌握) 13_常见对象(System类的概述和方法使用) A:System类的概述 System 类包含一些有用的类字段和方法。它不能被实例化。 B:成员方法 public static void gc() public static void exit(int status) public static long currentTimeMillis() pubiic static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) C:案例演示 System类的成员方法使用 14_常见对象(BigInteger类的概述和方法使用) A:BigInteger的概述 可以让超过Integer范围内的数据进行运算 B:构造方法 public BigInteger(String val) C:成员方法 public BigInteger add(BigInteger val) public BigInteger subtract(BigInteger val) public BigInteger multiply(BigInteger val) public BigInteger divide(BigInteger val) public BigInteger[] divideAndRemainder(BigInteger val) 15_常见对象(BigDecimal类的概述和方法使用) A:BigDecimal的概述 由于在运算的时候，float类型和double很容易丢失精度，演示案例。 所以，为了能精确的表示、计算浮点数，Java提供了BigDecimal 不可变的、任意精度的有符号十进制数。 B:构造方法 public BigDecimal(String val) C:成员方法 public BigDecimal add(BigDecimal augend) public BigDecimal subtract(BigDecimal subtrahend) public BigDecimal multiply(BigDecimal multiplicand) public BigDecimal divide(BigDecimal divisor) D:案例演示 BigDecimal类的构造方法和成员方法使用 16_常见对象(Date类的概述和方法使用)(掌握) A:Date类的概述 类 Date 表示特定的瞬间，精确到毫秒。 B:构造方法 public Date() public Date(long date) C:成员方法 public long getTime() public void setTime(long time) 17_常见对象(SimpleDateFormat类实现日期和字符串的相互转换)(掌握) A:DateFormat类的概述 DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。是抽象类，所以使用其子类SimpleDateFormat B:SimpleDateFormat构造方法 public SimpleDateFormat() public SimpleDateFormat(String pattern) C:成员方法 public final String format(Date date) public Date parse(String source) 18_常见对象(你来到这个世界多少天案例)(掌握) A:案例演示 需求：算一下你来到这个世界多少天? 19_常见对象(Calendar类的概述和获取日期的方法)(掌握) A:Calendar类的概述 Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 B:成员方法 public static Calendar getInstance() public int get(int field) 20_常见对象(Calendar类的add()和set()方法)(掌握) A:成员方法 public void add(int field,int amount) public final void set(int year,int month,int date) B:案例演示 Calendar类的成员方法使用 21_常见对象(如何获取任意年份是平年还是闰年)(掌握) A:案例演示 需求：键盘录入任意一个年份，判断该年是闰年还是平年]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[YARN之MRAppMaster深入剖析—ContainerAllocator分析]]></title>
      <url>%2F2017%2F01%2F10%2FYARN%E4%B9%8BMRAppMaster%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E2%80%94ContainerAllocator%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[1. ContainerAllocator概述ContainerAllocator负责与ResourceManager通信，为作业申请资源。作业的每个任务资源需求可描述为四元组，分别表示作业优先级、期望资源所在的host，资源量（当前仅支持内存），container数目，比如： &lt;10, “node1”, “memory:1G”, 3&gt;//优先级是一个正整数，优先级值越小，优先级越高 &lt;10, “node2”, “memory:2G”, 10&gt; &lt;2, “*”, “memory:1G”, 20&gt; //*表示这样的资源可来自任意一个节点，即不考虑数据本地性 ContainerAllocator周期性通过心跳与ResourceManager通信，ResourceManager每次会返回已经分配的container列表，完成的container列表等信息。 2. ContainerAllocator工作流程当用户提交作业之后，MRAppMaster会为之初始化，并创建一系列map task和reduce task，由于reduce task依赖于map task之间结果，所以reduce task会延后调度。在ContainerAllocator中，当map task数目完成一定比例（由mapreduce.job.reduce.slowstart.completedmaps指定，默认是0.05，即5%）且Reduce Task可允许占用的资源（Reduce Task可占用资源比由yarn.app.mapreduce.am.job.reduce.rampup.limit指定）能够折合成整数个任务时，才会调度Reduce Task。 考虑到Map Task和Reduce Task之间的依赖关系，因此，它们之间的数据结构转移也是不一样的，对于Map Task而言，会依次转移到以下几个数据结构中： scheduled-&gt;assigned-&gt;completed 对于Reduce Task而言，则按照以下流程： pending-&gt;scheduled-&gt;assigned-&gt;completed 其中，pengding表示等待ContainerAllocator发送资源请求，scheduled表示已经将资源请求发送给RM，但还没有收到分配的资源，assigned是已经收到RM分配的资源，completed已经未完成。 Reduce Task之所有多出一个pending，主要是为了根据Map Task情况调整Reduce Task状态（在pengding和scheduled中相互转移）。进一步说，这主要是为了防止Map Task饿死，因为在YARN中不再有map slot和reduce slot的概念（这两个概念从一定程度上减少了作业饿死的可能性），只有内存、CPU等真实的资源，需要由ApplicationMaster控制资源申请的顺序，以防止可能产生的作业饿死。此外，ContainerAllocator将所有任务划分成三类，分别是failed Map、Map和Reduce，并分别赋予它们优先级5、20和10，也就是说，当三种任务同时有资源需求是，会优先分配给failed map，然后是reduce，最后是map。 总结起来，ContainerAllocator工作流程如下： 步骤1 将所有map task的资源需求一次性发送给RM 步骤2 如果达到了Reduce task调度条件，则开始为Reduce Task申请资源。 步骤3 如果为某个task申请到了资源，则取消其他重复资源的申请。由于在HDFS中，任何一个任务通常有三备份，而对于一个任务而言，考虑到rack和any级别的本地性，它可能会对应7个资源请求，分别是： &lt;20, “node1”, “memory:1G”, 1&gt; &lt;20, “node2”, “memory:1G”, 1&gt; &lt;20, “node3”, “memory:1G”, 1&gt; &lt;20, “rack1”, “memory:1G”, 1&gt; &lt;20, “rack2”, “memory:1G”, 1&gt; &lt;20, “rack3”, “memory:1G”, 1&gt; &lt;20, “*”, “memory:1G”, 1&gt; 一旦该任务获取了以上任何一种资源，则会取消其他6个的资源申请。 步骤4 如果任务运行失败，则会重新为该任务申请资源。 步骤5 如果一个任务运行速度过慢，则会为其额外申请资源以启动备份任务（如果启动了推测执行功能）。 步骤6 如果一个节点失败的任务数目过多，则会撤销对该节点的所有资源申请请求。 3.ContainerAllocator类图ContainerAllocator实际上是一接口，它只定义了三个事件：CONTAINER_REQ,CONTAINER_DEALLOCATE和CONTAINER_FAILED，分别表示请求container，释放container和container运行失败。 ContainerAllocator的实现是RMContainerAllocator，它只接收和处理ContainerAllocator接口中定义的三种事件，它的运行是这三种事件驱动的。 RMContainerAllocator中最核心的框架是维护了一个心跳信息，在RMCommunicator类中实现如下： while (!stopped.get() &amp;&amp; !Thread.currentThread().isInterrupted()) { try { Thread.sleep(rmPollInterval); try { heartbeat(); } catch (YarnException e) { LOG.error(&quot;Error communicating with RM: &quot; + e.getMessage() , e); return; } catch (Exception e) { LOG.error(&quot;ERROR IN CONTACTING RM. &quot;, e); } } catch (InterruptedException e) { LOG.warn(&quot;Allocated thread interrupted. Returning.&quot;); return; } } 其中，heartbeat()函数定义（在RMContainerAllocator类中）如下： protected synchronized void heartbeat() throws Exception { LOG.info(&quot;Before Scheduling: &quot; + getStat()); List&lt;Container&gt; allocatedContainers = getResources(); LOG.info(&quot;After Scheduling: &quot; + getStat()); if (allocatedContainers.size() &gt; 0) { LOG.info(&quot;Before Assign: &quot; + getStat()); scheduledRequests.assign(allocatedContainers); LOG.info(&quot;After Assign: &quot; + getStat()); } …… } 其中，getResources()函数用于向RM发送心跳信息，并处理心跳应答。需要注意的是，有些情况下，心跳信息中并不包含新的资源请求信息，即空的心跳信息，这有以下几个作用： （1）周期性发送心跳，告诉RM自己还活着。 （2）周期性询问RM，以获取新分配的资源和各个container运行状况。 assign()函数是将收到的container分配给某个任务，如果这个container无法分配下去（比如内存空间不够），则是在下次心跳中通知RM释放该container，如果container可以分下去，则会释放对应任务的其他资源请求，同时会向TaskAttempt发送一个TA_ASSIGNED事件，以通知ContainerLauncher启动container。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[YARN之MRAppMaster整体架构]]></title>
      <url>%2F2017%2F01%2F10%2FYARN%E4%B9%8BMRAppMaster%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%2F</url>
      <content type="text"><![CDATA[MRAppMaster介绍MRAppMaster是MapReduce的ApplicationMaster实现，它使得MapReduce计算框架可以运行于YARN之上。在YARN中，MRAppMaster负责管理MapReduce作业的生命周期，包括创建MapReduce作业，向ResourceManager申请资源，与NodeManage通信要求其启动Container，监控作业的运行状态，当任务失败时重新启动任务等。 YARN中事件驱动的方式YARN使用了基于事件驱动的异步编程模型，它通过事件将各个组件联系起来，并由一个中央事件调度器统一将各种事件分配给对应的事件处理器。在YARN中，每种组件是一种事件处理器，当MRAppMaster启动时，它们会以服务的形式注册到MRAppMaster的中央事件调度器上，并告诉调度器它们处理的事件类型，这样，当出现某一种事件时，MRAppMaster会查询&lt;事件，事件处理器&gt;表，并将该事件分配给对应的事件处理器。接下来，我们分别介绍MRAppMaster各种组件/服务的功能。 ContainerAllocator与ResourceManager通信，为作业申请资源。作业的每个任务资源需求可描述为四元组，分别表示作业优先级、期望资源所在的host，资源量（当前仅支持内存），container数目。ContainerAllocator周期性通过RPC与ResourceManager通信，而ResourceManager会为之返回已经分配的container列表，完成的container列表等信息。 ClientServiceClientService是一个接口，由MRClientService实现。MRClientService实现了MRClientProtocol协议，客户端可通过该协议获取作业的执行状态（而不必通过ResourceManager）和制作业（比如杀死作业等）。 Job表示一个MapReduce作业，与MRv1的JobInProgress功能一样，负责监控作业的运行状态。它维护了一个作业状态机，以实现异步控制各种作业操作。 Task表示一个MapReduce作业中的某个任务，与MRv1中的TaskInProgress功能类似，负责监控一个任务的运行状态。它为花了一个任务状态机，以实现异步控制各种任务操作。 TaskAttempt表示一个任务运行实例，同MRv1中的概念一样。 TaskCleaner清理失败任务或者被杀死任务产生的结果，它维护了一个线程池，异步删除这些任务产生的结果。 Speculator完成推测执行功能。当一个任务运行速度明显慢于其他任务时，Speculator会为该任务启动一个备份任务，让其同慢任务一同处理同一份数据，谁先计算完成则将谁的结果作为最终结果，另一个任务将被杀掉。该机制可有效防止“拖后腿”任务拖慢整个作业的执行进度。 ContainerLauncher与NodeManager通信，要求其启动一个Container。当ResourceManager为作业分配资源后，ContainerLauncher会将资源信息封装成container，包括任务运行所需资源、任务运行命令、任务运行环境、任务依赖的外部文件等，然后与对应的节点通信，要求其启动container。 TaskAttemptListener管理各个任务的心跳信息，如果一个任务一段时间内未汇报心跳，则认为它死掉了，会将其从系统中移除。同MRv1中的TaskTracker类似，它实现了TaskUmbilicalProtocol协议，任务会通过该协议汇报心跳，并询问是否能够提交最终结果。 JobHistoryEventHandler对作业的各个事件记录日志，比如作业创建、作业开始运行、一个任务开始运行等，这些日志会被写到HDFS的某个目录下，这对于作业恢复非常有用。当MRAppMaster出现故障时，YARN会将其重新调度到另外一个节点上，为了避免重新计算，MRAppMaster首先会从HDFS上读取上次运行产生的运行日志，以恢复已经运行完成的任务，进而能够只运行尚未运行完成的任务。 Recovery当一个MRAppMaster故障后，它将被调度到另外一个节点上重新运行，为了避免重新计算，MRAppMaster首先会从HDFS上读取上次运行产生的运行日志，并恢复作业运行状态。 继续深入的步骤我将深入剖析以上这些组件的实现原理： YARN/MRv2 MRAppMaster深入剖析—作业生命周期 YARN/MRv2 MRAppMaster深入剖析—ContainerAllocator分析 YARN/MRv2 MRAppMaster深入剖析—ContainerLauncher分析 YARN/MRv2 MRAppMaster深入剖析—推测执行机制 YARN/MRv2 MRAppMaster深入剖析—作业恢复 转载自董的博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[YARN之Node Manager整体框架]]></title>
      <url>%2F2017%2F01%2F10%2FYARN%E4%B9%8BNode-Manager%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%2F</url>
      <content type="text"><![CDATA[NodeManager（NM）是YARN中每个节点上的代理，它管理Hadoop集群中单个计算节点，包括与ResourceManger保持通信，监督Container的生命周期管理，监控每个Container的资源使用（内存、CPU等）情况，追踪节点健康状况，管理日志和不同应用程序用到的附属服务（auxiliary service）。 【NodeStatusUpdater】当NM启动时，该组件向RM注册，并发送节点上可用资源。接下来，NM与RM通信，汇报各个Container的状态更新，包括节点上正运行的Container、已完成的Contaner等。此外，RM可能向NodeStatusUpdater发信号，杀死处于运行中的Container。注：NodeStatusUpdater是NM与RM通信的唯一通道，它实际上是RPC协议ResourceTracker的client，它周期性地调用RPC函数nodeHeartbeat()向RM汇报本节点上各种信息，包括资源使用情况，各个Container运行情况等。 【ContainerManager】它是NodeManager中核心组件，它由以下几个子组件构成，每个子组件负责一部分功能，以管理运行在该节点上的所有Container。（注意，ContainerManager实际上是个接口，真正的实现是ContainerManagerImpl类）（1）RPC Server ContainerManager从各个Application Master上接收RPC请求以启动Container或者停止正在运行的Container。它与ContainerTokenSecretManager（下面将介绍）合作，以对所有请求进行合法性验证。所有作用在正运行Container的操作均会被写入audit-log，以便让安全工具进行后续处理。 注：这里的“RPC Server”实际上是RPC协议ContainerManager的server，AM可通过该协议通知某个节点启动或者释放container，ContainerManager定义了三个接口供AM使用： StartContainerResponse startContainer(StartContainerRequest request); //启动container StopContainerResponse stopContainer(StopContainerRequest request); //释放container GetContainerStatusResponse getContainerStatus(GetContainerStatusRequest request);//获取container列表。 （2）ResourceLocalizationService 负责（从HDFS上）安全地下载和组织Container需要的各种文件资源。它尽量将文件分摊到各个磁盘上。它会为下载的文件添加访问控制限制，并为之施加合适的（磁盘空间）使用上限。 注：该服务会采用多线程方式同时从HDFS上下载文件，并按照文件类型（public或者private文件）存放到不同目录下，并为目录设置严格的访问权限，同时，每个用户可使用的磁盘空间大小也可以设置。 （3）ContainersLauncher 维护了一个线程池，随时准备并在必要时尽快启动Container，同时，当收到来自RM或者 ApplicationMaster的清理Container请求时，会清理对应的Container进程。 （4）AuxServices NM提供了一个框架以通过配置附属服务扩展自己的功能，这允许每个节点定制一些特定框架可能需要的服务，当然，这些服务是与NM其他服务隔离开的（有自己的安全验证机制）。附属服务需要在NM启动之前配置好，且由对应应用程序的运行在本节点上的第一container触发启动。 （5）ContainersMonitor 当一个Container启动之后，该组件便开始观察它在运行过程中的资源利用率。为了实现资源隔离和公平共享，RM为每个Container分配了一定量的资源。ContainersMonitor持续监控每个Container的利用率，一旦一个Container超出了它的允许使用份额，它将向Container发送信号将其杀掉，这可以避免失控的Container影响了同节点上其他正在运行的Container。（注意，ContainersMonitor实际上是个接口，真正的实现是ContainersMonitorImpl类）。 注：NM启动一个container后，ContainersMonitor会将该container进程对一个的pid添加到监控列表中，以监控以pid为根的整棵进程树的资源使用情况，它周期性地从/etc/proc中获取进程树使用的总资源，一旦发现超过了预期值，则会将其杀死。在最新版YARN中，已采用了Linux container对资源进行隔离。 （6）LogHandler 一个可插拔组件，用户通过它可选择将Container日志写到本地磁盘上还是将其打包后上传到一个文件系统中。 【ContainerExecutor】与底层操作系统交互，安全存放Container需要的文件和目录，进而以一种安全的方式启动和清除Container对应的进程。 注：在最新版YARN中，已采用了Linux container对资源进行隔离 【NodeHealthCheckerService】提供以下功能：通过周期性地运行一个配置好的脚本检查节点的健康状况，它也会通过周期性地在磁盘上创建临时文件以监控磁盘健康状况。任何系统健康方面的改变均会通知NodeStatusUpdater（前面已经介绍过），它会进一步将信息传递给RM。 【Security】（1） ApplicationACLsManager NM需要为所有面向用户的API提供安全检查，如在Web-UI上只能将container日志显示给授权用户。该组件为每个应用程序维护了一个ACL列表，一旦收到类似请求后会利用该列表对其进行验证。（2） ContainerTokenSecretManager 检查收到的各种访问请求的合法性，确保这些请求操作已被RM授权。 【WebServer】在给定时间点，展示该节点上所有应用程序和container列表，节点健康相关的信息和container产生的日志。 【主要功能亮点】启动Container为了能够启动Container，NM期望收到的Container定义了关于它运行时所需的详细信息，包括运行container的命令、环境变量、所需的资源列表和安全令牌等。 一旦收到container启动请求，如果YARN启用了安全机制，则NM首先验证请求合法性以对用户和正确的资源分配进行授权。之后，NM将按照以下步骤启动一个container： （1） 在本地拷贝一份运行Container所需的所有资源（通过Distributed Cache实现）。 （2） 为container创建经隔离的工作目录，并在这些目录中准备好所有（文件）资源。 （3） 运行命令启动container 日志聚集处理用户日志是过去令人头痛的事情之一。与MRv1不同，NM不再截取日志并将日志留单个节点（TaskTracker）上，而是将日志上传到一个文件系统中，比如HDFS，以此来解决日志管理问题。在某个NM上，所有属于同一个应用程序的container日志经聚集后被写到（可能经过压缩处理）一个FS上的日志文件中，用户可通过YARN命令行工具，WEB-UI或者直接通过FS访问这些日志。 MapReduce shuffle如何利用NM的附属服务运行MapReduce程序所需的shuffle功能是通过附属服务实现的，该服务会启动一个Netty Server，它知道如何处理来自Reduce Task的MR相关的shuffle请求。MR（MapReduce） AM（ApplicationMaster）为shuffle服务定义了服务ID，和可能需要的安全令牌，而NM向AM提供shuffle服务的运行端口号，并由AM传递给各个Reduce Task。 结论在YARN中，NodeManager主要用于管理抽象的container，它只处理container相关的事情，而不必关心每个应用程序（如MapReduce Task）自身的状态管理，它也不再有类似于map slot和reduce slot的slot概念，正是由于上述各个模块间清晰的责任分离，NM可以很容易的扩展，且它的代码也更容易维护。 转载自董的博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[YARN之Resource Manager 总体架构]]></title>
      <url>%2F2017%2F01%2F10%2FYARN%E4%B9%8BResource-Manager-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%2F</url>
      <content type="text"><![CDATA[RM粗略介绍在YARN中，ResourceManager负责集群中所有资源的统一管理和分配，它接收来自各个节点（NodeManager）的资源汇报信息，并把这些信息按照一定的策略分配给各个应用程序（实际上是ApplicationManager）。 RM组成ResourceManager主要由以下几个部分组成： 用户交互YARN分别针对普通用户，管理员和Web提供了三种对外服务，分别对应ClientRMService、AdminService和WebApp： ClientRMServiceClientRMService是为普通用户提供的服务，它会处理来自客户端各种RPC请求，比如提交应用程序、终止应用程序，获取应用程序运行状态等。 AdminServiceYARN为管理员提供了一套独立的服务接口，以防止大量的普通用户请求使管理员发送的管理命令饿死，管理员可通过这些接口管理集群，比如动态更新节点列表，更新ACL列表，更新队列信息等。 WebApp为了更加友好地展示集群资源使用情况和应用程序运行状态等信息，YARN对外提供了一个Web 界面，这一部分是YARN仿照haml（http://haml.info/）开发的一个轻量级嵌入式Web框架。具体讨论见：https://issues.apache.org/jira/browse/MAPREDUCE-2399 NM管理NMLivelinessMonitor监控NM是否活着，如果一个NodeManager在一定时间（默认为10min）内未汇报心跳信息，则认为它死掉了，会将其从集群中移除。 NodesListManager维护正常节点和异常节点列表，管理exlude（类似于黑名单）和inlude（类似于白名单）节点列表，这两个列表均是在配置文件中设置的，可以动态加载。 ResourceTrackerService处理来自NodeManager的请求，主要包括两种请求：注册和心跳，其中，注册是NodeManager启动时发生的行为，请求包中包含节点ID，可用的资源上限等信息，而心跳是周期性 行为，包含各个Container运行状态，运行的Application列表、节点健康状况（可通过一个脚本设置），而ResourceTrackerService则为NM返回待释放的Container列表、Application列表等。 AM管理AMLivelinessMonitor监控AM是否活着，如果一个ApplicationMaster在一定时间（默认为10min）内未汇报心跳信息，则认为它死掉了，它上面所有正在运行的Container将被认为死亡，AM本身会被重新分配到另外一个节点上（用户可指定每个ApplicationMaster的尝试次数，默认是1次）执行。 ApplicationMasterLauncher与NodeManager通信，要求它为某个应用程序启动ApplicationMaster。 ApplicationMasterService处理来自ApplicationMaster的请求，主要包括两种请求：注册和心跳，其中，注册是ApplicationMaster启动时发生的行为，包括请求包中包含所在节点，RPC端口号和tracking URL等信息，而心跳是周期性 行为，包含请求资源的类型描述、待释放的Container列表等，而AMS则为之返回新分配的Container、失败的Container等信息。 Application管理ApplicationACLsManager管理应用程序访问权限，包含两部分权限：查看和修改，查看主要指查看应用程序基本信息，而修改则主要是修改应用程序优先级、杀死应用程序等。 RMAppManager管理应用程序的启动和关闭。 ContainerAllocationExpirerYARN不允许AM获得Container后长时间不对其使用，因为这会降低整个集群的利用率。当AM收到RM新分配的一个Container后，必须在一定的时间（默认为10min）内在对应的NM上启动该Container， 否则，RM会回收该Container。 安全管理ResourceManage自带了非常全面的权限管理机制，主要由ClientToAMSecretManager、ContainerTokenSecretManager、ApplicationTokenSecretManager等模块完成。 资源分配ResourceSchedulerResourceScheduler是资源调度器，它按照一定的约束条件（比如队列容量限制等）将集群中的资源分配给各个应用程序，当前主要考虑内存资源，在3.0版本中将会考虑CPU（https://issues.apache.org/jira/browse/YARN-2）。ResourceScheduler是一个插拔式模块，默认是FIFO实现，YARN还提供了Fair Scheduler和Capacity Scheduler两个多租户调度器。 转载自董的博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hadoop2.0之YARN中的Container]]></title>
      <url>%2F2017%2F01%2F10%2Fhadoop2-0%E4%B9%8BYARN%E4%B8%AD%E7%9A%84Container%2F</url>
      <content type="text"><![CDATA[Container概念引出在学习Hadoop YARN—Hadoop 2.0新引入的通用资源管理系统过程中，总会遇到Container这一概念，由于中文资料的缺乏，很多人对Container这一概念仍非常的模糊。它与Linux Container是什么关系，它是否能像Linux Container那样为任务提供一个隔离环境?它代表计算资源，还是仅仅是一个任务处理进程？本文将尝试介绍Container这一概念。 hadoop中任务工作流程在学习Container之前，大家应先了解YARN的基本架构、工作流程。比如，大家应该了解一个应用程序的运行过程如下： 步骤1：用户将应用程序提交到ResourceManager上； 步骤2：ResourceManager为应用程序ApplicationMaster申请资源，并与某个NodeManager通信，以启动ApplicationMaster； 步骤3：ApplicationMaster与ResourceManager通信，为内部要执行的任务申请资源，一旦得到资源后，将于NodeManager通信，以启动对应的任务。 步骤4：所有任务运行完成后，ApplicationMaster向ResourceManager注销，整个应用程序运行结束。上述步骤中，步骤2~3涉及到资源申请与使用，而这正是Container出现的地方。 如果你你还不了解YARN的基本架构和工作原理，先按照以下方向进行了解。 YARN基本架构，YARN中的基本术语，YARN整套分析文章。 关于Container资源申请与分配在YARN中，ResourceManager中包含一个插拔式的组件：资源调度器，它负责资源的管理和调度，是YARN中最核心的组件之一。 当向资源调度器申请资源，需向它发送一个ResourceRequest列表，其中，每个ResourceRequest描述了一个资源单元的详细需求，而资源调度器则为之返回分配到的资源描述Container。每个ResourceRequest可看做一个可序列化Java对象，包含的字段信息（直接给出了Protocol Buffers定义）如下： message ResourceRequestProto { optional PriorityProto priority = 1; // 资源优先级 optional string resource_name = 2; // 资源名称（期望资源所在的host、rack名称等） optional ResourceProto capability = 3; // 资源量（仅支持CPU和内存两种资源） optional int32 num_containers = 4; // 满足以上条件的资源个数 optional bool relax_locality = 5 [default = true]; //是否支持本地性松弛（2.1.0-beta之后的版本新增加的，具体参考我的这篇文章：Hadoop新特性、改进、优化和Bug分析系列3：YARN-392） } 从上面定义可以看出，可以为应用程序申请任意大小的资源量（CPU和内存），且默认情况下资源是本地性松弛的，即申请优先级为10，资源名称为“node11”，资源量为的5份资源时，如果节点node11上没有满足要求的资源，则优先找node11同一机架上其他节点上满足要求的资源，如果仍找不到，则找其他机架上的资源。而如果你一定要node11上的节点，则将relax_locality置为false。 发出资源请求后，资源调度器并不会立马为它返回满足要求的资源，而需要应用程序的ApplicationMaster不断与ResourceManager通信，探测分配到的资源，并拉去过来使用。一旦分配到资源后，ApplicatioMaster可从资源调度器那获取以Container表示的资源，Container可看做一个可序列化Java对象，包含的字段信息（直接给出了Protocol Buffers定义）如下： message ContainerProto { optional ContainerIdProto id = 1; //container id optional NodeIdProto nodeId = 2; //container（资源）所在节点 optional string node_http_address = 3; optional ResourceProto resource = 4; //container资源量 optional PriorityProto priority = 5; //container优先级 optional hadoop.common.TokenProto container_token = 6; //container token，用于安全认证 } 一般而言，每个Container可用于运行一个任务。ApplicationMaster收到一个或多个Container后，再次将该Container进一步分配给内部的某个任务，一旦确定该任务后，ApplicationMaster需将该任务运行环境（包含运行命令、环境变量、依赖的外部文件等）连同Container中的资源信息封装到ContainerLaunchContext对象中，进而与对应的NodeManager通信，以启动该任务。ContainerLaunchContext包含的字段信息（直接给出了Protocol Buffers定义）如下： message ContainerLaunchContextProto { repeated StringLocalResourceMapProto localResources = 1; //Container启动以来的外部资源 optional bytes tokens = 2; repeated StringBytesMapProto service_data = 3; repeated StringStringMapProto environment = 4; //Container启动所需的环境变量 repeated string command = 5; //Container内部运行的任务启动命令，如果是MapReduce的话，Map/Reduce Task启动命令就在该字段中 repeated ApplicationACLMapProto application_ACLs = 6; } 每个ContainerLaunchContext和对应的Container信息（被封装到了ContainerToken中）将再次被封装到StartContainerRequest中，也就是说，ApplicationMaster最终发送给NodeManager的是StartContainerRequest，每个StartContainerRequest对应一个Container和任务。 Container的基本概念与工作流程总结上述可知，Container的一些基本概念和工作流程如下： （1） Container是YARN中资源的抽象，它封装了某个节点上一定量的资源（CPU和内存两类资源）。它跟Linux Container没有任何关系，仅仅是YARN提出的一个概念（从实现上看，可看做一个可序列化/反序列化的Java类）。 （2） Container由ApplicationMaster向ResourceManager申请的，由ResouceManager中的资源调度器异步分配给ApplicationMaster； （3） Container的运行是由ApplicationMaster向资源所在的NodeManager发起的，Container运行时需提供内部执行的任务命令（可以使任何命令，比如java、Python、C++进程启动命令均可）以及该命令执行所需的环境变量和外部资源（比如词典文件、可执行文件、jar包等）。 另外，一个应用程序所需的Container分为两大类，如下：（1） 运行ApplicationMaster的Container：这是由ResourceManager（向内部的资源调度器）申请和启动的，用户提交应用程序时，可指定唯一的ApplicationMaster所需的资源； （2） 运行各类任务的Container：这是由ApplicationMaster向ResourceManager申请的，并由ApplicationMaster与NodeManager通信以启动之。 以上两类Container可能在任意节点上，它们的位置通常而言是随机的，即ApplicationMaster可能与它管理的任务运行在一个节点上。 Container是YARN中最重要的概念之一，懂得该概念对于理解YARN的资源模型至关重要，希望本文对学习Container这一概念有所帮助。 文章转载自董的博客]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java语言基础11、StringBuffer、String、冒泡、选择、二分、Interger等]]></title>
      <url>%2F2017%2F01%2F04%2Fjava%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8011%E3%80%81StringBuffer%E3%80%81String%E3%80%81%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81Interger%E7%AD%89%2F</url>
      <content type="text"><![CDATA[01_常见对象(StringBuffer类的概述) A:StringBuffer类概述 通过JDK提供的API，查看StringBuffer类的说明 线程安全的可变字符序列 B:StringBuffer和String的区别 String是一个不可变的字符序列 StringBuffer是一个可变的字符序列 02_常见对象(StringBuffer类的构造方法) A:StringBuffer的构造方法： public StringBuffer():无参构造方法 public StringBuffer(int capacity):指定容量的字符串缓冲区对象 public StringBuffer(String str):指定字符串内容的字符串缓冲区对象 B:StringBuffer的方法： public int capacity()：返回当前容量。 理论值(不掌握) public int length():返回长度（字符数）。 实际值 03_常见对象(StringBuffer的添加功能) A:StringBuffer的添加功能 public StringBuffer append(String str): 可以把任意类型数据添加到字符串缓冲区里面,并返回字符串缓冲区本身 public StringBuffer insert(int offset,String str): 在指定位置把任意类型的数据插入到字符串缓冲区里面,并返回字符串缓冲区本身 04_常见对象(StringBuffer的删除功能) A:StringBuffer的删除功能 public StringBuffer deleteCharAt(int index): 删除指定位置的字符，并返回本身 public StringBuffer delete(int start,int end): 删除从指定位置开始指定位置结束的内容，并返回本身 05_常见对象(StringBuffer的替换和反转功能) A:StringBuffer的替换功能 public StringBuffer replace(int start,int end,String str): 从start开始到end用str替换 B:StringBuffer的反转功能 public StringBuffer reverse(): 字符串反转 06_常见对象(StringBuffer的截取功能及注意事项) A:StringBuffer的截取功能 public String substring(int start): 从指定位置截取到末尾 public String substring(int start,int end): 截取从指定位置开始到结束位置，包括开始位置，不包括结束位置 B:注意事项 注意:返回值类型不再是StringBuffer本身 07_常见对象(StringBuffer和String的相互转换) A:String – StringBuffer a:通过构造方法 b:通过append()方法 B:StringBuffer – String a:通过构造方法 b:通过toString()方法 c:通过subString(0,length); 08_常见对象(把数组转成字符串) A:案例演示 需求：把数组中的数据按照指定个格式拼接成一个字符串 举例： int[] arr = {1,2,3}; 输出结果： &quot;[1, 2, 3]&quot; 用StringBuffer的功能实现 09_常见对象(字符串反转) A:案例演示 需求：把字符串反转 举例：键盘录入&quot;abc&quot; 输出结果：&quot;cba&quot; 用StringBuffer的功能实现只需一个reverse即可 10_常见对象(StringBuffer和StringBuilder的区别) A:StringBuilder的概述 通过查看API了解一下StringBuilder类 B:面试题 String,StringBuffer,StringBuilder的区别 StringBuffer和StringBuilder的区别 StringBuffer是jdk1.0版本的,是线程安全的,效率低 StringBuilder是jdk1.5版本的,是线程不安全的,效率高 String和StringBuffer,StringBuilder的区别 String是一个不可变的字符序列 StringBuffer,StringBuilder是可变的字符序列 11_常见对象(String和StringBuffer分别作为参数传递) A:形式参数问题 String作为参数传递 StringBuffer作为参数传递 B:案例演示 String和StringBuffer分别作为参数传递问题 12_常见对象(数组高级冒泡排序原理图解) A:画图演示 需求： 数组元素：{24, 69, 80, 57, 13} 请对数组元素进行排序。 冒泡排序 相邻元素两两比较，大的往后放，第一次完毕，最大值出现在了最大索引处 13_常见对象(数组高级冒泡排序代码实现) A:案例演示 数组高级冒泡排序代码 14_常见对象(数组高级选择排序原理图解) A:画图演示 需求： 数组元素：{24, 69, 80, 57, 13} 请对数组元素进行排序。 选择排序 从0索引开始，依次和后面元素比较，小的往前放，第一次完毕，最小值出现在了最小索引处 15_常见对象(数组高级选择排序代码实现) A:案例演示 数组高级选择排序代码 16_常见对象(数组高级二分查找原理图解) A:画图演示 二分查找 前提：数组元素有序 17_常见对象(数组高级二分查找代码实现及注意事项) A:案例演示 数组高级二分查找代码 B:注意事项 如果数组无序，就不能使用二分查找。 因为如果你排序了，但是你排序的时候已经改变了我最原始的元素索引。 18_常见对象(Arrays类的概述和方法使用) A:Arrays类概述 针对数组进行操作的工具类。 提供了排序，查找等功能。 B:成员方法 public static String toString(int[] a) public static void sort(int[] a) public static int binarySearch(int[] a,int key) 19_常见对象(基本类型包装类的概述) A:为什么会有基本类型包装类 将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据。 B:常用操作 常用的操作之一：用于基本数据类型与字符串之间的转换。 C:基本类型和包装类的对应 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 其中除了char类型都有parseXXX(String)函数转为基本类型。因为char可以直接用toCharArray()20_常见对象(Integer类的概述和构造方法) A:Integer类概述 通过JDK提供的API，查看Integer类的说明 Integer 类在对象中包装了一个基本类型 int 的值, 该类提供了多个方法，能在 int 类型和 String 类型之间互相转换， 还提供了处理 int 类型时非常有用的其他一些常量和方法 B:构造方法 public Integer(int value) public Integer(String s) C:案例演示 使用构造方法创建对象 21_常见对象(String和int类型的相互转换) A:int – String a:和””进行拼接 b:public static String valueOf(int i) c:int – Integer – String(Integer类的toString方法()) d:public static String toString(int i)(Integer类的静态方法) B:String – int a:String – Integer – int public static int parseInt(String s) 22_常见对象(JDK5的新特性自动装箱和拆箱) A:JDK5的新特性 自动装箱：把基本类型转换为包装类类型 自动拆箱：把包装类类型转换为基本类型 B:案例演示 JDK5的新特性自动装箱和拆箱 Integer ii = 100; ii += 200; C:注意事项 在使用时，Integer x = null;代码就会出现NullPointerException。 建议先判断是否为null，然后再使用。 23_常见对象(Integer的面试题) A:Integer的面试题 看程序写结果 Integer i1 = new Integer(97); Integer i2 = new Integer(97); System.out.println(i1 == i2); //false System.out.println(i1.equals(i2)); //true System.out.println(&quot;-----------&quot;); Integer i3 = new Integer(197); Integer i4 = new Integer(197); System.out.println(i3 == i4); //false System.out.println(i3.equals(i4)); //true System.out.println(&quot;-----------&quot;); Integer i5 = 127; //-128-127都可以 Integer i6 = 127; System.out.println(i5 == i6); //true System.out.println(i5.equals(i6)); //true System.out.println(&quot;-----------&quot;); Integer i7 = 128; 大于等于128 Integer i8 = 128; System.out.println(i7 == i8); //false System.out.println(i7.equals(i8)); //true * 上述两个“==”判断结果不同，因为JDK5新特性，有自动装箱机制， * -128-127是byte的取值范围，如果在这个范围就不会创建新的对象 * 但是超过这个范围内就会创建对象了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java语言基础10、Scanner、String类对象]]></title>
      <url>%2F2017%2F01%2F04%2Fjava%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8010%E3%80%81Scanner%E3%80%81String%E7%B1%BB%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[01_常见对象(Scanner的概述和方法介绍)(掌握) A:Scanner的概述 B:Scanner的构造方法原理 Scanner(InputStream source) System类下有一个静态的字段：public static final InputStream in; 标准的输入流，对应着键盘录入。 C:一般方法 hasNextXxx() 判断是否还有下一个输入项,其中Xxx可以是Int,Double等。如果需要判断是否包含下一个字符串，则可以省略Xxx nextXxx() 获取下一个输入项。Xxx的含义和上个方法中的Xxx相同,默认情况下，Scanner使用空格，回车等作为分隔符 02_常见对象(Scanner获取数据出现的小问题及解决方案)(掌握) A:两个常用的方法： public int nextInt():获取一个int类型的值 public String nextLine():获取一个String类型的值 B:案例演示 a:先演示获取多个int值，多个String值的情况 b:再演示先获取int值，然后获取String值出现问题 出现如下问题假如我们先输入10，在输入hello， 其中我们输入10后面会自带\r\n，*如果运行完nextInt他是不管这些的，紧接着运行nextLine的话，他会接受后面的\r\n而不是下一行的hello。 c:问题解决方案 第一种：先获取一个数值后，在创建一个新的键盘录入Scannner对象获取字符串。 第二种：把所有的数据都先按照字符串获取，用nextLine,然后要什么，你就对应的转换对应类型 int i = sc.nextInt（）； String line2= sc.nextLine(); 03_常见对象(String类的概述)(掌握) A:String类的概述 通过JDK提供的API，查看String类的说明 可以看到这样的两句话。 a:字符串字面值”abc”也可以看成是一个字符串对象。 b:字符串是常量，一旦被赋值，就不能被改变。 04_常见对象(String类的构造方法)(掌握) A:常见构造方法 public String():空构造 public String(byte[] bytes):把字节数组转成字符串 public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串 public String(char[] value):把字符数组转成字符串 public String(char[] value,int index,int count):把字符数组的一部分转成字符串 public String(String original):把字符串常量值转成字符串 05_常见对象(String类的常见面试题)(掌握) 1.判断定义为String类型的s1和s2是否相等 String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; System.out.println(s1 == s2); //true 虽然比较的是引用对象，但是String放在常量池里，所以是一样的 System.out.println(s1.equals(s2)); //true 2.下面这句话在内存中创建了几个对象? String s1 = new String(&quot;abc&quot;); //创建了2个，一个是在常量池创建‘“abc”这个对象，另一个是在堆里创建 3.判断定义为String类型的s1和s2是否相等 String s1 = new String(&quot;abc&quot;); String s2 = &quot;abc&quot;; System.out.println(s1 == s2); ? //false 第一个s1是在堆内存中，s2是在常量池中 System.out.println(s1.equals(s2)); ? //true 4.判断定义为String类型的s1和s2是否相等 String s1 = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;; String s2 = &quot;abc&quot;; System.out.println(s1 == s2); ? //true,java中有常量优化机制所以等同于上述1题，指向同一个常量值“abc” System.out.println(s1.equals(s2)); ? //true 5.判断定义为String类型的s1和s2是否相等 String s1 = &quot;ab&quot;; String s2 = &quot;abc&quot;; String s3 = s1 + &quot;c&quot;; System.out.println(s3 == s2); //false 注意s3=s1+&quot;c&quot;;其中s1是变量，并不是常量，由其和“+”符号相连得到的字符串不在常量池，而是在堆内转换的 System.out.println(s3.equals(s2)); ? //true 06_常见对象(String类的判断功能)(掌握) A:String类的判断功能 boolean equals(Object obj):比较字符串的内容是否相同,区分大小写 boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 boolean contains(String str):判断大字符串中是否包含小字符串 boolean startsWith(String str):判断字符串是否以某个指定的字符串开头 boolean endsWith(String str):判断字符串是否以某个指定的字符串结尾 boolean isEmpty():判断字符串是否为空。 07_常见对象(String类的获取功能)(掌握) A:String类的获取功能 int length():获取字符串的长度。中文每一个字就是一个字符 char charAt(int index):获取指定索引位置的字符 int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。 int indexOf(String str):返回指定字符串在此字符串中第一次出现处的索引。 int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现处的索引。 int indexOf(String str,int fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现处的索引。 lastIndexOf String substring(int start):从指定位置开始截取字符串,默认到末尾。 String substring(int start,int end):从指定位置开始到指定位置结束截取字符串。 08_常见对象(String类的转换功能)(掌握) A:String的转换功能： byte[] getBytes():把字符串转换为字节数组。 char[] toCharArray():把字符串转换为字符数组。 static String valueOf(char[] chs):把字符数组转成字符串。 static String valueOf(int i):把int类型的数据转成字符串。 注意：String类的valueOf方法可以把任意类型的数据转成字符串。 String toLowerCase():把字符串转成小写。 String toUpperCase():把字符串转成大写。 String concat(String str):把字符串拼接。 09_常见对象(String类的其他功能) A:String的替换功能及案例演示 String replace(char old,char new) String replace(String old,String new) B:String的去除字符串两边空格（但是中间不会去掉） String trim() C:String的按字典顺序比较两个字符串及案例演示 int compareTo(String str) int compareToIgnoreCase(String str)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java语言基础09、包、import、四种权限、匿名内部类]]></title>
      <url>%2F2016%2F12%2F29%2Fjava%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8009%E3%80%81%E5%8C%85%E3%80%81import%E3%80%81%E5%9B%9B%E7%A7%8D%E6%9D%83%E9%99%90%E3%80%81%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
      <content type="text"><![CDATA[01_面向对象(package关键字的概述及作用)(了解) A:为什么要有包 将字节码(.class)进行分类存放 包其实就是文件夹 B:包的概述 举例： 学生：增加，删除，修改，查询 老师：增加，删除，修改，查询 ... 方案1：按照功能分 com.heima.add AddStudent AddTeacher com.heima.delete DeleteStudent DeleteTeacher com.heima.update UpdateStudent UpdateTeacher com.heima.find FindStudent FindTeacher 方案2：按照模块分 com.heima.teacher AddTeacher DeleteTeacher UpdateTeacher FindTeacher com.heima.student AddStudent DeleteStudent UpdateStudent FindStudent 02_面向对象(包的定义及注意事项)(掌握) A:定义包的格式 package 包名; 多级包用.分开即可 B:定义包的注意事项 A:package语句必须是程序的第一条可执行的代码 B:package语句在一个java文件中只能有一个 C:如果没有package，默认表示无包名 C:案例演示 包的定义及注意事项 03_面向对象(带包的类编译和运行)(掌握) A:如何编译运行带包的类 a:javac编译的时候带上-d即可 javac -d . HelloWorld.java b:通过java命令执行。 java 包名.HellWord04_面向对象(不同包下类之间的访问)(掌握) A:案例演示 不同包下类之间的访问 05_面向对象(import关键字的概述和使用)(掌握) A:案例演示 为什么要有import 其实就是让有包的类对调用者可见,不用写全类名了 B:导包格式 import 包名; 注意： 这种方式导入是到类的名称。 虽然可以最后写*，但是不建议。 C:package,import,class有没有顺序关系(面试题) 06_面向对象(四种权限修饰符的测试)(掌握) A:案例演示 四种权限修饰符 B:结论 本类 同一个包下(子类和无关类) 不同包下(子类) 不同包下(无关类) private Y 默认 Y Y protected Y Y Y public Y Y Y Y 07_面向对象(类及其组成所使用的常见修饰符)(掌握) A:修饰符： 权限修饰符：private，默认的，protected，public 状态修饰符：static，final 抽象修饰符：abstract B:类： 权限修饰符：默认修饰符，public 状态修饰符：final 抽象修饰符：abstract 用的最多的就是：public C:成员变量： 权限修饰符：private，默认的，protected，public 状态修饰符：static，final 用的最多的就是：private D:构造方法： 权限修饰符：private，默认的，protected，public 用的最多的就是：public E:成员方法： 权限修饰符：private，默认的，protected，public 状态修饰符：static，final 抽象修饰符：abstract 用的最多的就是：public F:除此以外的组合规则： 成员变量：public static final 成员方法： public static public abstract public final 08_面向对象(内部类概述和访问特点)(了解) A:内部类概述 B:内部类访问特点 a:内部类可以直接访问外部类的成员，包括私有。 b:外部类要访问内部类的成员，必须创建对象。 外部类名.内部类名 对象名 = 外部类对象.内部类对象; C:案例演示 内部类极其访问特点 09_面向对象(成员内部类私有使用)(了解) private 10_面向对象(静态成员内部类)(了解) static B:成员内部类被静态修饰后的访问方式是: 外部类名.内部类名 对象名 = 外部类名.内部类对象; 11_面向对象(成员内部类的面试题)(掌握) A:面试题 要求：使用已知的变量，在控制台输出30，20，10。 class Outer { public int num = 10; class Inner { public int num = 20; public void show() { int num = 30; System.out.println(?); System.out.println(??); System.out.println(???); } } } class InnerClassTest { public static void main(String[] args) { Outer.Inner oi = new Outer().new Inner(); oi.show(); } } 12_面向对象(局部内部类访问局部变量的问题)(掌握) A:案例演示 局部内部类访问局部变量必须用final修饰 局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么? 因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用 但是jdk1.8取消了这个事情,所以我认为这是个bug 13_面向对象(匿名内部类的格式和理解) A:匿名内部类 就是内部类的简化写法。 B:前提：存在一个类或者接口 这里的类可以是具体类也可以是抽象类。 C:格式： new 类名或者接口名(){ 重写方法; } D:本质是什么呢? 是一个继承了该类或者实现了该接口的子类匿名对象。 E:案例演示 按照要求来一个匿名内部类 14_面向对象(匿名内部类重写多个方法调用) A:案例演示 匿名内部类的方法调用 15_面向对象(匿名内部类在开发中的应用) A:代码如下 //这里写抽象类，接口都行 abstract class Person { public abstract void show(); } class PersonDemo { public void method(Person p) { p.show(); } } class PersonTest { public static void main(String[] args) { //如何调用PersonDemo中的method方法呢? PersonDemo pd = new PersonDemo (); } } 16_面向对象(匿名内部类的面试题) A:面试题 按照要求，补齐代码 interface Inter { void show(); } class Outer { //补齐代码 } class OuterDemo { public static void main(String[] args) { Outer.method().show(); } } 要求在控制台输出”HelloWorld”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Apache Falcon（一）安装]]></title>
      <url>%2F2016%2F12%2F28%2FApache%20Falcon%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85%2F</url>
      <content type="text"><![CDATA[如今，随着大数据越来越流行，大数据安全治理也变得越来越火热，介绍下其中数据处理框架Apache的顶级项目Falcon。先以安装为开始。 1. Hadoop配置项的修改1.1 修改yarn-site.xml操作机器 在主机-1、主机-2、主机-3节点上使用 hdfs 用户， /var/local/hadoop/hadoop-2.6.0/etc/hadoop 目录下 操作指令 1vim yarn-site.xml 在标签内修改添加如下内容 &lt;property&gt; &lt;name&gt;mapred.jobtracker.taskScheduler&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.FairScheduler&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapred.fairscheduler.allocation.file&lt;/name&gt; &lt;value&gt;/var/local/hadoop/hadoop-2.6.0/etc/hadoop/fair-scheduler.xml&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapred.fairscheduler.preemption&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapred.fairscheduler.assignmultiple&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapred.fairscheduler.poolnameproperty&lt;/name&gt; &lt;value&gt;mapred.job.queue.name&lt;/value&gt; &lt;description&gt;job.set(&quot;mapred.job.queue.name&quot;,pool); &lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapred.fairscheduler.preemption.only.log&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapred.fairscheduler.preemption.interval&lt;/name&gt; &lt;value&gt;15000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapred.queue.names&lt;/name&gt; &lt;value&gt;default,hadoop,hive&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt; &lt;value&gt;20960&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt; &lt;value&gt;1024&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt; &lt;value&gt;2048&lt;/value&gt; &lt;/property&gt; 1.2 添加公平策略fair-scheduler.xml因为Falcon的运作过程中会涉及大量的MapReduce作业，所以yarn调度需要进行一些处理，来保证他的负载均衡，所以此处我们最好加上公平策略。 操作机器 在主机-1、主机-2、主机-3节点上使用 hdfs 用户， /var/local/hadoop/hadoop-2.6.0/etc/hadoop 目录下 操作指令 vim fair-scheduler.xml 在文件中添加如下内容： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;allocations&gt; &lt;pool name=&quot;hive&quot;&gt; &lt;minMaps&gt;90&lt;/minMaps&gt; &lt;minReduces&gt;20&lt;/minReduces&gt; &lt;maxRunningJobs&gt;20&lt;/maxRunningJobs&gt; &lt;weight&gt;2.0&lt;/weight&gt; &lt;minSharePreemptionTimeout&gt;30&lt;/minSharePreemptionTimeout&gt; &lt;/pool&gt; &lt;pool name=&quot;hadoop&quot;&gt; &lt;minMaps&gt;9&lt;/minMaps&gt; &lt;minReduces&gt;2&lt;/minReduces&gt; &lt;maxRunningJobs&gt;20&lt;/maxRunningJobs&gt; &lt;weight&gt;1.0&lt;/weight&gt; &lt;minSharePreemptionTimeout&gt;30&lt;/minSharePreemptionTimeout&gt; &lt;/pool&gt; &lt;user name=&quot;hadoop&quot;&gt; &lt;maxRunningJobs&gt;6&lt;/maxRunningJobs&gt; &lt;/user&gt; &lt;poolMaxJobsDefault&gt;10&lt;/poolMaxJobsDefault&gt; &lt;userMaxJobsDefault&gt;8&lt;/userMaxJobsDefault&gt; &lt;defaultMinSharePreemptionTimeout&gt;600&lt;/defaultMinSharePreemptionTimeout&gt; &lt;fairSharePreemptionTimeout&gt;600&lt;/fairSharePreemptionTimeout&gt; &lt;/allocations&gt; 指令说明 minResources: 最少资源保证量,格式为 “X mb,Y vcores”. 各队列最少资源保证量之和最好不要超过YARN最大的可使用的内存 maxResources: 最多可以使用资源量,Fair Scheduler会保证每个队列使用的资源量不会超过该队列的最多可使用资源量. maxRunningApps: 最多同时运行的应用程序数目. schedulingPolicy: 队列采用的调度模式,支持 fifo,fair,drf aclSubmitApps: 可向队列中提交应用程序的数目,默认是*.如果需要指定多个用户可以这样hadoopuser hadoopgroup,sparkuser aclAdministerApps: 该队列的管理员列表,管理员可以杀死队列中的任一个任务 userMaxAppsDefault: 默认的用户最多同时运行应用程序 注:使用队列时只使用叶子队列maxRunningApps 参数非常有用需要根据当前集群的可用内存资源来配置。会因hadoop的版本不同，如果设置不当（值过大）,测试短时间内提交多个yarn程序同时运行时Yarn资源迅速用完时，各Job会长时间等待任务的分配。 2. 编译和部署Oozie-4.2.0oozie是falcon运行过程中所运行的调度器，所以其是falcon正常运行所必须的。 2.1 编译oozie操作机器 在集群 namenode 节点 主机-1 上使用 hdfs 用户， /home/hdfs 目录下 操作指令 wget http://mirror.bit.edu.cn/apache/oozie/4.2.0/oozie-4.2.0.tar.gz 下载 oozie 源代码 tar zxvf oozie-4.2.0.tar.gz cd oozie-4.2.0 解压缩 oozie-4.2.0, 进入 oozie源代码目录 bin/mkdistro.sh -DskipTests -Phadoop-2 -Dhadoop.auth.version=2.6.0 -Ddistcp.version=2.6.0 -Dhive.version=1.2.1 -Dsqoop.version=1.4.6 编译oozie-4.2.0，编译完成后在distro/target/ 目录下有oozie程序压缩包 oozie-4.2.0-distro.tar.gz tar -zxf oozie-4.2.0-distro.tar.gz mv oozie-4.2.0 /var/local/hadoop/ 解压缩oozie-4.2.0并将得到的文件移动到 /var/local/hadoop 目录下 2.2修改hdfs配置操作机器 在集群namenode节点主机-1上使用hdfs用户。 操作指令 vim /var/local/hadoop/hadoop-2.6.0/etc/hadoop/core-site.xml 修改 hadoop core-site.xml文件，添加如下配置： &lt;property&gt; &lt;name&gt;hadoop.proxyuser.hdfs.hosts&lt;/name&gt; &lt;value&gt;*&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.proxyuser.hdfs.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt; &lt;/property&gt; 其中hdfs是用户之后运行oozie的用户名 hdfs dfsadmin -refreshSuperUserGroupsConfiguration yarn rmadmin -refreshSuperUserGroupsConfiguration 不重启hadoop集群，而使配置生效 2.3添加Oozie lib扩展包操作机器 在集群namenode节点主机-1上使用hdfs用户。 操作指令 cd /var/local/hadoop/oozie-4.2.0 mkdir libext tar zxvf oozie-sharelib-4.2.0.tar.gz 在 oozie-4.2.0 新建 libext 文件夹并进入该目录 cp $HADOOP_HOME/share/hadoop/*/*.jar libext/ cp $HADOOP_HOME/share/hadoop/*/lib/*.jar libext/ cp $HIVE_HOME/lib/*.jar libext/ cp share/lib/hcatalog/*.jar libext/ 将hadoop的jar包导入oozie libext cd libext mv servlet-api-2.5.jar servlet-api-2.5.jar.bak mv jsp-api-2.1.jar jsp-api-2.1.jar.bak mv jasper-compiler-5.5.23.jar jasper-compiler-5.5.23.jar.bak mv jasper-runtime-5.5.23.jar jasper-runtime-5.5.23.jar.bak 把hadoop与tomcat冲突jar包去掉 将附件中ext-2.2.zip上传到$OOZIE_HOME/libext/目录下（此文件请百度自行下载文件） wget http://mirror.bit.edu.cn/mysql/Downloads/Connector-J/mysql-connector-java-5.1.38.tar.gz tar zxvf mysql-connector-java-5.1.38.tar.gz cp mysql-connector-java-5.1.38/mysql-connector-java-5.1.38-bin.jar /var/local/hadoop/oozie-4.2.0/libext 下载mysql驱动包至libext/目录下 2.4添加Oozie配置项操作机器 在集群namenode节点主机-1上使用hdfs用户 操作指令 cd /var/local/hadoop/oozie-4.2.0 vim conf/oozie-site.xml 修改oozie配置文件，添加如下内容 &lt;property&gt; &lt;name&gt;oozie.service.JPAService.create.db.schema&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.JPAService.jdbc.driver&lt;/name&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.JPAService.jdbc.url&lt;/name&gt; &lt;value&gt;jdbc:mysql://主机-1:3306/oozie?createDatabaseIfNotExist=true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.JPAService.jdbc.username&lt;/name&gt; &lt;value&gt;oozie&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.JPAService.jdbc.password&lt;/name&gt; &lt;value&gt;oozie&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.HadoopAccessorService.hadoop.configurations&lt;/name&gt; &lt;value&gt;*=/var/local/hadoop/hadoop-2.6.0/etc/hadoop&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.ProxyUserService.proxyuser.hdfs.hosts&lt;/name&gt; &lt;value&gt;*&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.ProxyUserService.proxyuser.hdfs.groups&lt;/name&gt; &lt;value&gt;*&lt;/value&gt; &lt;/property&gt; 操作说明 其中oozie.service.HadoopAccessorService.hadoop.configurations项配置目录为$HADOOP_HOME下的etc/hadoop目录，主机-1是运行oozie的节点机子，主机是运行oozie的用户名，与前面hadoop的core-site.xml配置一致 2.5添加mysql用户操作机器 在集群namenode节点主机-1上使用hdfs用户 操作指令 mysql -uroot -padmin 使用管理员用户进入mysql控制台 create database oozie; 创建名称为oozie的数据库 grant all privileges on oozie.* to &apos;oozie&apos;@&apos;localhost&apos; identified by &apos;oozie&apos;; 设置oozie数据库的访问权限，创建用户名为oozie，密码为oozie的用户 grant all privileges on oozie.* to &apos;oozie&apos;@&apos;%&apos; identified by &apos;oozie&apos;; 设置oozie数据库的访问权限 update mysql.user set host=’%’ where user=’root’ and host=’localhost’; insert into mysql.user (host,user,password) values(‘主机-1’,’oozie’,PASSWORD(‘oozie’)); 设置oozie用户的认证权限 FLUSH PRIVILEGES; quit 退出mysql控制台 重启mysql使配置生效： sudo service mysqld restart 2.6配置Oozie环境变量操作机器： 在主机-1，主机-2，主机-3上，使用hdfs用户，任意目录下 操作命令： sudo vim /etc/profile 主机-1,主机-2,主机-3在文件末尾，添加如下内容： export OOZIE_HOME=/var/local/hadoop/oozie-4.2.0 export PATH=$PATH:$HADOOP_HOME/bin:$OOZIE_HOME/bin 2.7刷新环境变量操作机器： 在主机-1,主机-2,主机-3上，使用当前终端，任意目录下 操作命令： source /etc/profile 2.8部署oozie操作机器 在集群namenode节点主机-1上使用hdfs用户 操作指令 cd /var/local/hadoop/oozie-4.2.0 bin/oozie-setup.sh prepare-war 打包oozie war包 bin/ooziedb.sh create -sqlfile oozie.sql -run 初始化数据库 vim oozie-server/conf/server.xml 修改服务器端conf/server.xml文件，注释掉下面的记录 bin/oozie-setup.sh sharelib create -fs hdfs://主机-1:9000 将oozie share库中的jar上传至hdfs上 2.9启动并测试oozie操作机器 在集群namenode节点主机-1上使用hdfs用户 操作指令 jps 显示启动的java服务，如果列表中没有historyserver服务，则输入下列指令启动historyserver： $HADOOP_HOME/sbin/mr-jobhistory-daemon.sh start historyserver 完成后再次输入jps查看启动结果 cd /var/local/hadoop/oozie-4.2.0 bin/oozied.sh start 启动oozie服务 oozie admin -oozie http://主机-1:11000/oozie -status 检验服务是否正常启动，如果显示System model:Normal启动成功，反之失败 操作说明 用户可以在浏览器输入http://主机-1:11000/oozie/进入oozie web端控制台查看oozie运行状态，其中主机-1为安装并运行oozie的节点ip地址 3. 编译和部署Falcon3.1编译falcon操作机器 在集群 namenode 节点 主机-1 上使用 hdfs 用户， /home/hdfs 目录下 操作指令 wget http://mirror.bit.edu.cn/apache/falcon/0.9/apache-falcon-0.9-sources.tar.gz 下载 falcon源码 tar -zxvf apache-falcon-0.9-sources.tar.gz cd falcon-sources-0.9/ 解压缩得到代码文件 falcon-sources-0.9 并进入 export MAVEN_OPTS=&quot;-Xmx1024m -XX:MaxPermSize=256m -noverify&quot; &amp;&amp; mvn clean install -Dhadoop.version=2.6.0 -Doozie.version=4.2.0 –DskipTests 打包编译falcon源码，如果在编译过程中出现npm error报错，输入下列指令安装npm： sudo yum -y install npm 安装npm并使用国内镜像 npm --registry https://registry.npm.taobao.org info underscore mvn clean assembly:assembly -DskipTests -DskipCheck=true 编译完成后在target/ 文件夹下存在apache-falcon-0.9-bin.tar.gz和apache-falcon-0.9-bin.zip压缩包 tar -zxvf target/apache-falcon-0.9-bin.tar.gz mv falcon-0.9 /var/local/hadoop/ 解压缩falcon工程包，并将解压缩得到的falcon-0.9 文件移到/var/local/hadoop 目录下 3.2 修改oozie配置项操作机器 在集群 namenode 节点 主机-1 上使用 hdfs 用户 操作指令 cd /var/local/hadoop/oozie-4.2.0 vim conf/oozie-site.xml 在oozie的oozie-site.xml配置文件中添加以下内容 &lt;!-- Oozie EL Extension configurations for falcon --&gt; &lt;property&gt; &lt;name&gt;oozie.service.ELService.ext.functions.coord-job-submit-instances&lt;/name&gt; &lt;value&gt; now=org.apache.oozie.extensions.OozieELExtensions#ph1_now_echo, today=org.apache.oozie.extensions.OozieELExtensions#ph1_today_echo, yesterday=org.apache.oozie.extensions.OozieELExtensions#ph1_yesterday_echo, currentWeek=org.apache.oozie.extensions.OozieELExtensions#ph1_currentWeek_echo, lastWeek=org.apache.oozie.extensions.OozieELExtensions#ph1_lastWeek_echo, currentMonth=org.apache.oozie.extensions.OozieELExtensions#ph1_currentMonth_echo, lastMonth=org.apache.oozie.extensions.OozieELExtensions#ph1_lastMonth_echo, currentYear=org.apache.oozie.extensions.OozieELExtensions#ph1_currentYear_echo, lastYear=org.apache.oozie.extensions.OozieELExtensions#ph1_lastYear_echo, formatTime=org.apache.oozie.coord.CoordELFunctions#ph1_coord_formatTime_echo, latest=org.apache.oozie.coord.CoordELFunctions#ph2_coord_latest_echo, future=org.apache.oozie.coord.CoordELFunctions#ph2_coord_future_echo &lt;/value&gt; &lt;description&gt; EL functions declarations, separated by commas, format is [PREFIX:]NAME=CLASS#METHOD. This property is a convenience property to add extensions to the built in executors without having to include all the built in ones. &lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.ELService.ext.functions.coord-action-create-inst&lt;/name&gt; &lt;value&gt; now=org.apache.oozie.extensions.OozieELExtensions#ph2_now_inst, today=org.apache.oozie.extensions.OozieELExtensions#ph2_today_inst, yesterday=org.apache.oozie.extensions.OozieELExtensions#ph2_yesterday_inst, currentWeek=org.apache.oozie.extensions.OozieELExtensions#ph2_currentWeek_inst, lastWeek=org.apache.oozie.extensions.OozieELExtensions#ph2_lastWeek_inst, currentMonth=org.apache.oozie.extensions.OozieELExtensions#ph2_currentMonth_inst, lastMonth=org.apache.oozie.extensions.OozieELExtensions#ph2_lastMonth_inst, currentYear=org.apache.oozie.extensions.OozieELExtensions#ph2_currentYear_inst, lastYear=org.apache.oozie.extensions.OozieELExtensions#ph2_lastYear_inst, latest=org.apache.oozie.coord.CoordELFunctions#ph2_coord_latest_echo, future=org.apache.oozie.coord.CoordELFunctions#ph2_coord_future_echo, formatTime=org.apache.oozie.coord.CoordELFunctions#ph2_coord_formatTime, user=org.apache.oozie.coord.CoordELFunctions#coord_user &lt;/value&gt; &lt;description&gt; EL functions declarations, separated by commas, format is [PREFIX:]NAME=CLASS#METHOD. This property is a convenience property to add extensions to the built in executors without having to include all the built in ones. &lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.ELService.ext.functions.coord-action-create&lt;/name&gt; &lt;value&gt; now=org.apache.oozie.extensions.OozieELExtensions#ph2_now, today=org.apache.oozie.extensions.OozieELExtensions#ph2_today, yesterday=org.apache.oozie.extensions.OozieELExtensions#ph2_yesterday, currentWeek=org.apache.oozie.extensions.OozieELExtensions#ph2_currentWeek, lastWeek=org.apache.oozie.extensions.OozieELExtensions#ph2_lastWeek, currentMonth=org.apache.oozie.extensions.OozieELExtensions#ph2_currentMonth, lastMonth=org.apache.oozie.extensions.OozieELExtensions#ph2_lastMonth, currentYear=org.apache.oozie.extensions.OozieELExtensions#ph2_currentYear, lastYear=org.apache.oozie.extensions.OozieELExtensions#ph2_lastYear, latest=org.apache.oozie.coord.CoordELFunctions#ph2_coord_latest_echo, future=org.apache.oozie.coord.CoordELFunctions#ph2_coord_future_echo, formatTime=org.apache.oozie.coord.CoordELFunctions#ph2_coord_formatTime, user=org.apache.oozie.coord.CoordELFunctions#coord_user &lt;/value&gt; &lt;description&gt; EL functions declarations, separated by commas, format is [PREFIX:]NAME=CLASS#METHOD. This property is a convenience property to add extensions to the built in executors without having to include all the built in ones. &lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.ELService.ext.functions.coord-job-submit-data&lt;/name&gt; &lt;value&gt; now=org.apache.oozie.extensions.OozieELExtensions#ph1_now_echo, today=org.apache.oozie.extensions.OozieELExtensions#ph1_today_echo, yesterday=org.apache.oozie.extensions.OozieELExtensions#ph1_yesterday_echo, currentWeek=org.apache.oozie.extensions.OozieELExtensions#ph1_currentWeek_echo, lastWeek=org.apache.oozie.extensions.OozieELExtensions#ph1_lastWeek_echo, currentMonth=org.apache.oozie.extensions.OozieELExtensions#ph1_currentMonth_echo, lastMonth=org.apache.oozie.extensions.OozieELExtensions#ph1_lastMonth_echo, currentYear=org.apache.oozie.extensions.OozieELExtensions#ph1_currentYear_echo, lastYear=org.apache.oozie.extensions.OozieELExtensions#ph1_lastYear_echo, dataIn=org.apache.oozie.extensions.OozieELExtensions#ph1_dataIn_echo, instanceTime=org.apache.oozie.coord.CoordELFunctions#ph1_coord_nominalTime_echo_wrap, formatTime=org.apache.oozie.coord.CoordELFunctions#ph1_coord_formatTime_echo, dateOffset=org.apache.oozie.coord.CoordELFunctions#ph1_coord_dateOffset_echo, user=org.apache.oozie.coord.CoordELFunctions#coord_user &lt;/value&gt; &lt;description&gt; EL constant declarations, separated by commas, format is [PREFIX:]NAME=CLASS#CONSTANT. This property is a convenience property to add extensions to the built in executors without having to include all the built in ones. &lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.ELService.ext.functions.coord-action-start&lt;/name&gt; &lt;value&gt; now=org.apache.oozie.extensions.OozieELExtensions#ph2_now, today=org.apache.oozie.extensions.OozieELExtensions#ph2_today, yesterday=org.apache.oozie.extensions.OozieELExtensions#ph2_yesterday, currentWeek=org.apache.oozie.extensions.OozieELExtensions#ph2_currentWeek, lastWeek=org.apache.oozie.extensions.OozieELExtensions#ph2_lastWeek, currentMonth=org.apache.oozie.extensions.OozieELExtensions#ph2_currentMonth, lastMonth=org.apache.oozie.extensions.OozieELExtensions#ph2_lastMonth, currentYear=org.apache.oozie.extensions.OozieELExtensions#ph2_currentYear, lastYear=org.apache.oozie.extensions.OozieELExtensions#ph2_lastYear, latest=org.apache.oozie.coord.CoordELFunctions#ph3_coord_latest, future=org.apache.oozie.coord.CoordELFunctions#ph3_coord_future, dataIn=org.apache.oozie.extensions.OozieELExtensions#ph3_dataIn, instanceTime=org.apache.oozie.coord.CoordELFunctions#ph3_coord_nominalTime, dateOffset=org.apache.oozie.coord.CoordELFunctions#ph3_coord_dateOffset, formatTime=org.apache.oozie.coord.CoordELFunctions#ph3_coord_formatTime, user=org.apache.oozie.coord.CoordELFunctions#coord_user &lt;/value&gt; &lt;description&gt; EL functions declarations, separated by commas, format is [PREFIX:]NAME=CLASS#METHOD. This property is a convenience property to add extensions to the built in executors without having to include all the built in ones. &lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.ELService.ext.functions.coord-sla-submit&lt;/name&gt; &lt;value&gt; instanceTime=org.apache.oozie.coord.CoordELFunctions#ph1_coord_nominalTime_echo_fixed, user=org.apache.oozie.coord.CoordELFunctions#coord_user &lt;/value&gt; &lt;description&gt; EL functions declarations, separated by commas, format is [PREFIX:]NAME=CLASS#METHOD. &lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.ELService.ext.functions.coord-sla-create&lt;/name&gt; &lt;value&gt; instanceTime=org.apache.oozie.coord.CoordELFunctions#ph2_coord_nominalTime, user=org.apache.oozie.coord.CoordELFunctions#coord_user &lt;/value&gt; &lt;description&gt; EL functions declarations, separated by commas, format is [PREFIX:]NAME=CLASS#METHOD. &lt;/description&gt; &lt;/property&gt; &lt;!-- Required to Notify Falcon on Workflow job status. --&gt; &lt;property&gt; &lt;name&gt;oozie.services.ext&lt;/name&gt; &lt;value&gt; org.apache.oozie.service.JMSAccessorService, org.apache.oozie.service.JMSTopicService, org.apache.oozie.service.EventHandlerService &lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.EventHandlerService.event.listeners&lt;/name&gt; &lt;value&gt; org.apache.oozie.jms.JMSJobEventListener &lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.jms.producer.connection.properties&lt;/name&gt; &lt;value&gt; java.naming.factory.initial#org.apache.activemq.jndi.ActiveMQInitialContextFactory;java.naming.provider.url#tcp://主机-1:61616 &lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.JMSTopicService.topic.name&lt;/name&gt; &lt;value&gt; WORKFLOW=ENTITY.TOPIC, COORDINATOR=ENTITY.TOPIC &lt;/value&gt; &lt;description&gt; Topic options are ${username} or a fixed string which can be specified as default or for a particular job type. For e.g To have a fixed string topic for workflows, coordinators and bundles, specify in the following comma-separated format: {jobtype1}={some_string1}, {jobtype2}={some_string2} where job type can be WORKFLOW, COORDINATOR or BUNDLE. Following example defines topic for workflow job, workflow action, coordinator job, coordinator action, bundle job and bundle action WORKFLOW=workflow, COORDINATOR=coordinator, BUNDLE=bundle For jobs with no defined topic, default topic will be ${username} &lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;oozie.service.JMSTopicService.topic.prefix&lt;/name&gt; &lt;value&gt;FALCON.&lt;/value&gt; &lt;description&gt; This can be used to append a prefix to the topic in oozie.service.JMSTopicService.topic.name. For eg: oozie. &lt;/description&gt; &lt;/property&gt; 操作说明 将$FALCON_HOME/oozie/conf/oozie-site.xml 的配置项内容添加到$OOZIE_HOME/conf/oozie-site.xml 中，其中将oozie 的jms消息连接项oozie.jms.producer.connection.properties里面的通讯地址改为oozie运行的节点，即主机-1。 3.3添加Falcon jar包至oozie库文件操作机器 在集群 namenode 节点 主机-1 上使用 hdfs 用户 操作指令 cd /var/local/hadoop/oozie-4.2.0 cp /var/local/hadoop/falcon-0.9/oozie/libext/*.jar libext/ 将falcon在oozie目录下的扩展jar包拷贝至$OOZIE_HOME/libext文件夹下 bin/oozie-stop.sh bin/oozie-setup.sh prepare-war bin/oozie-start.sh 重新部署并启动oozie 3.4Falcon client配置操作机器 在集群 namenode 节点 主机-1 上使用 hdfs 用户 操作指令 cd /var/local/hadoop/falcon-0.9 vim conf/client.properties 修改client.properties文件中falcon.url的值，将其改为 falcon.url=https://{主机-1}:{port}/ 操作说明 falcon.url指定了falcon server的ip地址，在本例中为主机-1的ip地址,port为falcon启动时配置的端口号，默认为15443. 3.5修改Falcon配置文件操作机器 在集群 namenode 节点 主机-1 上使用 hdfs 用户 操作指令 cd /var/local/hadoop/falcon-0.9 vim conf/startup.properties 将*.broker.url的值改动如下 *.broker.url=tcp/主机-1:61616 操作说明 *.broker.url为Falcon自带activemq消息发送地址，即Falcon运行所在的节点机器，在本例中为主机-1的ip地址。 3.6配置Falcon环境变量操作机器： 在主机-1，主机-2，主机-3上，使用hdfs用户，任意目录下 操作命令： sudo vim /etc/profile #主机-1,主机-2,主机-3在文件末尾，添加如下内容： export FALCON_HOME=/var/local/hadoop/falcon-0.9 export PATH=$PATH:$HADOOP_HOME/bin:$FALCON_HOME/bin 3.7刷新环境变量操作机器： 在主机-1,主机-2,主机-3上，使用当前终端，任意目录下 操作命令： source /etc/profile 3.8创建Falcon client操作机器 在集群 namenode 节点 主机-1 上使用 root用户 操作指令 useradd -U -m falcon-dashboard -G users groups falcon-dashboard 显示falcon-dashboard : falcon-dashboard users则创建成功 scp -r /var/local/hadoop/falcon-0.9 主机@主机-client:/home/主机/ 将falcon发送至client端 操作说明 传到client上需要输入client端主机用户的密码 3.9启动Falcon操作机器 在集群 namenode 节点 主机-1 上使用 hdfs 用户 操作指令 cd /var/local/hadoop/falcon-0.9 bin/falcon-start 启动Falcon server jps 显示java进程，如果列表中有Falconserver则启动成功 操作说明 用户可以在client端通过浏览器输入https://主机-1:15443进入falcon web端控制台。其中注意falcon server使用https协议，如果输入地址为http则显示出错。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java基础08、多态、抽象、接口]]></title>
      <url>%2F2016%2F12%2F28%2Fjava%E5%9F%BA%E7%A1%8008%E3%80%81%E5%A4%9A%E6%80%81%E3%80%81%E6%8A%BD%E8%B1%A1%E3%80%81%E6%8E%A5%E5%8F%A3%2F</url>
      <content type="text"><![CDATA[01_面向对象(多态的概述及其代码体现) A:多态(polymorphic)概述 事物存在的多种形态 B:多态前提 a:要有继承关系。 b:要有方法重写。 c:要有父类引用指向子类对象。 C:案例演示 代码体现多态 02_面向对象(多态中的成员访问特点之成员变量) 成员变量 编译看左边(父类)，运行看左边(父类)。 03_面向对象(多态中的成员访问特点之成员方法) 成员方法 编译看左边(父类)，运行看右边(子类)。【动态绑定】 04_面向对象(多态中的成员访问特点之静态成员方法) 静态方法 编译看左边(父类)，运行看左边(父类)。 (静态和类相关，算不上重写，所以，访问还是左边的) 只有非静态的成员方法,编译看左边,运行看右边 05_面向对象06_面向对象(多态中向上转型和向下转型) A:案例演示 详细讲解多态中向上转型和向下转型 Person p = new SuperMan();父类引用指向子类对象，向上转型 SuperMan sm = (SuperMan)p;子类引用指向父类对象，向下转型 07_面向对象(多态的好处和弊端) A:多态的好处 a:提高了代码的维护性(继承保证) b:提高了代码的扩展性(由多态保证) B:案例演示 多态的好处 可以当作形式参数,可以接收任意子类对象 C:多态的弊端 不能使用子类的特有属性和行为。 D:instanceof 判断前面的引用是否是后面的类型 if (animal instanceof Cat) { Cat c = (Cat)animal; c.eat; }else if ()... 08_面向对象(多态中的题目分析题) A:看下面程序是否有问题，如果没有，说出结果 class Fu { public void show() { System.out.println(&quot;fu show&quot;); } } class Zi extends Fu { public void show() { System.out.println(&quot;zi show&quot;); } public void method() { System.out.println(&quot;zi method&quot;); } } class Test1Demo { public static void main(String[] args) { Fu f = new Zi(); f.method();//这句有问题不能调用子类特有的方法 f.show(); } } B:看下面程序是否有问题，如果没有，说出结果 class A { public void show() { show2(); } public void show2() { System.out.println(&quot;我&quot;); } } class B extends A { public void show() { show2(); } public void show2() { System.out.println(&quot;爱&quot;); } } class C extends B { public void show() { super.show(); } public void show2() { System.out.println(&quot;你&quot;); } } public class Test2DuoTai { public static void main(String[] args) { A a = new B(); a.show(); B b = new C(); b.show(); } } *输出爱你，因为show方法可以继承下来，第二个因为调用父类show,而show方法调用show2调用的还是子类的show2,所以输出的是你。 09_面向对象(抽象类的概述及其特点) A:抽象类概述 抽象就是看不懂的 B:抽象类特点 a:抽象类和抽象方法必须用abstract关键字修饰 abstract class 类名 {} public abstract void eat(); b:抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口 c:抽象类不能实例化那么，抽象类如何实例化呢? 按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态。 d:抽象类的子类 要么是抽象类 要么重写抽象类中的所有抽象方法 10_面向对象(抽象类的成员特点) A:抽象类的成员特点 a:成员变量：既可以是变量，也可以是常量。abstract是否可以修饰成员变量?不能修饰成员变量 b:构造方法：有。 用于子类访问父类数据的初始化。 c:成员方法：既可以是抽象的，也可以是非抽象的。 B:案例演示 抽象类的成员特点 C:抽象类的成员方法特性： a:抽象方法 强制要求子类做的事情。 b:非抽象方法 子类继承的事情，提高代码复用性。 11_面向对象(葵花宝典)案例演示抽象类的作用 12_面向对象(抽象类练习猫狗案例) A:案例演示 具体事物：猫，狗 共性：姓名，年龄，吃饭 猫的特性:抓老鼠 狗的特性:看家 13_面向对象(抽象类练习老师案例) A:案例演示 具体事物：基础班老师，就业班老师 共性：姓名，年龄，讲课。 具体事物:基础班学生,就业班学生 共性:姓名,年龄,学习 14_面向对象(抽象类练习员工案例) A:案例演示 假如我们在开发一个系统时需要对程序员类进行设计，程序员包含3个属性：姓名、工号以及工资。 经理，除了含有程序员的属性外，另为还有一个奖金属性。 请使用继承的思想设计出程序员类和经理类。要求类中提供必要的方法进行属性访问。 15_面向对象(抽象类中的面试题) A:面试题1 一个抽象类如果没有抽象方法，可不可以定义为抽象类?如果可以，有什么意义? 可以 这么做目的只有一个,就是不让其他类创建本类对象,交给子类完成 B:面试题2 abstract不能和哪些关键字共存 16_面向对象(接口的概述及其特点) A:接口概述 从狭义的角度讲就是指java中的interface 从广义的角度讲对外提供规则的都是接口 B:接口特点 a:接口用关键字interface表示 interface 接口名 {} b:类实现接口用implements表示 class 类名 implements 接口名 {} c:接口不能实例化 那么，接口如何实例化呢? 按照多态的方式来实例化。 d:接口的子类 a:可以是抽象类。但是意义不大。 b:可以是具体类。要重写接口中的所有抽象方法。(推荐方案) C:案例演示 接口特点 17_面向对象(接口的成员特点) A:接口成员特点 成员变量；只能是常量，并且是静态的并公共的。 默认修饰符：public static final 建议：自己手动给出。 构造方法：接口没有构造方法。 成员方法：只能是抽象方法。 默认修饰符：public abstract 建议：自己手动给出。 18_面向对象(类与类,类与接口,接口与接口的关系) A:类与类,类与接口,接口与接口的关系 a:类与类： 继承关系,只能单继承,可以多层继承。 b:类与接口： 实现关系,可以单实现,也可以多实现。 并且还可以在继承一个类的同时实现多个接口。 c:接口与接口： 继承关系,可以单继承,也可以多继承。 B:案例演示 类与类,类与接口,接口与接口的关系 19_面向对象(抽象类和接口的区别) A:成员区别 抽象类： 成员变量：可以变量，也可以常量 构造方法：有 成员方法：可以抽象，也可以非抽象 接口： 成员变量：只可以常量 成员方法：只可以抽象 B:关系区别 类与类 继承，单继承 类与接口 实现，单实现，多实现 接口与接口 继承，单继承，多继承 C:设计理念区别 抽象类 被继承体现的是：”is a”的关系。抽象类中定义的是该继承体系的共性功能。 接口 被实现体现的是：”like a”的关系。接口中定义的是该继承体系的扩展功能。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java语言基础07、代码块、继承、方法重写、this、super、final]]></title>
      <url>%2F2016%2F11%2F23%2Fjava%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8007%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E3%80%81this%E3%80%81super%E3%80%81final%2F</url>
      <content type="text"><![CDATA[01_面向对象(代码块的概述和分类)(了解)(面试的时候会问,开发不用或者很少用) A:代码块概述 在Java中，使用{}括起来的代码被称为代码块。 B:代码块分类 根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。 C:常见代码块的应用 a:局部代码块 在方法中出现；限定变量生命周期，及早释放，提高内存利用率 b:构造代码块 (初始化块) 在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行 c:静态代码块 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，优先于main方法，并且只执行一次。 一般用于加载驱动 02_面向对象(代码块的面试题)(掌握) A:看程序写结果 class Student { static { System.out.println(&quot;Student 静态代码块&quot;); } { System.out.println(&quot;Student 构造代码块&quot;); } public Student() { System.out.println(&quot;Student 构造方法&quot;); } } class Demo2_Student { static { System.out.println(&quot;Demo2_Student静态代码块&quot;); } public static void main(String[] args) { System.out.println(&quot;我是main方法&quot;); Student s1 = new Student(); Student s2 = new Student(); } } 03_面向对象(继承案例演示)(掌握) A:继承(extends) 让类与类之间产生关系,子父类关系 B:继承案例演示： 动物类,猫类,狗类 定义两个属性(颜色,腿的个数)两个功能(吃饭，睡觉) C:案例演示 使用继承前 D:案例演示 使用继承后 04_面向对象(继承的好处和弊端)(掌握) A:继承的好处 a:提高了代码的复用性 b:提高了代码的维护性 c:让类与类之间产生了关系，是多态的前提 B:继承的弊端 类的耦合性增强了。 开发的原则：高内聚，低耦合。 耦合：类与类的关系 内聚：就是自己完成某件事情的能力 05_面向对象(Java中类的继承特点)(掌握) A:Java中类的继承特点 a:Java只支持单继承，不支持多继承。(一个儿子只能有一个爹) 有些语言是支持多继承，格式：extends 类1,类2,… b:Java支持多层继承(继承体系) B:案例演示 Java中类的继承特点 如果想用这个体系的所有功能用最底层的类创建对象 如果想看这个体系的共性功能,看最顶层的类 06_面向对象(继承的注意事项和什么时候使用继承)(掌握) A:继承的注意事项 a:子类只能继承父类所有非私有的成员(成员方法和成员变量) b:子类不能继承父类的构造方法，但是可以通过super(马上讲)关键字去访问父类构造方法。 c:不要为了部分功能而去继承 项目经理 姓名 工号 工资 奖金 程序员 姓名 工号 工资 B:什么时候使用继承 继承其实体现的是一种关系：”is a”。 Person Student Teacher 水果 苹果 香蕉 橘子 采用假设法。 如果有两个类A,B。只有他们符合A是B的一种，或者B是A的一种，就可以考虑使用继承。 07_面向对象(继承中成员变量的关系)(掌握) A:案例演示 a:不同名的变量 b:同名的变量08_面向对象(this和super的区别和应用)(掌握) A:this和super都代表什么 this:代表当前对象的引用,谁来调用我,我就代表谁 super:代表当前对象父类的引用 B:this和super的使用区别 a:调用成员变量 this.成员变量 调用本类的成员变量,也可以调用父类的成员变量 super.成员变量 调用父类的成员变量 b:调用构造方法 this(…) 调用本类的构造方法 super(…) 调用父类的构造方法 c:调用成员方法 this.成员方法 调用本类的成员方法,也可以调用父类的方法 super.成员方法 调用父类的成员方法 09_面向对象(继承中构造方法的关系)(掌握) A:案例演示 子类中所有的构造方法默认都会访问父类中空参数的构造方法 B:为什么呢? 因为子类会继承父类中的数据，可能还会使用父类的数据。 所以，子类初始化之前，一定要先完成父类数据的初始化。 其实： 每一个构造方法的第一条语句默认都是：super() Object类最顶层的父类。 10_面向对象(继承中构造方法的注意事项)(掌握) A:案例演示 父类没有无参构造方法,子类怎么办? super解决 this解决 B:注意事项 super(…)或者this(….)必须出现在构造方法的第一条语句上 11_面向对象(继承中的面试题)(掌握) A:案例演示 看程序写结果1class Fu{ public int num = 10; public Fu(){ System.out.println(&quot;fu&quot;); }}class Zi extends Fu{ public int num = 20; public Zi(){ System.out.println(&quot;zi&quot;); } public void show(){ int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(super.num); }}class Test1_Extends { public static void main(String[] args) { Zi z = new Zi(); z.show(); }} 看程序写结果2class Fu { static { System.out.println(&quot;静态代码块Fu&quot;); } { System.out.println(&quot;构造代码块Fu&quot;); } public Fu() { System.out.println(&quot;构造方法Fu&quot;); }} class Zi extends Fu { static { System.out.println(&quot;静态代码块Zi&quot;); } { System.out.println(&quot;构造代码块Zi&quot;); } public Zi() { System.out.println(&quot;构造方法Zi&quot;); }} Zi z = new Zi(); 请执行结果。 12_面向对象(继承中成员方法关系)(掌握) A:案例演示 a:不同名的方法 b:同名的方法 13_面向对象(方法重写概述及其应用)(掌握) A:什么是方法重写 重写:子父类出现了一模一样的方法(注意:返回值类型可以是子父类,这个我们学完面向对象讲) B:方法重写的应用： 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。 C:案例演示 a:定义一个手机类。 14_面向对象(方法重写的注意事项)(掌握) A:方法重写注意事项 a:父类中私有方法不能被重写 因为父类私有方法子类根本就无法继承 b:子类重写父类方法时，访问权限不能更低 最好就一致 c:父类静态方法，子类也必须通过静态方法进行重写 其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解(静态只能覆盖静态) 子类重写父类方法的时候，最好声明一模一样。 B:案例演示 方法重写注意事项 15_面向对象(方法重写的面试题)(掌握) A:方法重写的面试题 Override和Overload的区别?Overload能改变返回值类型吗? overload可以改变返回值类型,只看参数列表 方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的 方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。 子类对象调用方法的时候： 先找子类本身，再找父类。 16_面向对象(使用继承前的学生和老师案例)(掌握) A:案例演示 使用继承前的学生和老师案例 属性:姓名,年龄 行为:吃饭 老师有特有的方法:讲课 学生有特有的方法:学习 17_面向对象(使用继承后的学生和老师案例)(掌握) A:案例演示 使用继承后的学生和老师案例 18_面向对象(猫狗案例分析,实现及测试)(掌握) A:猫狗案例分析 B:案例演示 猫狗案例继承版 属性:毛的颜色,腿的个数 行为:吃饭 猫特有行为:抓老鼠catchMouse 狗特有行为:看家lookHome 19_面向对象(final关键字修饰类,方法以及变量的特点)(掌握) A:final概述 B:final修饰特点 修饰类，类不能被继承 修饰变量，变量就变成了常量，只能被赋值一次 修饰方法，方法不能被重写 C:案例演示 final修饰特点 20_面向对象(final关键字修饰局部变量)(掌握) A:案例演示 方法内部或者方法声明上都演示一下(了解) 基本类型，是值不能被改变 引用类型，是地址值不能被改变,对象中的属性可以改变 21_面向对象(final修饰变量的初始化时机)(掌握) A:final修饰变量的初始化时机 显示初始化 在对象构造完毕前即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java语言基础06、构造方法、方法重载、static相关]]></title>
      <url>%2F2016%2F11%2F22%2Fjava%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8006%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E3%80%81static%E7%9B%B8%E5%85%B3%2F</url>
      <content type="text"><![CDATA[01_面向对象(构造方法Constructor概述和格式)(掌握) A:构造方法概述和作用 给对象的数据(属性)进行初始化 B:构造方法格式特点 a:方法名与类名相同(大小也要与类名一致) b:没有返回值类型，连void都没有 c:没有具体的返回值return; 02_面向对象(构造方法的重载及注意事项)(掌握) A:案例演示 构造方法的重载 重载:方法名相同,与返回值类型无关(构造方法没有返回值),只看参数列表 B:构造方法注意事项 a:如果我们没有给出构造方法，系统将自动提供一个无参构造方法。 b:如果我们给出了构造方法，系统将不再提供默认的无参构造方法。 注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法 03_面向对象(给成员变量赋值的两种方式的区别) A:setXxx()方法 修改属性值 B:构造方法 给对象中属性进行初始化 04_面向对象(学生类的代码及测试)(掌握) A:案例演示 学生类： 成员变量： name，age 构造方法： 无参，带两个参 成员方法： getXxx()/setXxx() show()：输出该类的所有成员变量值 B:给成员变量赋值： a:setXxx()方法 b:构造方法 C:输出成员变量值的方式： a:通过getXxx()分别获取然后拼接 b:通过调用show()方法搞定 05_面向对象(手机类的代码及测试)(掌握) A:案例演示 模仿学生类，完成手机类代码 06_面向对象(创建一个对象的步骤)(掌握) A:画图演示 画图说明一个对象的创建过程做了哪些事情? Student s = new Student(); 1,Student.class加载进内存 2,声明一个Student类型引用s 3,在堆内存创建对象, 4,给对象中属性默认初始化值 5,属性进行显示初始化 6,构造方法进栈,对对象中的属性赋值,构造方法弹栈 7,将对象的地址值赋值给s 07_面向对象(长方形案例练习)(掌握) A:案例演示 需求： 定义一个长方形类,定义 求周长和面积的方法， 然后定义一个测试类进行测试。 08_面向对象(员工类案例练习)(掌握) A:案例演示 需求：定义一个员工类Employee 自己分析出几个成员，然后给出成员变量 姓名name,工号id,工资salary 构造方法， 空参和有参的 getXxx()setXxx()方法， 以及一个显示所有成员信息的方法。并测试。 work 09_面向对象(static关键字及内存图)(了解) A:案例演示 通过一个案例引入static关键字。（放在方法区，可以多个对象共用一个，堆中不会创建static变量） 人类：Person。每个人都有国籍，中国。 非静态方法必须创建对象才能调用（比较关键） B:画图演示 带有static的内存图 10_面向对象(static关键字的特点)(掌握) A:static关键字的特点 a:随着类的加载而加载 b:优先于对象存在 c:被类的所有对象共享 举例：咱们班级的学生应该共用同一个班级编号。 其实这个特点也是在告诉我们什么时候使用静态? 如果某个成员变量是被所有对象共享的，那么它就应该定义为静态的。 举例： 饮水机(用静态修饰) 水杯(不能用静态修饰) 共性用静态,特性用非静态 d:可以通过类名调用 其实它本身也可以通过对象名调用。 推荐使用类名调用。 静态修饰的内容一般我们称其为：与类相关的，类成员 B:案例演示 static关键字的特点 11_面向对象(static的注意事项)(掌握) A:static的注意事项 a:在静态方法中是没有this关键字的 如何理解呢? 静态是随着类的加载而加载，this是随着对象的创建而存在。 静态比对象先存在。 b:静态方法只能访问静态的成员变量和静态的成员方法 静态方法： 成员变量：只能访问静态变量 成员方法：只能访问静态成员方法 非静态方法： 成员变量：可以是静态的，也可以是非静态的 成员方法：可是是静态的成员方法，也可以是非静态的成员方法。 简单记： 静态只能访问静态。 B:案例演示 static的注意事项 12_面向对象(静态变量和成员变量的区别)(掌握) 静态变量也叫类变量 成员变量也叫对象变量 A:所属不同 静态变量属于类，所以也称为为类变量 成员变量属于对象，所以也称为实例变量(对象变量) B:内存中位置不同 静态变量存储于方法区的静态区 成员变量存储于堆内存 C:内存出现时间不同 静态变量随着类的加载而加载，随着类的消失而消失 成员变量随着对象的创建而存在，随着对象的消失而消失 D:调用不同 静态变量可以通过类名调用，也可以通过对象调用 成员变量只能通过对 象名调用 13_面向对象(main方法的格式详细解释)(了解) A:格式 public static void main(String[] args) {} B:针对格式的解释 public 被jvm调用，访问权限足够大。 static 被jvm调用，不用创建对象，直接类名访问 void被jvm调用，不需要给jvm返回值 main 一个通用的名称，虽然不是关键字，但是被jvm识别 String[] args 以前用于接收键盘录入的 C:演示案例 通过args接收键盘例如数据 14_面向对象(工具类中使用静态)(了解) A:制作一个工具类 ArrayTool 1,获取最大值 2,数组的遍历 3,数组的反转 如果一个类中方法都是静态那要多家一步，创建静态构造函数，目的不让其他类创建本类对象 15_面向对象(说明书的制作过程)(了解) A:对工具类加入文档注释 B:通过javadoc命令生成说明书 @author(提取作者内容) @version(提取版本内容) javadoc -d 指定的文件目录 -author -version ArrayTool.java @param 参数名称//形式参数的变量名称@return 函数运行完返回的数据 16_面向对象(如何使用JDK提供的帮助文档)(了解) A:找到文档，打开文档 B:点击显示，找到索引，出现输入框 C:你应该知道你找谁?举例：Scanner D:看这个类的结构(需不需要导包) 成员变量 字段 构造方法 构造方法 成员方法 方法 17_面向对象(学习Math类的随机数功能)(了解) 打开JDK提供的帮助文档学习 A:Math类概述 类包含用于执行基本数学运算的方法 B:Math类特点 由于Math类在java.lang包下，所以不需要导包。 因为它的成员全部是静态的,所以私有了构造方法 C:获取随机数的方法 public static double random():返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。 D:我要获取一个1-100之间的随机数，肿么办? int number = (int)(Math.random()*100)+1; 18_面向对象(猜数字小游戏案例)(了解) A:案例演示 需求：猜数字小游戏(数据在1-100之间)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java语言基础05、面向对象概念、对象相关、this简单介绍]]></title>
      <url>%2F2016%2F11%2F21%2Fjava%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8005%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E3%80%81this%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[01_面向对象(面向对象思想概述)(了解) A:面向过程思想概述 第一步 第二步 B:面向对象思想概述 找对象(第一步,第二步) C:举例 买煎饼果子 洗衣服 D:面向对象思想特点 a:是一种更符合我们思想习惯的思想 b:可以将复杂的事情简单化 c:将我们从执行者变成了指挥者 角色发生了转换 E:面向对象开发 就是不断的创建对象，使用对象，指挥对象做事情。 F:面向对象设计 其实就是在管理和维护对象之间的关系。 G:面向对象特征 封装(encapsulation) 继承(inheritance) 多态(polymorphism) 02_面向对象(类与对象概述)(掌握) A:我们学习编程是为了什么 为了把我们日常生活中实物用学习语言描述出来 B:我们如何描述现实世界事物 属性 就是该事物的描述信息(事物身上的名词) 行为 就是该事物能够做什么(事物身上的动词) C:Java中最基本的单位是类,Java中用class描述事物也是如此 成员变量 就是事物的属性 成员方法 就是事物的行为 D:定义类其实就是定义类的成员(成员变量和成员方法) a:成员变量 和以前定义变量是一样的，只不过位置发生了改变。在类中，方法外。 b:成员方法 和以前定义方法是一样的，只不过把static去掉，后面在详细讲解static的作用。 E:类和对象的概念 a:类：是一组相关的属性和行为的集合 b:对象：是该类事物的具体体现 c:举例： 类 学生 对象 具体的某个学生就是一个对象 03_面向对象(学生类的定义)(掌握) A:学生事物 B:学生类 C:案例演示 属性:姓名,年龄,性别 行为:学习,睡觉 04_面向对象(手机类的定义)(掌握) 模仿学生类，让学生自己完成 属性:品牌(brand)价格(price) 行为:打电话(call),发信息(sendMessage)玩游戏(playGame) 05_面向对象(学生类的使用)(掌握) A:文件名问题 在一个java文件中写两个类：一个基本的类，一个测试类。 建议：文件名称和测试类名称一致。 B:如何使用对象? 创建对象并使用 格式：类名 对象名 = new 类名(); D:如何使用成员变量呢? 对象名.变量名 E:如何使用成员方法呢? 对象名.方法名(…) 06_面向对象(手机类的使用)(掌握) A:学生自己完成 模仿学生类，让学生自己完成 07_面向对象(一个对象的内存图)(掌握) A:画图演示 一个对象 08_面向对象(二个对象的内存图)(了解) A:画图演示 二个不同的对象 09_面向对象(三个引用两个对象的内存图)(了解) A:画图演示 三个引用，有两个对象的引用指向同一个地址 10_面向对象(成员变量和局部变量的区别)(掌握) A:在类中的位置不同 成员变量：在类中方法外 局部变量：在方法定义中或者方法声明上 B:在内存中的位置不同 成员变量：在堆内存(成员变量属于对象,对象进堆内存) 局部变量：在栈内存(局部变量属于方法,方法进栈内存) C:生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 D:初始化值不同 成员变量：有默认初始化值 局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。 注意事项： 局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。 基本数据类型变量包括哪些:byte,short,int,long,float,double,boolean,char 引用数据类型变量包括哪些:数组,类,接口,枚举 11_面向对象(方法的形式参数是类名的时候如何调用)(掌握) A:方法的参数是类名public void print(Student s){}//print(new Student()); 如果你看到了一个方法的形式参数是一个类类型(引用类型)，这里其实需要的是该类的对象。 12_面向对象(匿名对象的概述和应用)(掌握) A:什么是匿名对象 没有名字的对象 B:匿名对象应用场景 a:调用方法，仅仅只调用一次的时候。 那么，这种匿名调用有什么好处吗? 节省代码 注意：调用多次的时候，不适合。匿名对象调用完毕就是垃圾。可以被垃圾回收器回收。 b:匿名对象可以作为实际参数传递 C:案例演示 匿名对象应用场景 13_面向对象(封装的概述)(掌握) A:封装概述 是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。 B:封装好处 隐藏实现细节，提供公共的访问方式 提高了代码的复用性 提高安全性。 C:封装原则 将不需要对外提供的内容都隐藏起来。 把属性隐藏，提供公共方法对其访问。 14_面向对象(private关键字的概述和特点)(掌握) A:人类赋值年龄的问题 B:private关键字特点 a:是一个权限修饰符 b:可以修饰成员变量和成员方法 c:被其修饰的成员只能在本类中被访问 C:案例演示 封装和private的应用： A:把成员变量用private修饰 B:提供对应的getXxx()和setXxx()方法 private仅仅是封装的一种体现形式,不能说封装就是私有 15_面向对象(this关键字的概述和应用)(掌握) A:this关键字特点 代表当前对象的引用 B:案例演示 this的应用场景 用来区分成员变量和局部变量重名 16_面向对象(手机类代码及其测试)(掌握) A:学生练习 请把手机类写成一个标准类，然后创建对象测试功能。 class Demo2_Phone { public static void main(String[] args) { Phone p1 = new Phone(); p1.setBrand(&quot;三星&quot;); p1.setPrice(5288); System.out.println(p1.getBrand() + &quot;...&quot; + p1.getPrice()); p1.call(); p1.sendMessage(); p1.playGame(); } } /* 手机类 属性:品牌brand,价格price 行为:打电话call,发短信sendMessage,玩游戏,playGame */ class Phone { //java bean private String brand; //品牌 private int price; //价格 public void setBrand(String brand) { //设置品牌 this.brand = brand; } public String getBrand() { //获取品牌 return this.brand; //this.可以省略,你不加系统会默认给你加 } public void setPrice(int price) { //设置价格 this.price = price; } public int getPrice() { //获取价格 return price; } public void call() { //打电话 System.out.println(&quot;打电话&quot;); } public void sendMessage() { //发短信 System.out.println(&quot;发短信&quot;); } public void playGame() { //玩游戏 System.out.println(&quot;玩游戏&quot;); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java语言基础04、数组、内存分配堆与栈、数组的操作、java中参数的传递]]></title>
      <url>%2F2016%2F11%2F10%2Fjava%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8004%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%A0%86%E4%B8%8E%E6%A0%88%E3%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%81java%E4%B8%AD%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%2F</url>
      <content type="text"><![CDATA[01(数组概述和定义格式说明)(了解) A:为什么要有数组(容器) 为了存储同种数据类型的多个值 B:数组概念 数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。 数组既可以存储基本数据类型，也可以存储引用数据类型。 C:数组定义格式 数据类型[] 数组名 = new 数据类型[数组的长度];02(数组的初始化动态初始化)(掌握) A:什么是数组的初始化 就是为数组开辟连续的内存空间，并为每个数组元素赋予值 B:如何对数组进行初始化 a:动态初始化 只指定长度，由系统给出初始化值 int[] arr = new int[5]; b:静态初始化 给出初始化值，由系统决定长度 C:动态初始化的格式： 数据类型[] 数组名 = new 数据类型[数组长度]; D:案例演示 输出数组名称和数组元素 03(Java中的内存分配以及栈和堆的区别) A:栈(掌握) 存储局部变量 B:堆(掌握) 存储new出来的数组或对象 C:方法区 面向对象部分讲解，简单来说代码区 D:本地方法区 和系统相关 E:寄存器 给CPU使用04(数组的内存图解1一个数组)(掌握) A:画图演示 一个数组 05(数组的内存图解2二个数组)(了解) A:画图演示 二个不同的数组 06(数组的内存图解3三个引用两个数组)(了解) A:画图演示 三个引用，有两个数组的引用指向同一个地址 07(数组的初始化静态初始化及内存图)(掌握) A:静态初始化的格式： 格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…}; 简化格式： 数据类型[] 数组名 = {元素1,元素2,…}; B:案例演示 对数组的解释 输出数组名称和数组元素 C:画图演示 一个数组 08(数组操作的两个常见小问题越界和空指针)(掌握) A:案例演示 a:ArrayIndexOutOfBoundsException:数组索引越界异常 原因：你访问了不存在的索引。 b:NullPointerException:空指针异常 原因：数组已经不在指向堆内存了。而你还用数组名去访问元素。 int[] arr = {1,2,3}; arr = null; System.out.println(arr[0]); 09(数组的操作1遍历)(掌握) A:案例演示 数组遍历：就是依次输出数组中的每一个元素。 数组的属性:arr.length数组的长度 数组的最大索引:arr.length - 1; public static void print(int[] arr) { for (int i = 0;i &lt; arr.length ;i++ ) { System.out.print(arr[i] + &quot; &quot;); } } 10(数组的操作2获取最值)(掌握) A:案例演示 数组获取最值(获取数组中的最大值最小值) public static int getMax(int[] arr) { int max = arr[0]; for (int i = 1;i &lt; arr.length ;i++ ) { //从数组的第二个元素开始遍历 if (max &lt; arr[i]) { //如果max记录的值小于的数组中的元素 max = arr[i]; //max记录住较大的 } } return max; } 11(数组的操作3反转)(掌握) A:案例演示 数组元素反转(就是把元素对调) public static void reverseArray(int[] arr) { for (int i = 0;i &lt; arr.length / 2 ; i++) { //arr[0]和arr[arr.length-1-0]交换 //arr[1]和arr[arr.length-1-1]交换 //arr[2]和arr[arr.lentth-1-2] //... int temp = arr[i]; arr[i] = arr[arr.length-1-i]; arr[arr.length-1-i] = temp; } } 12(数组的操作4查表法)(掌握) A:案例演示 数组查表法(根据键盘录入索引,查找对应星期) public static char getWeek(int week) { char[] arr = {&apos; &apos;,&apos;一&apos;,&apos;二&apos;,&apos;三&apos;,&apos;四&apos;,&apos;五&apos;,&apos;六&apos;,&apos;日&apos;}; //定义了一张星期表 return arr[week]; //通过索引获取表中的元素 } 13(数组的操作5基本查找)(掌握) A:案例演示 数组元素查找(查找指定元素第一次在数组中出现的索引) public static int getIndex(int[] arr,int value) { for (int i = 0;i &lt; arr.length ;i++ ) { //数组的遍历 if (arr[i] == value) { //如果数组中的元素与查找的元素匹配 return i; } } return -1; } 14(二维数组概述和格式1的讲解)(了解) A:二维数组概述 B:二维数组格式1 int[][] arr = new int[3][2]; C:二维数组格式1的解释 D:注意事项 a:以下格式也可以表示二维数组 1:数据类型 数组名[][] = new 数据类型[m][n]; 2:数据类型[] 数组名[] = new 数据类型[m][n]; B:注意下面定义的区别 int x; int y; int x,y; int[] x; int[] y[]; int[] x,y[]; x是一维数组,y是二维数组 E:案例演示 定义二维数组，输出二维数组名称，一维数组名称，一个元素 15(二维数组格式1的内存图解)(了解) A:画图演示 画图讲解上面的二维数组名称，一维数组名称，一个元素的值的问题16(二维数组格式2的讲解及其内存图解)(了解) A:二维数组格式2 int[][] arr = new int[3][]; arr[0] = new int[3]; arr[1] = new int[5]; B:二维数组格式2的解释 C:案例演示 讲解格式，输出数据，并画内存图 D:格式3（可看做17项） 1* int[][] arr = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8,9&#125;&#125;; 18(二维数组练习1遍历)(掌握) A:案例演示 需求：二维数组遍历 外循环控制的是二维数组的长度，其实就是一维数组的个数。 内循环控制的是一维数组的长度。 int[][] arr = {{1,2,3},{4,5},{6,7,8,9}}; for (int i = 0;i &lt; arr.length ;i++ ) { //获取到每个二维数组中的一维数组 for (int j = 0;j &lt; arr[i].length ;j++ ) { //获取每个一维数组中的元素 System.out.print(arr[i][j] + &quot; &quot;); } System.out.println(); } 19(二维数组练习2求和)(掌握) A:案例演示 需求：公司年销售额求和 某公司按照季度和月份统计的数据如下：单位(万元) 第一季度：22,66,44 第二季度：77,33,88 第三季度：25,45,65 第四季度：11,66,99 int[][] arr = {{22,66,44},{77,33,88},{25,45,65},{11,66,99}}; int sum = 0; //定义变量,记录每次相加的结果 for (int i = 0;i &lt; arr.length ;i++ ) { //获取每一个一维数组 for (int j = 0;j &lt; arr[i].length ;j++ ) { //获取每一个一维数组中的元素 sum = sum + arr[i][j]; //累加 } } System.out.println(sum); 20(思考题Java中的参数传递问题及图解)(掌握) A:案例演示 看程序写结果，并画内存图解释 public static void main(String[] args) { int a = 10; int b = 20; System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); change(a,b); System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); int[] arr = {1,2,3,4,5}; change(arr); System.out.println(arr[1]); } public static void change(int a,int b) { System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); a = b; b = a + b; System.out.println(&quot;a:&quot;+a+&quot;,b:&quot;+b); } public static void change(int[] arr) { for(int x=0; x&lt;arr.length; x++) { if(arr[x]%2==0) { arr[x]*=2; } } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java基础03、循环语句、控制跳转语句、方法、方法重载]]></title>
      <url>%2F2016%2F11%2F08%2Fjava%E5%9F%BA%E7%A1%8003%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E3%80%81%E6%8E%A7%E5%88%B6%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[01(循环结构概述和for语句的格式及其使用) A:循环结构的分类 for,while,do…while B:循环结构for语句的格式： for(初始化表达式;条件表达式;循环后的操作表达式) { 循环体; } C执行流程： a:执行初始化语句 b:执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 c:执行循环体语句; d:执行循环后的操作表达式 e:回到B继续。 D:案例演示 在控制台输出10次”helloworld” 02(循环结构for语句的练习之获取数据) A:案例演示 需求：请在控制台输出数据1-10 需求：请在控制台输出数据10-1 B:注意事项 a:判断条件语句无论简单还是复杂结果是boolean类型。 b:循环体语句如果是一条语句，大括号可以省略；如果是多条语句，大括号不能省略。建议永远不要省略。 c:一般来说：有左大括号就没有分号，有分号就没有左大括号 03(循环结构for语句的练习之求和思想) A:案例演示 需求：求出1-10之间数据之和 B:学生练习 需求：求出1-100之间偶数和 需求：求出1-100之间奇数和 04(循环结构for语句的练习之水仙花) A:案例演示 需求：在控制台输出所有的”水仙花数” 所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。 举例：153就是一个水仙花数。 153 = 111 + 555 + 333 = 1 + 125 + 27 = 153 05(循环结构for语句的练习之统计思想) A:案例演示 需求：统计”水仙花数”共有多少个 06(循环结构while语句的格式和基本使用) A:循环结构while语句的格式： while循环的基本格式：while(判断条件语句) { 循环体语句;} 完整格式： 初始化语句;while(判断条件语句) { 循环体语句; 控制条件语句;} B:执行流程： a:执行初始化语句 b:执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 c:执行循环体语句; d:执行控制条件语句 e:回到B继续。 C:案例演示 需求：请在控制台输出数据1-10 07(循环结构while语句的练习) A:求和思想 求1-100之和 B:统计思想 统计”水仙花数”共有多少个 08(循环结构do…while语句的格式和基本使用) A:循环结构do…while语句的格式： do { 循环体语句; }while(判断条件语句); 完整格式； 初始化语句; do { 循环体语句; 控制条件语句; }while(判断条件语句); B:执行流程： a:执行初始化语句 b:执行循环体语句; c:执行控制条件语句 d:执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 e:回到b继续。 C:案例演示 需求：请在控制台输出数据1-10 09(循环结构三种循环语句的区别) A:案例演示 三种循环语句的区别: do…while循环至少执行一次循环体。 而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句。 B:案例演示 for循环和while循环的区别： A:如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。不知道用谁就用for循环。因为变量及早的从内存中消失，可以提高内存的使用效率。 10(循环结构注意事项之死循环) A:一定要注意控制条件语句控制的那个变量的问题，不要弄丢了，否则就容易死循环。 B:两种最简单的死循环格式 while(true){…} for(;;){…} 11(循环结构循环嵌套输出4行5列的星星) A:案例演示 需求：请输出一个4行5列的星星(*)图案。 如图： ***** ***** ***** ***** 注意： System.out.println(&quot;*&quot;);和System.out.print(&quot;*&quot;);的区别 B:结论： 外循环控制行数，内循环控制列数 12(循环结构循环嵌套输出正三角形) A:案例演示 需求：请输出下列的形状 * ** *** **** ***** 13(循环结构九九乘法表) A:案例演示 需求：在控制台输出九九乘法表。 B:代码优化 注意： &apos;\x&apos; x表示任意，\是转义符号,这种做法叫转移字符。 &apos;\t&apos; tab键的位置 &apos;\r&apos; 回车 &apos;\n&apos; 换行 &apos;\&quot;&apos; &apos;\&apos;&apos; 14(控制跳转语句break语句) A:break的使用场景 只能在switch和循环中 15(控制跳转语句continue语句) A:continue的使用场景 只能在循环中 16(控制跳转语句标号) 标号:标记某个循环对其控制 标号组成规则:其实就是合法的标识符 17(控制调整语句练习) A:练习题 for(int x=1; x&lt;=10; x++) { if(x%3==0) { //在此处填写代码 } System.out.println(“Java基础班”); } 我想在控制台输出2次:“Java基础班“ 我想在控制台输出7次:“Java基础班“ 我想在控制台输出13次:“Java基础班“ 18(控制跳转语句return语句) A:return的作用 返回 其实它的作用不是结束循环的，而是结束方法的。 B:案例演示 return和break以及continue的区别? return是结束方法 break是跳出循环 continue是终止本次循环继续下次循环 19(方法概述和格式说明) A:为什么要有方法 提高代码的复用性 B:什么是方法 完成特定功能的代码块。 C:方法的格式 修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) { 方法体语句; return 返回值; } D:方法的格式说明 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。 返回值类型：就是功能结果的数据类型。 方法名：符合命名规则即可。方便我们的调用。 参数： 实际参数：就是实际参与运算的。 形式参数；就是方法定义上的，用于接收实际参数的。 参数类型：就是参数的数据类型 参数名：就是变量名 方法体语句：就是完成功能的代码。 return：结束方法的。 返回值：就是功能的结果，由return带给调用者。 20(方法之求和案例及其调用) A:如何写一个方法 1,明确返回值类型 2,明确参数列表 B:案例演示 需求：求两个数据之和的案例 C:方法调用图解 21(方法的注意事项) A:方法调用(有具体返回值的方法) a:单独调用,一般来说没有意义，所以不推荐。 b:输出调用,但是不够好。因为我们可能需要针对结果进行进一步的操作。 c:赋值调用,推荐方案。 B:案例演示 a:方法不调用不执行 b:方法与方法是平级关系，不能嵌套定义 c:方法定义的时候参数之间用逗号隔开 d:方法调用的时候不用在传递数据类型 e:如果方法有明确的返回值，一定要有return带回一个值 22(方法的练习) A:案例演示 需求：键盘录入两个数据，返回两个数中的较大值 B:案例演示 需求：键盘录入两个数据，比较两个数是否相等 23(方法之输出星形及其调用) A:案例演示 需求：根据键盘录入的行数和列数，在控制台输出星形 B:方法调用：(无返回值,void) 单独调用 输出调用(错误) 赋值调用(错误) 24(方法的练习) A:案例演示 需求：根据键盘录入的数据输出对应的乘法表 25(方法重载概述和基本使用) A:方法重载概述 求和案例 2个整数 3个整数 4个整数 B:方法重载： 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。 参数列表不同： A:参数个数不同 B:参数类型不同 C:参数的顺序不同(算重载,但是在开发中不用) 26(方法重载练习比较数据是否相等) A:案例演示 需求：比较两个数据是否相等。 参数类型分别为两个int类型，两个double类型，并在main方法中进行测试]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java语言基础02、逻辑运算符、位运算符、三元运算符、键盘录入、if、switch]]></title>
      <url>%2F2016%2F11%2F08%2Fjava%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8002%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5%E3%80%81if%E3%80%81switch%2F</url>
      <content type="text"><![CDATA[01 (逻辑运算符的基本用法)(掌握) A:逻辑运算符有哪些 &amp;,|,^,! &amp;&amp;,|| B:案例演示 逻辑运算符的基本用法 注意事项： a:逻辑运算符一般用于连接boolean类型的表达式或者值。 b:表达式：就是用运算符把常量或者变量连接起来的符合java语法的式子。 算术表达式：a + b 比较表达式：a == b(条件表达式) C:结论： &amp;逻辑与:有false则false。 |逻辑或:有true则true。 ^逻辑异或:相同为false，不同为true。 !逻辑非:非false则true，非true则false。 特点：偶数个不改变本身。 02 (逻辑运算符&amp;&amp;和&amp;的区别)(掌握) A:案例演示 &amp;&amp;和&amp;的区别? a:最终结果一样。 b:&amp;&amp;具有短路效果。左边是false，右边不执行。 &amp;是无论左边是false还是true,右边都会执行 例子 B:同理||和|的区别 原理同上，左边为真则右边不执行 C:开发中常用谁? &amp;&amp;,||,! 03 (位运算符的基本用法1)(了解) A:位运算符有哪些 &amp;,|,^,~ ,&gt;&gt;,&gt;&gt;&gt;,&lt;&lt; B:案例演示 位运算符的基本用法1 &amp;,|,^,~ 的用法 &amp;:有0则0 |:有1则1 ^:相同则0，不同则1 ~:按位取反 04 (位异或运算符的特点及面试题)(掌握) A:案例演示 位异或运算符的特点 ^的特点：一个数据对另一个数据位异或两次，该数本身不变。如5^5^10=5，5^10^10=10 B:面试题： 请自己实现两个整数变量的交换（不定义第三方变量） 例子* 05 (位运算符的基本用法2及面试题)(了解) A:案例演示 &gt;&gt;,&gt;&gt;&gt;,&lt;&lt;的用法: &lt;&lt;:左移 左边最高位丢弃，右边补齐0 :右移 最高位是0，左边补齐0;最高为是1，左边补齐1 :无符号右移 无论最高位是0还是1，左边补齐0 最有效率的算出2 * 8的结果 2 &lt;&lt; 3因为操作二进制数最快 06 (三元运算符的基本用法)(掌握) A:三元运算符的格式 (关系表达式) ? 表达式1 : 表达式2; B:三元运算符的执行流程 C:案例演示 获取两个数中的最大值 07 (三元运算符的练习)(掌握) A:案例演示 比较两个整数是否相同 B:案例演示 获取三个整数中的最大值1234567891011121314151617181920212223242526/* * A:案例演示 * 比较两个整数是否相同 * B:案例演示 * 获取三个整数中的最大值 */ //比较两个整数是否相同 /*int x = 10; int y = 10; //boolean b = (x == y) ? true : false; boolean b = (x == y); System.out.println(&quot;b = &quot; + b);*/ //获取三个整数中的最大值 int a = 10; int b = 20; int c = 30; //先比较任意两个数的值,找出这两个数中的最大值 int temp = (a &gt; b) ? a : b; //用前两个数的最大值与第三个数比较,获取最大值 int max = (temp &gt; c) ? temp : c; System.out.println(&quot;max =&quot; + max); 08 (键盘录入的基本格式讲解)(掌握) A:为什么要使用键盘录入数据 a:为了让程序的数据更符合开发的数据 b:让程序更灵活一下 B:如何实现键盘录入呢? 先照格式来。 a:导包 格式： import java.util.Scanner; 位置： 在class上面。 b:创建键盘录入对象 格式： Scanner sc = new Scanner(System.in); c:通过对象获取数据 格式： int x = sc.nextInt(); C:案例演示 键盘录入1个整数，并输出到控制台。 键盘录入2个整数，并输出到控制台。 09 (键盘录入的练习1)(掌握) A:案例演示 键盘录入练习：键盘录入两个数据，并对这两个数据求和，输出其结果 B:案例演示 键盘录入练习：键盘录入两个数据，获取这两个数据中的最大值 10 (键盘录入的练习2)(掌握) A:案例演示 键盘录入练习：键盘录入两个数据，比较这两个数据是否相等 B:案例演示 键盘录入练习：键盘录入三个数据，获取这三个数据中的最大值 11 (顺序结构语句)(了解) A:什么是流程控制语句 流程控制语句：可以控制程序的执行流程。 B:流程控制语句的分类 顺序结构 选择结构 循环结构 C:顺序结构执行流程： 从上往下，依次执行。 D:案例演示 输出几句话看效果即可 12 (选择结构if语句格式1及其使用)(掌握) A:选择结构的分类 if语句 switch语句 B:if语句有几种格式 格式1 格式2 格式3 C:if语句的格式1 if(比较表达式) { 语句体; } D:执行流程： 先计算比较表达式的值，看其返回值是true还是false。 如果是true，就执行语句体； 如果是false，就不执行语句体； 13 (选择结构if语句注意事项)(掌握) A:案例演示 a:比较表达式无论简单还是复杂，结果必须是boolean类型 b:if语句控制的语句体如果是一条语句，大括号可以省略； 如果是多条语句，就不能省略。建议永远不要省略。 c:一般来说：有左大括号就没有分号，有分号就没有左大括号 14 (选择结构if语句格式2及其使用)(掌握) A:if语句的格式2 if(比较表达式) { 语句体1; }else { 语句体2; } B:执行流程： 首先计算比较表达式的值，看其返回值是true还是false。 如果是true，就执行语句体1； 如果是false，就执行语句体2； C:案例演示 a:获取两个数据中较大的值 b:判断一个数据是奇数还是偶数,并输出是奇数还是偶数 注意事项：else后面是没有比较表达式的，只有if后面有。 15 (if语句的格式2和三元的相互转换问题)(掌握) A:案例演示 if语句和三元运算符完成同一个效果 B:案例演示 if语句和三元运算符的区别 三元运算符实现的，都可以采用if语句实现。反之不成立。 什么时候if语句实现不能用三元改进呢? 当if语句控制的操作是一个输出语句的时候就不能。 为什么呢?因为三元运算符是一个运算符，运算符操作完毕就应该有一个结果，而不是一个输出。 16 (选择结构if语句格式3及其使用)(掌握) A:if语句的格式3： if(比较表达式1) { 语句体1; }else if(比较表达式2) { 语句体2; }else if(比较表达式3) { 语句体3; } ... else { 语句体n+1; } B:执行流程： 首先计算比较表达式1看其返回值是true还是false， 如果是true，就执行语句体1，if语句结束。 如果是false，接着计算比较表达式2看其返回值是true还是false， 如果是true，就执行语句体2，if语句结束。 如果是false，接着计算比较表达式3看其返回值是true还是false， 如果都是false，就执行语句体n+1。 C:注意事项:最后一个else可以省略,但是建议不要省略,可以对范围外的错误值提示 17 (选择结构if语句格式3练习)(掌握) A:练习1 需求：键盘录入一个成绩，判断并输出成绩的等级。 90-100 优 80-89 良 70-79 中 60-69 及 0-59 差 B:练习2 需求： 键盘录入x的值，计算出y的并输出。 x&gt;=3 y = 2 * x + 1; -1&lt;x&lt;3 y = 2 * x; x&lt;=-1 y = 2 * x - 1; 18 (选择结构if语句的嵌套使用)(掌握) A:案例演示 需求：获取三个数据中的最大值 if语句的嵌套使用。 19 (选择结构switch语句的格式及其解释)(掌握) A:switch语句的格式 if放的是条件表达式 switch可以接受 1.基本数据类型可以接受:byte，short,char,int(也就是可以转为int计算的比int精度高的不可以) 2.引用数据表达式可以接受枚举（JDK1.5） 、String(1.7) switch(表达式) { case 值1： 语句体1; break; case 值2： 语句体2; break; … default： 语句体n+1; break; } B:switch语句的格式解释 C:面试题 byte可以作为switch的表达式吗? long可以作为switch的表达式吗? String可以作为switch的表达式吗? C:执行流程 先计算表达式的值 然后和case后面的匹配，如果有就执行对应的语句，否则执行default控制的语句 20 (选择结构switch语句的练习)(掌握) A:整数(给定一个值,输出对应星期几) 21 (选择结构switch语句的注意事项)(掌握) A:案例演示 a:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的 b:default可以省略吗? 可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。 特殊情况： case就可以把值固定。 A,B,C,D c:break可以省略吗? 最后一个可以省略,其他最好不要省略 会出现一个现象：case穿透。 最终我们建议不要省略 d:default一定要在最后吗? 不是，可以在任意位置。但是建议在最后。 e:switch语句的结束条件 a:遇到break就结束了 b:执行到switch的右大括号就结束了 22 (选择结构switch语句练习)(掌握) A:看程序写结果： int x = 2; int y = 3; switch(x){ default: y++; break; case 3: y++; case 4: y++; } System.out.println(&quot;y=&quot;+y); 4 B:看程序写结果： int x = 2; int y = 3; switch(x){ default: y++; case 3: y++; case 4: y++; } System.out.println(&quot;y=&quot;+y); 6 23 (选择结构if语句和switch语句的区别)(掌握) A:总结switch语句和if语句的各自使用场景 switch建议判断固定值的时候用 if建议判断区间或范围的时候用 B:案例演示 分别用switch语句和if语句实现下列需求： 键盘录入月份，输出对应的季节]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java面试题相关持续更新]]></title>
      <url>%2F2016%2F11%2F08%2Fjava%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%B8%E5%85%B3%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%2F</url>
      <content type="text"><![CDATA[变量和常量 A:案例演示 面试题:看下面的程序是否有问题，如果有问题，请指出并说明理由。 byte b1 = 3; byte b2 = 4; byte b3 = b1 + b2;（报错，可能损失精度） 从两方面去回答这个题 b1和b2是两个变量,变量里面存储的值都是变化的,所以在程序运行中JVM是无法判断里面具体的值 byte类型的变量在进行运算的时候,会自动类型提升为int类型 byte b4 = 3 + 4;（可以正常运行无错误） 3和4都是常量,java有常量优化机制,就是在编译的的时候直接把3和4的结果赋值给b4了运算符 A:案例演示 请分别计算出a,b,c的值? int a = 10; int b = 10; int c = 10; a = b++; a=10,b=11 c = --a; a=9,c=9 b = ++a; a=10,b=10 a = c--; a=9,c=8 所以最后结果a=9,b=10,c=8 B:案例演示 请分别计算出x,y的值? int x = 4; int y = (x++)+(++x)+(x*10); 4 + 6 + 60 结果x=6，y=70 C:面试题 byte b = 10; 正常 b++; 正常（与下对比正常因为，运算符会有自动强转） b = b + 1; 报错，可能损失精度 问哪句会报错,为什么 D位运算符* 请自己实现两个整数变量的交换（不定义第三方变量） 例子逻辑运算符&amp;&amp;和&amp;的区别 A:案例演示 &amp;&amp;和&amp;的区别? a:最终结果一样。 b:&amp;&amp;具有短路效果。左边是false，右边不执行。 &amp;是无论左边是false还是true,右边都会执行 例子赋值符 A:案例演示 面试题:看下面的程序是否有问题，如果有问题，请指出并说明理由。 short s=1;s = s+1; //报错可能损失精度，因为也要提升为int计算，结果也是int short s=1;s+=1; //正常不报错，s+ 和++一样也会自动加强转符号 选择结构switch语句 A:switch语句的格式 if放的是条件表达式 switch可以接受 1.基本数据类型可以接受:byte，short,char,int(也就是可以转为int计算的比int精度高的不可以) 2.引用数据表达式可以接受枚举（JDK1.5） 、String(1.7) B:面试题 byte可以作为switch的表达式吗? 可以 long可以作为switch的表达式吗?不可以 String可以作为switch的表达式吗?JDK1.7以后版本可以 C:注意事项 a:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的 b:default可以省略吗? 可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。 特殊情况： case就可以把值固定。 如只有A,B,C,D4个选项 c:break可以省略吗? 最后一个可以省略,其他最好不要省略 否则会出现一个现象：case穿透。 最终建议不要省略 d:default一定要在最后吗? 不是，可以在任意位置。但是建议在最后。 e:switch语句的结束条件 a:遇到break就结束了 b:执行到switch的右大括号就结束了 D:两个例子 12345678910111213141516171819202122232425262728* A:看程序写结果：* int x = 2; int y = 3; switch(x)&#123; default: y++; break; case 3: y++; case 4: y++; &#125; System.out.println(&quot;y=&quot;+y); 4 * B:看程序写结果：* int x = 2; int y = 3; switch(x)&#123; default: y++; case 3: y++; case 4: y++; &#125; System.out.println(&quot;y=&quot;+y); 6 E:switch和if各自使用场景 A:总结switch语句和if语句的各自使用场景 switch建议判断固定值的时候用 if建议判断区间或范围的时候用 循环相关 j=1; while(j&lt;999);{ } 注意while条件后面加分号，大括号内的语句就无法执行了。 A:案例演示 三种循环语句的区别: do…while循环至少执行一次循环体。 而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句。 B:案例演示 for循环和while循环的区别： A:如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。不知道用谁就用for循环。因为变量及早的从内存中消失，可以提高内存的使用效率。 C:死循环 (循环结构注意事项之死循环) A:一定要注意控制条件语句控制的那个变量的问题，不要弄丢了，否则就容易死循环。 B:两种最简单的死循环格式 while(true){…} for(;;){…} D:break、continue break跳出循环 continue终止本次循环继续下次循环 E:break,continue综合练习题 for(int x=1; x&lt;=10; x++) { if(x%3==0) { //在此处填写代码 } System.out.println(“Java基础班”); } 我想在控制台输出2次:“Java基础班“ 我想在控制台输出7次:“Java基础班“ 我想在控制台输出13次:“Java基础班“ 12345678 for(int x=1; x&lt;=10; x++) &#123; if(x%3==0) &#123; //break; //我想在控制台输出2次:“Java基础班“ //continue; //我想在控制台输出7次:“Java基础班“ System.out.println(&quot;Java基础&quot;);//我想在控制台输出13次:“Java基础班“ &#125; System.out.println(&quot;Java基础&quot;);&#125; (控制跳转语句return语句) A:return的作用 返回 其实它的作用不是结束循环的，而是结束方法的。 B:案例演示 return和break以及continue的区别? return是结束方法 break是跳出循环 continue是终止本次循环继续下次循环标号12345678910111213//mark 标记outer: for (int i = 1;i &lt;= 10 ;i++ ) &#123; //outer就是标号,只要是合法的标识符即可 System.out.println(&quot;i = &quot; + i); inner: for (int j = 1;j &lt;= 10 ;j++ ) &#123; System.out.println(&quot;j = &quot; + j); break outer;//跳出整个大循环，如果不加跳出一个 &#125;&#125; System.out.println(&quot;大家好&quot;);http://www.heima.com//注意上一行也无错误为标号后面为单行注释System.out.println(&quot;才是真的好&quot;); 数组 输出结果为 [代表几维数组，I代表int类型@固定后面为16进制地址 A:二维数组格式1 int[][] arr = new int[3][2]; A:二维数组格式2 int[][] arr = new int[3][]; arr[0] = new int[3]; arr[1] = new int[5]; B:注意事项 a:以下格式也可以表示二维数组 1:数据类型 数组名[][] = new 数据类型[m][n]; 2:数据类型[] 数组名[] = new 数据类型[m][n]; b:注意下面定义的区别 int x; int y; int x,y; int[] x; int[] y[]; int[] x,y[]; x是一维数组,y是二维数组 Java中的内存分配以及栈和堆的区别 A:栈(掌握) 存储局部变量（引用） 例 int[] arr =new int[3]; arr（引用）在栈，int数组在堆 还有方法 B:堆(掌握) 存储new出来的数组或对象 C:方法区 面向对象部分讲解，简单来说代码区 D:本地方法区 和系统相关 E:寄存器 给CPU使用Java中的参数传递 /*基本数据类型的值传递,不改变原值,因为调用后就会弹栈,局部变量随之消失引用数据类型的值传递,改变原值,因为即使方法弹栈,但是堆内存数组对象还在,可以通过地址继续访问 Java中到底是传值还是传址1,既是传值,也是传地址,基本数据类型传递的值,引用数据类型传递的地址2,java中只有传值,因为地址值也是值(出去面试都说这种,支持者是高司令(java之父)) 面向对象中的一些概念1.面向对象创建一个对象的步骤 A: Student s = new Student(); 1,Student.class加载进内存 2,栈中声明一个Student类型引用s 3,在堆内存创建对象, 4,给对象中属性默认初始化值 5,属性进行显示初始化 6,构造方法进栈,对对象中的属性赋值,构造方法弹栈 7,将对象的地址值赋值给s07.10_面向对象(static关键字的特点)(掌握) A:static关键字的特点 a:随着类的加载而加载 b:优先于对象存在 c:被类的所有对象共享 举例：咱们班级的学生应该共用同一个班级编号。 其实这个特点也是在告诉我们什么时候使用静态? 如果某个成员变量是被所有对象共享的，那么它就应该定义为静态的。 举例： 饮水机(用静态修饰) 水杯(不能用静态修饰) 共性用静态,特性用非静态 d:可以通过类名调用 其实它本身也可以通过对象名调用。 推荐使用类名调用。 静态修饰的内容一般我们称其为：与类相关的，类成员 B:一个类中都是静态方法 如果一个类中方法都是静态的，那要多做一步，创建静态构造函数，目的不让其他类创建本类对象 2.static的注意事项 A:static的注意事项 a:在静态方法中是没有this关键字的 如何理解呢? 静态是随着类的加载而加载，this是随着对象的创建而存在。 静态比对象先存在。 b:静态方法只能访问静态的成员变量和静态的成员方法 静态方法： 成员变量：只能访问静态变量 成员方法：只能访问静态成员方法 非静态方法： 成员变量：可以是静态的，也可以是非静态的 成员方法：可是是静态的成员方法，也可以是非静态的成员方法。 简单记： 静态只能访问静态。 3.静态变量和成员变量的区别 静态变量也叫类变量 成员变量也叫对象变量 A:所属不同 静态变量属于类，所以也称为为类变量 成员变量属于对象，所以也称为实例变量(对象变量) B:内存中位置不同 静态变量存储于方法区的静态区 成员变量存储于堆内存 C:内存出现时间不同 静态变量随着类的加载而加载，随着类的消失而消失 成员变量随着对象的创建而存在，随着对象的消失而消失 D:调用不同 静态变量可以通过类名调用，也可以通过对象调用 成员变量只能通过对 象名调用4.代码块相关 A:代码块概述 在Java中，使用{}括起来的代码被称为代码块。 B:代码块分类 根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。 C:常见代码块的应用 a:局部代码块 在方法中出现；限定变量生命周期，及早释放，提高内存利用率 b:构造代码块 (初始化块) 在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行 c:静态代码块 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，优先于main方法，并且只执行一次。 一般用于加载驱动 A:看程序写结果 class Student { static { System.out.println(&quot;Student 静态代码块&quot;); } { System.out.println(&quot;Student 构造代码块&quot;); } public Student() { System.out.println(&quot;Student 构造方法&quot;); } } class Demo2_Student { static { System.out.println(&quot;Demo2_Student静态代码块&quot;); } public static void main(String[] args) { System.out.println(&quot;我是main方法&quot;); Student s1 = new Student(); Student s2 = new Student(); } } 继承相关1.继承的好处和弊端 A:继承的好处 a:提高了代码的复用性 b:提高了代码的维护性 c:让类与类之间产生了关系，是多态的前提 B:继承的弊端 类的耦合性增强了。 开发的原则：高内聚，低耦合。 耦合：类与类的关系 内聚：就是自己完成某件事情的能力 2.Java中类的继承特点 A:Java中类的继承特点 a:Java只支持单继承，不支持多继承。(一个儿子只能有一个爹) 有些语言是支持多继承，格式：extends 类1,类2,… b:Java支持多层继承(继承体系) B:案例演示 Java中类的继承特点 如果想用这个体系的所有功能用最底层的类创建对象 如果想看这个体系的共性功能,看最顶层的类 3.继承的注意事项和什么时候使用继承 A:继承的注意事项 a:子类只能继承父类所有非私有的成员(成员方法和成员变量) b:子类不能继承父类的构造方法，但是可以通过super(马上讲)关键字去访问父类构造方法。 c:不要为了部分功能而去继承 项目经理 姓名 工号 工资 奖金 程序员 姓名 工号 工资 B:什么时候使用继承 继承其实体现的是一种关系：”is a”。 Person Student Teacher 水果 苹果 香蕉 橘子 采用假设法。 如果有两个类A,B。只有他们符合A是B的一种，或者B是A的一种，就可以考虑使用继承。 4.this和super的区别和应用 A:this和super都代表什么 this:代表当前对象的引用,谁来调用我,我就代表谁 super:代表当前对象父类的引用 B:this和super的使用区别 a:调用成员变量 this.成员变量 调用本类的成员变量,也可以调用父类的成员变量 super.成员变量 调用父类的成员变量 b:调用构造方法 this(…) 调用本类的构造方法 super(…) 调用父类的构造方法 c:调用成员方法 this.成员方法 调用本类的成员方法,也可以调用父类的方法 super.成员方法 调用父类的成员方法 5.继承中构造方法的关系 A:案例演示 子类中所有的构造方法默认都会访问父类中空参数的构造方法 B:为什么呢? 因为子类会继承父类中的数据，可能还会使用父类的数据。 所以，子类初始化之前，一定要先完成父类数据的初始化。 其实： 每一个构造方法的第一条语句默认都是：super() Object类最顶层的父类。 6.继承中构造方法的注意事项 A:案例演示 父类没有无参构造方法,子类怎么办? super解决 this解决 B:注意事项 super(…)或者this(….)必须出现在构造方法的第一条语句上 7.继承中的面试题 A:案例演示 看程序写结果1class Fu{ public int num = 10; public Fu(){ System.out.println(&quot;fu&quot;); }}class Zi extends Fu{ public int num = 20; public Zi(){ System.out.println(&quot;zi&quot;); } public void show(){ int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(super.num); }}class Test1_Extends { public static void main(String[] args) { Zi z = new Zi(); z.show(); }} 看程序写结果2class Fu { static { System.out.println(&quot;静态代码块Fu&quot;); } { System.out.println(&quot;构造代码块Fu&quot;); } public Fu() { System.out.println(&quot;构造方法Fu&quot;); }} class Zi extends Fu { static { System.out.println(&quot;静态代码块Zi&quot;); } { System.out.println(&quot;构造代码块Zi&quot;); } public Zi() { System.out.println(&quot;构造方法Zi&quot;); }} Zi z = new Zi(); 请执行结果。 8.方法重写概述及其应用 A:什么是方法重写 重写:子父类出现了一模一样的方法(注意:返回值类型可以是子父类,这个我们学完面向对象讲) B:方法重写的应用： 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。 C:案例演示 a:定义一个手机类。 9.方法重写的注意事项 A:方法重写注意事项 a:父类中私有方法不能被重写 因为父类私有方法子类根本就无法继承 b:子类重写父类方法时，访问权限不能更低 最好就一致 c:父类静态方法，子类也必须通过静态方法进行重写 其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解(静态只能覆盖静态) 子类重写父类方法的时候，最好声明一模一样。 B:案例演示 方法重写注意事项 10. 方法重写的面试题 A:方法重写的面试题 Override和Overload的区别?Overload能改变返回值类型吗? overload可以改变返回值类型,只看参数列表 方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的 方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。 子类对象调用方法的时候： 先找子类本身，再 找父类。final关键字 A:final概述 B:final修饰特点 修饰类，类不能被继承 修饰变量，变量就变成了常量，只能被赋值一次 一半与public公用如 public static int a; 修饰方法，方法不能被重写 多态class Fu { public void show() { System.out.println(&quot;fu show&quot;); } } class Zi extends Fu { public void show() { System.out.println(&quot;zi show&quot;); } public void method() { System.out.println(&quot;zi method&quot;); } } class Test1Demo { public static void main(String[] args) { Fu f = new Zi(); f.method();//这句有问题不能调用子类特有的方法 f.show(); } } B:看下面程序是否有问题，如果没有，说出结果 class A { public void show() { show2(); } public void show2() { System.out.println(&quot;我&quot;); } } class B extends A { public void show() { show2(); } public void show2() { System.out.println(&quot;爱&quot;); } } class C extends B { public void show() { super.show(); } public void show2() { System.out.println(&quot;你&quot;); } } public class Test2DuoTai { public static void main(String[] args) { A a = new B(); a.show(); B b = new C(); b.show(); } } *输出爱你，因为show方法可以继承下来，第二个因为调用父类show,而show方法调用show2调用的还是子类的show2,所以输出的是你。 抽象相关 A:面试题1 一个抽象类如果没有抽象方法，可不可以定义为抽象类?如果可以，有什么意义? 可以 这么做目的只有一个,就是不让其他类创建本类对象,交给子类完成 B:面试题2 abstract不能和哪些关键字共存 abstract和static不能共存 因为被abstract修饰的方法没有方法体 被static修饰的可以用类名.调用，但是类名.调用抽象方法是没有意义的 abstract和final不能共存 *被abstract修饰的强制子类重写而被final修饰的不让重写 abstract和private *被abstract修饰的是为了让子类看见而private不让子类看见面向对象权限本类 同一个包下(子类和无关类) 不同包下(子类) 不同包下(无关类) private Y默认 Y Yprotected Y Y Ypublic Y Y Y Y面向对象(成员内部类的面试题 A:面试题 要求：使用已知的变量，在控制台输出30，20，10。 class Outer { public int num = 10; class Inner { public int num = 20; public void show() { int num = 30; System.out.println(?); num System.out.println(??); this.num System.out.println(???); Outer.this.num } } } class InnerClassTest { public static void main(String[] args) { Outer.Inner oi = new Outer().new Inner(); oi.show(); } } B ==号和equals方法的区别 ==是一个比较运算符号,既可以比较基本数据类型,也可以比较引用数据类型,基本数据类型比较的是值,引用数据类型比较的是地址值 equals方法是一个方法,只能比较引用数据类型,所有的对象都会继承Object类中的方法,如果没有重写Object类中的equals方法,equals方法和==号比较引用数据类型无区别,重写后的equals方法比较的是对象中的属性 String类 1.判断定义为String类型的s1和s2是否相等 String s1 = &quot;abc&quot;; String s2 = &quot;abc&quot;; System.out.println(s1 == s2); //true 虽然比较的是引用对象，但是String放在常量池里，所以是一样的 System.out.println(s1.equals(s2)); //true 2.下面这句话在内存中创建了几个对象? String s1 = new String(“abc”); //创建了2个，一个是在常量池创建‘“abc”这个对象，另一个是在堆里创建 3.判断定义为String类型的s1和s2是否相等 String s1 = new String(“abc”); String s2 = “abc”; System.out.println(s1 == s2); ? //false 第一个s1是在堆内存中，s2是在常量池中 System.out.println(s1.equals(s2)); ? //true 4.判断定义为String类型的s1和s2是否相等 String s1 = “a” + “b” + “c”; String s2 = “abc”; System.out.println(s1 == s2); ? //true,java中有常量优化机制所以等同于上述1题，指向同一个常量值“abc” System.out.println(s1.equals(s2)); ? //true 5.判断定义为String类型的s1和s2是否相等 String s1 = “ab”; String s2 = “abc”; String s3 = s1 + “c”; System.out.println(s3 == s2); //false 注意s3=s1+”c”;其中s1是变量，并不是常量，由其和“+”符号相连得到的字符串不在常量池，而是在堆内转换的 System.out.println(s3.equals(s2)); ? //true 6.String,StringBuffer,StringBuilder的区别 StringBuffer和StringBuilder的区别 StringBuffer是jdk1.0版本的,是线程安全的,效率低 StringBuilder是jdk1.5版本的,是线程不安全的,效率高 String和StringBuffer,StringBuilder的区别 String是一个不可变的字符序列 StringBuffer,StringBuilder是可变的字符序列 Integer 看程序写结果 Integer i1 = new Integer(97); Integer i2 = new Integer(97); System.out.println(i1 == i2); //false System.out.println(i1.equals(i2)); //true System.out.println(&quot;-----------&quot;); Integer i3 = new Integer(197); Integer i4 = new Integer(197); System.out.println(i3 == i4); //false System.out.println(i3.equals(i4)); //true System.out.println(&quot;-----------&quot;); Integer i5 = 127; //-128-127都可以 Integer i6 = 127; System.out.println(i5 == i6); //true System.out.println(i5.equals(i6)); //true System.out.println(&quot;-----------&quot;); Integer i7 = 128; 大于等于128 Integer i8 = 128; System.out.println(i7 == i8); //false System.out.println(i7.equals(i8)); //true * 上述两个“==”判断结果不同，因为JDK5新特性，有自动装箱机制， * -128-127是byte的取值范围，如果在这个范围就不会创建新的对象 * 但是超过这个范围内就会创建对象了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java语言基础01、常量、进制及转换、数据类型及转换、运算符、赋值符]]></title>
      <url>%2F2016%2F11%2F08%2Fjava%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%8001%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E8%BF%9B%E5%88%B6%E5%8F%8A%E8%BD%AC%E6%8D%A2%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%B5%8B%E5%80%BC%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[01 (常量的概述和使用)(掌握) A:什么是常量 在程序执行的过程中其值不可以发生改变 B:Java中常量的分类 字面值常量 自定义常量(面向对象部分讲) C:字面值常量的分类 字符串常量 用双引号括起来的内容 整数常量 所有整数 小数常量 所有小数 字符常量 用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号 布尔常量 较为特殊，只有true和false 空常量 null(数组部分讲解) D:案例演示 用输出语句输出各种常量。null不演示 02 (进制概述和二,八,十六进制图解)(了解) A:什么是进制 进制：就是进位制，是人们规定的一种进位方法。 对于任何一种进制–X进制，就表示某一位置上的数运算时是逢X进一位。二进制就是逢二进一，八进制是逢八进一，十进制是逢十进一，十六进制是逢十六进一。 例如一周有七天,七进制,一年有十二个月,十二进制 B:十进制的由来 十进制的由来是因为人类有十个手指 C:二进制的由来 其实二进制来源与中国,请看史料记载 18世纪德国数理哲学大师莱布尼兹从他的传教士朋友鲍威特寄给他的拉丁文译本《易经》中，读到了八卦的组成结构，惊奇地发现其基本素数（0）（1），即《易经》的阴爻yao- -和__阳爻，其进位制就是二进制，并认为这是世界上数学进制中最先进的。20世纪被称作第三次科技革命的重要标志之一的计算机的发明与应用，其运算模式正是二进制。它不但证明了莱布尼兹的原理是正确的，同时也证明了《易经》数理学是很了不起的。 D:八进制的由来 任何数据在计算机中都是以二进制的形式存在的。二进制早期由电信号开关演变而来。一个整数在内存中一样也是二进制的，但是使用一大串的1或者0组成的数值进行使用很麻烦。 所以就想把一大串缩短点，将二进制中的三位用一位表示。这三位可以取到的最大值就是7.超过7就进位了，这就是八进制。 E:十六进制的由来 但是对于过长的二进制变成八进制还是较长，所以出现的用4个二进制位表示一位的情况，四个二进制位最大是15，这就是十六进制。 F:不同进制表现同一个数据的形式特点 进制越大，表现形式越短 03 (不同进制数据的表现形式)(掌握) A:二进制的数据表现形式 由0,1组成。以0b(b可以大写也可以小写)开头(JDK1.7版本可以表示二进制了) B:八进制的数据表现形式 由0,1,…7组成。以0开头 C:十进制的数据表现形式 由0,1,…9组成。整数默认是十进制的 D:十六进制的数据表现形式 由0,1,…9,a,b,c,d,e,f(大小写均可)。以0x开头 E:案例演示 输出不同进制表现100的数据。 0b100 0100 100 0x100 04 (任意进制到十进制的转换图解)(了解) A:任意进制到十进制的转换原理 系数：就是每一位上的数据。 基数：X进制，基数就是X。 权：在右边，从0开始编号，对应位上的编号即为该位的权。 结果：把系数*基数的权次幂相加即可。 B:画图练习 二进制–十进制 八进制–十进制 十六进制–十进制 05 (十进制到任意进制的转换图解)(了解) A:十进制到任意进制的转换原理 除积倒取余 结果为111100 B:画图练习 十进制–二进制 十进制–八进制 十进制–十六进制 06 (快速的进制转换法)(了解) A:8421码及特点 8421码是中国大陆的叫法，8421码是BCD代码中最常用的一种。在这种编码方式中每一位二值代码的1都是代表一个固定数值，把每一位的1代表的十进制数加起来，得到的结果就是它所代表的十进制数码。 B:通过8421码的方式进行二进制和十进制的相互转换 C:二进制到八进制的简易方式（每三位变一位，因为2的三次方为8） D:二进制到十六进制的简易方式（每四位变一位，因为2的四次方为16） 07 (原码反码补码)(了解) A:为什么要学习原码反码补码? 后面要学习强制类型转换,如果不知道有原反补会看不懂结果 B:有符号数据表示法的几种方式 原码 就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。 通过一个字节,也就是8个二进制位表示+7和-7 0(符号位) 0000111 1(符号位) 0000111 反码 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码 正数的补码与其原码相同；负数的补码是在其反码的末位加1。 08 (原码反码补码的练习)(了解) A:已知原码求补码 0b10110100 B:已知补码求原码 0b11101110 09 (变量的概述及格式)(掌握) A:什么是变量 在程序执行的过程中，在某个范围内其值可以发生改变的量 B:变量的定义格式 数据类型 变量名 = 变量值; C:为什么要定义变量 用来不断的存放同一类型的常量，并可以重复使用 10 (数据类型的概述和分类)(掌握) A:为什么有数据类型 Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间 B:Java中数据类型的分类 基本数据类型 引用数据类型 面向对象部分讲解 C:基本数据类型分类(4类8种) 整数型 byte 占一个字节 -128到127 short 占两个字 -2^15~2^15-1 int 占四个字节 -2^31~2^31-1 long 占八个字节 -2^63~2^63-1 浮点型 float 占四个字节 -3.403E38~3.403E38 单精度 double 占八个字节-1.798E308~1.798E308 双精度 字符型 char 占两个字节 0~65535 布尔型 boolean boolean理论上是占八分之一个字节,因为一个开关就可以决定是true和false了,但是java中boolean类型没有明确指定他的大小 11 (定义不同数据类型的变量)(掌握) A:案例演示 定义不同基本数据类型的变量，并输出 赋值时候注意float类型,long类型 如果long = 888888888L后加大L float = 3.14f 因为默认整数位int，默认小数为double,不然有可能超出限制 12 (使用变量的注意事项)(掌握) A:案例演示 a:作用域问题 同一个区域不能使用相同的变量名 b:初始化值问题 局部变量在使用之前必须赋值 c:一条语句可以定义几个变量 int a,b,c…; 13 (数据类型转换之隐式转换)(掌握) A:案例演示 a:int + int b:byte + int B:Java中的默认转换规则 取值范围小的数据类型与取值范围大的数据类型进行运算,会先将小的数据类型提升为大的,再运算 C:画图解释byte+int类型的问题 14 (数据类型转换之强制转换)(掌握) A:强制转换问题 int a = 10; byte b = 20; b = a + b;（这样会报错可能损失精度） B:强制转换的格式 b = (byte)(a + b); （如int转byte则去掉前面24位只留8位） C:强制转换的注意事项 如果超出了被赋值的数据类型的取值范围得到的结果会与你期望的结果不同 （只算那8位的值） 15 (面试题之变量相加和常量相加的区别)(掌握) A:案例演示 面试题:看下面的程序是否有问题，如果有问题，请指出并说明理由。 byte b1 = 3; byte b2 = 4; byte b3 = b1 + b2;（报错，可能损失精度） 从两方面去回答这个题 b1和b2是两个变量,变量里面存储的值都是变化的,所以在程序运行中JVM是无法判断里面具体的值 byte类型的变量在进行运算的时候,会自动类型提升为int类型 byte b4 = 3 + 4;（可以正常运行无错误） 3和4都是常量,java有常量优化机制,就是在编译的的时候直接把3和4的结果赋值给b4了 16 (long与float的取值范围谁大谁小)(了解) 进行混合运算的时候,byte,short,char不会相互转换,都会自动类型提升为int类型,其他类型进行混合运算的是小的数据类型提升为大的 byte,short,char – int – long – float – double （即使一个8个字节，一个4个字节但是float村曾IEEE754规范8个指数为范围为1-127~254-127，减127位规定即为2的-126次方到2的126次方所以大于long） long: 8个字节 float：4个字节 IEEE754 4个字节是32个二进制位 1位是符号位 8位是指数位 00000000 11111111 0到255 1到254 -126到127 23位是尾数位 每个指数位减去127 A:它们底层的存储结构不同。 B:float表示的数据范围比long的范围要大 long：2^63-1 float：3.410^38 &gt; 210^38 &gt; 28^38 = 22^3^38 = 2*2^114 &gt; 2^63-1 17 (字符和字符串参与运算)(掌握) A:案例演示 System.out.println(‘a’); System.out.println(‘a’+1); 通过看结果知道’a’的值是多少,由此引出ASCII码表 B:ASCII码表的概述 记住三个值： ‘0’ 48 ‘A’ 65 ‘a’ 97 C:案例演示 System.out.println(“hello”+’a’+1); 输出helloa1 任何数据类型+字符串连接产生新的字符串 System.out.println(‘a’+1+”hello”); 输出98hello 因为从左向右计算 D:+在有字符串参与中被称为字符串连接符 System.out.println(“5+5=”+5+5); 结果 5+5=55,如要正常输出加上括号 System.out.println(5+5+”=5+5”); 输出 10=5+5 18 (char数据类型)(掌握) A:char c = 97; 0到65535 B:Java语言中的字符char可以存储一个中文汉字吗?为什么呢? 可以。因为Java语言采用的是Unicode编码。Unicode编码中的每个字符占用两个字节。中文也是占的两个字节 所以，Java中的字符可以存储一个中文汉字19 (算术运算符的基本用法)(掌握) A:什么是运算符 就是对常量和变量进行操作的符号。 B:运算符的分类 算术运算符，赋值运算符，比较(关系或条件)运算符，逻辑运算符，位运算符，三目(元)运算符 C:算数运算符有哪些 +,-,*,/,%,++,– D:注意事项： a:+号在java中有三种作用,代表正号,做加法运算,字符串的连接符 b:整数相除只能得到整数。如果想得到小数，必须把数据变化为浮点数类型 c:/获取的是除法操作的商，%获取的是除法操作的余数 %运算符 当左边的绝对值小于右边绝对值时,结果是左边 当左边的绝对值等于右边或是右边的倍数时,结果是0 当左边的绝对值大于右边绝对值时,结果是余数 %运算符结果的符号只和左边有关系,与右边无关 任何一个正整数%2结果不是0就是1可以用来当作切换条件 20 (算术运算符++和–的用法)(掌握) A:++,–运算符的作用 自加（++）自减（–）运算 ++:自加。对原有的数据进行+1 –:自减。对原有的数据进行-1 B:案例演示 a:单独使用： 放在操作数的前面和后面效果一样。(这种用法是我们比较常见的) b:参与运算使用： 放在操作数的前面，先自增或者自减，然后再参与运算。 如int a=3; int b; b = ++a; 输出的话b为4,a为4 放在操作数的后面，先参与运算，再自增或者自减。 如int a=3; int b; b = a++; 输出的话b为3,a为4 21 (算术运算符++和–的练习)(掌握) A:案例演示 请分别计算出a,b,c的值? int a = 10; int b = 10; int c = 10; a = b++; a=10,b=11 c = --a; a=9,c=9 b = ++a; a=10,b=10 a = c--; a=9,c=8 所以最后结果a=9,b=10,c=8 B:案例演示 请分别计算出x,y的值? int x = 4; int y = (x++)+(++x)+(x*10); 4 + 6 + 60 结果x=6，y=70 C:面试题 byte b = 10; 正常 b++; 正常（运算符会有自动强转） b = b + 1; 报错，可能损失精度 问哪句会报错,为什么 22 (赋值运算符的基本用法)(掌握) A:赋值运算符有哪些 a:基本的赋值运算符：= 把=右边的数据赋值给左边。 b:扩展的赋值运算符：+=,-=,*=,/=,%= += 把左边和右边做加法，然后赋值给左边。 23 (赋值运算符的面试题)(掌握) A:案例演示 面试题:看下面的程序是否有问题，如果有问题，请指出并说明理由。 short s=1;s = s+1; short s=1;s+=1; 24 (关系运算符的基本用法及其注意事项)(掌握) A:关系运算符有哪些(比较运算符,条件运算符) ==,!=,&gt;,&gt;=,&lt;,&lt;= 注意事项： 无论你的操作是简单还是复杂，结果是boolean类型。 “==”不能写成”=”。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[sqoop从SQLServer导入hdfs]]></title>
      <url>%2F2016%2F11%2F05%2Fsqoop%E4%BB%8ESQLServer%E5%AF%BC%E5%85%A5hdfs%2F</url>
      <content type="text"><![CDATA[##环境准备 1.下载jdbc的sqlserver驱动在HDFS与SqlServer数据库之间导入数据，需要下载jdbc的sqlserver驱动。并将jar文件拷入/var/local/hadoop/sqoop-1.4.6/lib 2.但是这个只是jdbc中SqlServer的驱动，它并不支持HDFS与SqlServer数据库之间数据的传输，还需要下载 SQL Server-Hadoop Connector。解压得到sqoop-sqlserver-1.0目录，并在系统中添加环境变量MSSQL_CONNECTOR_HOME，让它指向sqoop-sqlserver-1.0目录。 3.然后执行sqoop-sqlserver-1.0目录下的install.sh。这个命令会将连接的jar文件和配置文 件拷贝的Sqoop目录中。 ##执行导入进行导入：1sqoop import --connect &apos;jdbc:sqlserver://ip;username=sa;password=123456;database=shifenzheng&apos; --table cdsgus 导入完成后会在/home/username/下产生一个cdsgus文件。 ##注意事项1.使用最新的sqljdbc4.jar2.SqlServer中显示的表的名称为：用户名.表名 jar文件同学提供下载目录：http://download.csdn.net/detail/it_dx/9673929]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最大公约数]]></title>
      <url>%2F2016%2F10%2F15%2F%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%2F</url>
      <content type="text"><![CDATA[一、简述求两个数间的最大公约数，要求传递两个正整形参数，返回值就是他们的最大公约数，需要尽可能的保证性能。 二、方法1：暴力枚举法试图寻找合适的整数i,看看这个数能否被两个整形参数numberA和numberB同时整除。如果较小数字不为较大数字的的公约数，这个整数i可以从2开始循环累加，一直累加到numberA和numberB中较小参数的一半为止。循环结束后，上一次寻找到的能被两个数同时整除的最大值i,就是两个数的最大公约数。12345678910111213141516//暴力破解法 public int gcd1(int numberA,int numberB)&#123; int result=0; int smallNumber = numberA &lt; numberB ? numberA : numberB; int bigNumber = numberA &gt;= numberB ? numberA : numberB; if (bigNumber%smallNumber == 0) return smallNumber; else &#123; for (int i = 2; i &lt;= smallNumber / 2; i++) &#123; if ((smallNumber%i)==0 &amp;&amp; (bigNumber%i)==0)&#123; result = i; &#125; &#125; return result; &#125; &#125; 但这种方法明显不行，效率过于低下，如10000与10001，这样就要计算10000/2-1=4999次。于是我们可以提及另一种方法，详见方法二。 三、方法2：辗转相除法辗转相除法，又名欧几里得算法，目的就是求出两个正整数的最大公约数，这条算法的基于一个定理，两个正整数a和b(假设a&gt;b)，他们的最大公约数等于a除以b的余数c和较小数b之间的最大公约数。比如10和25,25除以10商2余5，那么10和25的最大公约数等同于10和5的最大公约数。基础这条定理，求最大公约数我们就可以运用递归的方法把问题简化了。首先，我们先计算出a除以b的余数c，把问题转化成求出b和c的最大公约数；然后计算出b除以c的余数d，把问题转化成求出c和d的最大公约数；再然后计算出c除以d的余数e，把问题转化成求出d和e的最大公约数。以此类推，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以整除，或者其中一个数减小到1为止。1234567891011//辗转相除法public int gcd2(int numberA,int numberB)&#123; int result = 0; int smallNumber = numberA &lt; numberB ? numberA : numberB; int bigNumber = numberA &gt;= numberB ? numberA : numberB; if(bigNumber%smallNumber==0) return smallNumber; else &#123; return gcd2( smallNumber,bigNumber%smallNumber); &#125;&#125; 但是这样做，假如两个数很大，a%b这样的取模运算性能会比较低，因而又有了另一种方法。 四、方法3：更相减损数更相减损术，出自于中国古代的《九章算术》，也是一种求最大公约数的算法。他的原理更加简单：两个正整数a和b（a&gt;b），它们的最大公约数等于a-b的差值c和较小数b的最大公约数。比如10和25，25减去10的差是15,那么10和25的最大公约数，等同于10和15的最大公约数。由此，我们同样可以通过递归来简化问题。首先，我们先计算出a和b的差值c（假设a&gt;b），把问题转化成求出b和c的最大公约数；然后计算出c和b的差值d（假设c&gt;b），把问题转化成求出b和d的最大公约数；再然后计算出b和d的差值e（假设b&gt;d），把问题转化成求出d和e的最大公约数……以此类推，逐渐把两个较大整数之间的运算简化成两个较小整数之间的运算，直到两个数可以相等为止，最大公约数就是最终相等的两个数。12345678910public int gcd3(int numberA,int numberB)&#123; int result = 0; int smallNumber = numberA &lt; numberB ? numberA : numberB; int bigNumber = numberA &gt;= numberB ? numberA : numberB; if(bigNumber%smallNumber==0) return smallNumber; else &#123; return gcd3( bigNumber-smallNumber,smallNumber ); &#125; &#125; 虽然更相见孙淑的避免了大整数取模的性能问题，已经接近最优。但是更相减损数依靠两个数求差来进行递归，运算的次数肯定远大于辗转相除法的取模方式。如10000和1，就要递归9999次。所以又涉及到了方法4，移位运算法。 五、方法4：移位运算法众所周知，移位运算的性能非常快。对于给定的正整数a和b，不难得到如下的结论。其中gcb(a,b)的意思是a,b的最大公约数函数：当a和b均为偶数，gcb(a,b) = 2gcb(a/2,b/2) = 2gcb(a&gt;&gt;1,b&gt;&gt;1)当a为偶数，b为奇数，gcb(a,b) = gcb(a/2, b) = gcb(a&gt;&gt;1, b)当a为奇数，b为偶数，gcb(a,b) = gcb(a,b/2) = gcb(a,b&gt;&gt;1)当a和b均为奇数，利用更相减损术运算一次，gcb(a,b) =gcb(b, a-b)，此时a-b必然是偶数，又可以继续进行移位运算。比如计算10和25的最大公约数的步骤如下： 0. 整数10通过移位，可以转换成求5和25的最大公约数 0. 利用更相减损法，计算出25-5=20，转换成求5和20的最大公约数 0. 整数20通过移位，可以转换成求5和10的最大公约数 0. 整数10通过移位，可以转换成求5和5的最大公约数 0. 利用更相减损法，因为两数相等，所以最大公约数是5 在两数比较小的时候，暂时看不出计算次数的优势，当两数越大，计算次数的节省就越明显。12345678910111213141516171819//移位运算法 public int gcd4(int numberA,int numberB)&#123; int result = 0; int smallNumber = numberA &lt; numberB ? numberA : numberB; int bigNumber = numberA &gt;= numberB ? numberA : numberB; if(bigNumber%smallNumber==0) return smallNumber; else &#123; if ((smallNumber&amp;1)==0 &amp;&amp; (bigNumber&amp;1)==0) return gcd4( smallNumber&gt;&gt;1,bigNumber&gt;&gt;1 )&lt;&lt;1; else if ((smallNumber&amp;1)==0 &amp;&amp; (bigNumber&amp;1)==1) return gcd4( smallNumber&gt;&gt;1,bigNumber ); else if ((smallNumber&amp;1)==1 &amp;&amp; (bigNumber&amp;1)==0) return gcd4( smallNumber,bigNumber&gt;&gt;1 ); else //都为奇数时候更相减损 return gcd4( smallNumber,bigNumber-smallNumber ); &#125; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux以及win10中VPN的架设]]></title>
      <url>%2F2016%2F09%2F28%2FVPN%2F</url>
      <content type="text"><![CDATA[近期由于常常要跨墙，而lantern免费用户所给予的免费流量对于我来说，显得不是很充足。所以折腾了一下VPN，以低价购买了一个位于洛杉矶的vps。选择centos系统进行配置。同时在校的时候不停的需要网络认证，并且需要花费1元1G的价格，恰好实验室的电脑不需要网费，那么又想办法在win10上搭建VPN服务器，这其中也遇到了很多坑。在此记录下。 一.基于CentOS的Linux下VPN搭建。1.确认vps内的PPP和TUN已经启动。 12cat /dev/ppp cat /dev/net/tun 显示结果为：cat: /dev/ppp: No such device or address和cat: /dev/net/tun: File descriptor in bad state，表明通过，上述两条只要有一个没通过都不行。这些功能默认是不开启的。如果你所购买的VPS有控制面板，请在控制面板内自我手动打开TUN/TAP服务。如果你的供应商没有此选项，你也可以给VPS提供商Submit 一个 Ticket请求开通：12345HelloCould you enabled TUN-TAP for me? I want run pptp-vpn on my VPS.Thank you. 2.确认 PPP 和 TUN 启用后，开始安装 ppp 和 iptables： 1yum install -y ppp iptables 安装pptp:12rpm -ivh http://acelnmp.googlecode.com/files/pptpd-1.3.4-1.rhel5.1.i386.rpm（适用32位系统） rpm -ivh http://acelnmp.googlecode.com/files/pptpd-1.3.4-1.rhel5.1.x86_64.rpm（适用64位系统） 3.配置pptp，编辑/etc/pptpd.conf文件：1vim /etc/pptpd.conf 把下面如图中字段前的#注释去掉：4.编辑/etc/ppp/options.pptpd 文件：1vim /etc/ppp/options.pptpd 去掉ms-dns前面的#，并且使用Google的DNS服务器，修改成付下字段12ms-dns 8.8.8.8 ms-dns 8.8.4.4 5.设置VPN账号密码，编辑/etc/ppp/chap-secrets这个文件：1vim /etc/ppp/chap-secrets 第一列为VPN用户名，第三列为VPN密码，第四列为指定登陆IP，*代表全部。6.修改内核设置，使其支持转发，编辑 /etc/sysctl.conf 文件：1vim /etc/sysctl.conf 将“net.ipv4.ip_forward”的值改为1，同时在“net.ipv4.tcp_syncookies = 1”前面加#7.使 sysctl.conf 配置文件生效并添加 iptables 转发规则：12345678910111213141516171819202122sysctl -p iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j SNAT --to-source ***.***.***.*** (***.***.***.***为你VPS的公网IP地址)保存iptables转发规则：/etc/init.d/iptables save重启 iptables：/etc/init.d/iptables restart重启pptp服务：/etc/init.d/pptpd restart设置开机自动运行pptp服务：chkconfig pptpd on设置开机自动运行iptables服务：chkconfig iptables on 至此，Linux VPS架设VPN完成，如果连接出现错误619则输入如下命令解决：12rm /dev/ppp mknod /dev/ppp c 108 0 如果出现错误734则修改/etc/ppp/options.pptpd文件，在require-mppe-128字段前面加#然后windows客户端连接按下图设置即可。(win10参考着修改即可) 二.Win10内VPN服务器服务器的架设1.在网络共享中心-更改适配器内容-文件-新建传入连接（有些win10可能不能看见这些选项请看后面的方法操作）添加用户中可以添加VPN连接的账号，没问题的话继续下一步。到达如上图步骤的时候开打IPV4，指定你所在局域网内空闲的IP段，并且允许对方呼叫访问自己的局域网。 如果不能上面方法操作,请按如下方法操作：我的电脑-管理-服务和应用程序-服务下开启以下全部服务。 如果以上完成，却无法连入，请开启如下服务：控制面板-程序和功能-启用或关闭Windows功能开启如下服务]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[动态规划讲解以及案例]]></title>
      <url>%2F2016%2F09%2F11%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
      <content type="text"><![CDATA[今天在网上看到一个讲动态规划的文章，是以01背包为例的，这文章和书上的讲解非常不一样，令我眼前一亮，于是转载一下下并且附加了java代码，以及拓展案例～～～原文地址 通过金矿模型介绍动态规划 对于动态规划，每个刚接触的人都需要一段时间来理解，特别是第一次接触的时候总是想不通为什么这种方法可行，这篇文章就是为了帮助大家理解动态规划，并通过讲解基本的01背包问题来引导读者如何去思考动态规划。本文力求通俗易懂，无异性，不让读者感到迷惑，引导读者去思考，所以如果你在阅读中发现有不通顺的地方，让你产生错误理解的地方，让你难得读懂的地方，请跟贴指出，谢谢！ —-第一节—-初识动态规划——– 经典的01背包问题是这样的： 有一个包和n个物品，包的容量为m，每个物品都有各自的体积和价值，问当从这n个物品中选择多个物品放在包里而物品体积总数不超过包的容量m时，能够得到的最大价值是多少？[对于每个物品不可以取多次，最多只能取一次，之所以叫做01背包，0表示不取，1表示取] 为了用一种生动又更形象的方式来讲解此题，我把此题用另一种方式来描述，如下： 有一个国家，所有的国民都非常老实憨厚，某天他们在自己的国家发现了十座金矿，并且这十座金矿在地图上排成一条直线，国王知道这个消息后非常高兴，他希望能够把这些金子都挖出来造福国民，首先他把这些金矿按照在地图上的位置从西至东进行编号，依次为0、1、2、3、4、5、6、7、8、9，然后他命令他的手下去对每一座金矿进行勘测，以便知道挖取每一座金矿需要多少人力以及每座金矿能够挖出多少金子，然后动员国民都来挖金子。 题目补充1：挖每一座金矿需要的人数是固定的，多一个人少一个人都不行。国王知道每个金矿各需要多少人手，金矿i需要的人数为peopleNeeded。 题目补充2：每一座金矿所挖出来的金子数是固定的，当第i座金矿有peopleNeeded人去挖的话，就一定能恰好挖出gold个金子。否则一个金子都挖不出来。 题目补充3：开采一座金矿的人完成开采工作后，他们不会再次去开采其它金矿，因此一个人最多只能使用一次。 题目补充4：国王在全国范围内仅招募到了10000名愿意为了国家去挖金子的人，因此这些人可能不够把所有的金子都挖出来，但是国王希望挖到的金子越多越好。 题目补充5：这个国家的每一个人都很老实（包括国王），不会私吞任何金子，也不会弄虚作假，不会说谎话。 题目补充6：有很多人拿到这个题后的第一反应就是对每一个金矿求出平均每个人能挖出多少金子，然后从高到低进行选择，这里要强调这种方法是错的，如果你也是这样想的，请考虑背包模型，当有一个背包的容量为10，共有3个物品，体积分别是3、3、5，价值分别是6、6、9，那么你的方法取到的是前两个物品，总价值是12，但明显最大值是后两个物品组成的15。 题目补充7：我们只需要知道最多可以挖出多少金子即可，而不用关心哪些金矿挖哪些金矿不挖。 那么，国王究竟如何知道在只有10000个人的情况下最多能挖出多少金子呢？国王是如何思考这个问题的呢？ 国王首先来到了第9个金矿的所在地（注意，第9个就是最后一个，因为是从0开始编号的，最西边的那个金矿是第0个），他的臣子告诉他，如果要挖取第9个金矿的话就需要1500个人，并且第9个金矿可以挖出8888个金子。听到这里国王哈哈大笑起来，因为原先他以为要知道十个金矿在仅有10000个人的情况下最多能挖出多少金子是一件很难思考的问题，但是，就在刚才听完他的臣子所说的那句话时，国王已经知道总共最多能挖出多少金子了，国王是如何在不了解其它金矿的情况下知道最多能挖出多少金子的呢？他的臣子们也不知道这个谜，因此他的臣子们就问他了：“最聪明的国王陛下，我们都没有告诉您其它金矿的情况，您是如何知道最终答案的呢？” 得意的国王笑了笑，然后把他最得意的“左、右手”叫到跟前，说到：“我并不需要考虑最终要挖哪些金矿才能得到最多的金子，我只需要考虑我面前的这座金矿就可以了，对于我面前的这座金矿不外乎仅有两种选择，要么挖，要么不挖，对吧？” “当然，当然”大臣们回答倒。 国王继续说道：“如果我挖取第9座金矿的话那么我现在就能获得8888个金子，而我将用去1500个人，那么我还剩下8500个人。我亲爱的左部下，如果你告诉我当我把所有剩下的8500个人和所有剩下的其它金矿都交给你去开采你最多能给我挖出多少金子的话，那么我不就知道了在第9个金矿一定开采的情况下所能得到的最大金币数吗？” 国王的左部下听后回答道：“国王陛下，您的意思是如果我能用8500个人在其它金矿最多开采出x个金币的话，那您一共就能够获得 x + 8888个金子，对吗？” “是啊，是啊……如果第9座金矿一定开采的话……”大臣们点头说到。 国王笑着继续对着他的右部下说到：“亲爱的右部下，也许我并不打算开采这第9座金矿，那么我依然拥有10000个人，如果我把这10000个人和剩下的金矿都给你的话，你最多能给我挖出多少个金子呢？” 国王的右部下聪明地说道：“尊敬的国王陛下，我明白您的意思了，如果我回答最多能购开采出y个金币的话，那您就可以在y和x+8888之间选择一个较大者，而这个较大者就是最终我们能获得的最大金币数，您看我这样理解对吗？” 国王笑得更灿烂了，问他的左部下：“那么亲爱的左部下，我给你8500个人和其余金矿的话你能告诉我最多能挖出多少金子吗？” “请您放心，这个问题难不倒我”。左部下向国王打包票说到。 国王高兴地继续问他的右部下：“那右部下你呢，如果我给你10000个人和其余金矿的话你能告诉我最多能挖出多少金子吗？” “当然能了！交给我吧！”右部下同左部下一样自信地回答道。 “那就拜托给你们两位了，现在我要回到我那舒适的王宫里去享受了，我期待着你们的答复。”国王说完就开始动身回去等消息了，他是多么地相信他的两个大臣能够给他一个准确的答复，因为国王其实知道他的两位大臣要比他聪明得多。 故事发展到这里，你是否在想国王的这两个大臣又是如何找到让国王满意的答案的呢？他们为什么能够如此自信呢？事实上他们的确比国王要聪明一些，因为他们从国王的身上学到了一点，就是这一点让他们充满了自信。 国王走后，国王的左、右部下来到了第8座金矿，早已在那里等待他们的金矿勘测兵向两位大臣报道：“聪明的两位大臣，您们好，第8座金矿需要1000个人才能开采，可以获得7000个金子”。 因为国王仅给他的左部下8500个人，所以国王的左部下叫来了两个人，对着其中一个人问到：“如果我给你7500个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 然后国王的左部下继续问另一个人：“如果我给你8500个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 国王的左部下在心里想着：“如果他们俩都能回答我的问题的话，那国王交给我的问题不就解决了吗？哈哈哈！” 因为国王给了他的右部下10000个人，所以国王的右部下同样也叫来了两个人，对着其中一个人问：“如果我给你9000个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 然后国王的右部下继续问他叫来的另一个人：“如果我给你10000个人和除了第8、第9的其它所有金矿的话，你能告诉我你最多能挖出多少金子吗？” 此时，国王的右部下同左部下一样，他们都在为自己如此聪明而感到满足。 当然，这四个被叫来的人同样自信地回答没有问题，因为他们同样地从这两个大臣身上学到了相同的一点，而两位自认为自己一样很聪明的大臣得意地笑着回到了他们的府邸，等着别人回答他们提出来的问题，现在你知道了这两个大臣是如何解决国王交待给他们的问题了吗？ 那么你认为被大臣叫去的那四个人又是怎么完成大臣交给他们的问题的呢？答案当然是他们找到了另外八个人！ 没用多少功夫，这个问题已经在全国传开了，更多人的人找到了更更多的人来解决这个问题，而有些人却不需要去另外找两个人帮他，哪些人不需要别人的帮助就可以回答他们的问题呢？ 很明显，当被问到给你z个人和仅有第0座金矿时最多能挖出多少金子时，就不需要别人的帮助，因为你知道，如果z大于等于挖取第0座金矿所需要的人数的话，那么挖出来的最多金子数就是第0座金矿能够挖出来的金子数，如果这z个人不够开采第0座金矿，那么能挖出来的最多金子数就是0，因为这唯一的金矿不够人力去开采。让我们为这些不需要别人的帮助就可以准确地得出答案的人们鼓掌吧，这就是传说中的底层劳动人民！ 故事讲到这里先暂停一下，我们现在重新来分析一下这个故事，让我们对动态规划有个理性认识。 子问题： 国王需要根据两个大臣的答案以及第9座金矿的信息才能判断出最多能够开采出多少金子。为了解决自己面临的问题，他需要给别人制造另外两个问题，这两个问题就是子问题。 思考动态规划的第一点—-最优子结构： 国王相信，只要他的两个大臣能够回答出正确的答案（对于考虑能够开采出的金子数，最多的也就是最优的同时也就是正确的），再加上他的聪明的判断就一定能得到最终的正确答案。我们把这种子问题最优时母问题通过优化选择后一定最优的情况叫做“最优子结构”。 思考动态规划的第二点—-子问题重叠： 实际上国王也好，大臣也好，所有人面对的都是同样的问题，即给你一定数量的人，给你一定数量的金矿，让你求出能够开采出来的最多金子数。我们把这种母问题与子问题本质上是同一个问题的情况称为“子问题重叠”。然而问题中出现的不同点往往就是被子问题之间传递的参数，比如这里的人数和金矿数。 思考动态规划的第三点—-边界： 想想如果不存在前面我们提到的那些底层劳动者的话这个问题能解决吗？永远都不可能！我们把这种子问题在一定时候就不再需要提出子子问题的情况叫做边界，没有边界就会出现死循环。 思考动态规划的第四点—-子问题独立： 要知道，当国王的两个大臣在思考他们自己的问题时他们是不会关心对方是如何计算怎样开采金矿的，因为他们知道，国王只会选择两个人中的一个作为最后方案，另一个人的方案并不会得到实施，因此一个人的决定对另一个人的决定是没有影响的。我们把这种一个母问题在对子问题选择时，当前被选择的子问题两两互不影响的情况叫做“子问题独立”。 这就是动态规划，具有“最优子结构”、“子问题重叠”、“边界”和“子问题独立”，当你发现你正在思考的问题具备这四个性质的话，那么恭喜你，你基本上已经找到了动态规划的方法。 有了上面的这几点，我们就可以写出动态规划的转移方程式，现在我们来写出对应这个问题的方程式，如果用gold[mineNum]表示第mineNum个金矿能够挖出的金子数，用peopleNeeded[mineNum]表示挖第mineNum个金矿需要的人数，用函数f(people,mineNum)表示当有people个人和编号为0、1、2、3、……、mineNum的金矿时能够得到的最大金子数的话，f(people,mineNum)等于什么呢？或者说f(people,mineNum)的转移方程是怎样的呢？ 答案是：当mineNum = 0且people &gt;= peopleNeeded[mineNum]时 f(people,mineNum) = gold[mineNum] 当mineNum = 0且people &lt; peopleNeeded[mineNum]时 f(people,mineNum) = 0 当mineNum != 0时 f(people,mineNum) = f(people-peopleNeeded[mineNum], mineNum-1) + gold[mineNum]与f(people, mineNum-1)中的较大者，前两个式子对应动态规划的“边界”，后一个式子对应动态规划的“最优子结构”请读者弄明白后再继续往下看。 —-第二节—-动态规划的优点——– 现在我假设读者你已经搞清楚了为什么动态规划是正确的方法，但是我们为什么需要使用动态规划呢？请先继续欣赏这个故事： 国王得知他的两个手下使用了和他相同的方法去解决交代给他们的问题后，不但没有认为他的两个大臣在偷懒，反而很高兴，因为他知道，他的大臣必然会找更多的人一起解决这个问题，而更多的人会找更更多的人，这样他这个聪明的方法就会在不经意间流传开来，而全国人民都会知道这个聪明的方法是他们伟大的国王想出来的，你说国王能不高兴吗？ 但是国王也有一些担忧，因为他实在不知道这个“工程”要动用到多少人来完成，如果帮助他解决这个问题的人太多的话那么就太劳民伤财了。“会不会影响到今年的收成呢？”国王在心里想着这个问题，于是他请来了整个国家里唯一的两个数学天才，一个叫做小天，另一个叫做小才。 国王问小天：“小天啊，我发觉这个问题有点严重，我知道其实这可以简单的看成一个组合问题，也就是从十个金矿中选取若干个金矿进行开采，看看哪种组合得到的金子最多，也许用组合方法会更好一些。你能告诉我一共有多少种组合情况吗？” “国王陛下，如果用组合方法的话一共要考虑2的10次方种情况，也就是1024种情况。”小天思考了一会回答到。 “嗯……，如果每一种情况我交给一个人去计算能得到的金子数的话，那我也要1024个人，其实还是挺多的。”国王好像再次感觉到了自己的方法是正确的。 国王心理期待着小才能够给它一个更好的答案，问到：“小才啊，那么你能告诉我用我的那个方法总共需要多少人吗？其实，我也计算过，好像需要的人数是1+2+4+8+16+32+64+……，毕竟每一个人的确都需要找另外两个人来帮助他们……” 不辜负国王的期待，小才微笑着说到：“亲爱的国王陛下，其实我们并不需要那么多人，因为有很多问题其实是相同的，而我们只需要为每一个不同的问题使用一个人力便可。” 国王高兴的问到：“此话如何讲？” “打个比方，如果有一个人需要知道1000个人和3个金矿可以开采出多少金子，同时另一个人也需要知道1000个人和3个金矿可以开采出多少金子的话，那么他们可以去询问相同的一个人，而不用各自找不同的人浪费人力了。” 国王思考着说到：“嗯，很有道理，如果问题是一样的话那么就不需要去询问两个不同的人了，也就是说一个不同的问题仅需要一个人力，那么一共有多少个不同的问题呢？” “因为每个问题的人数可以从0取到10000，而金矿数可以从0取到10，所以最多大约有10000 * 10 等于100000个不同的问题。” 小才一边算着一边回答。 “什么？十万个问题？十万个人力？”国王有点失望。 “请国王放心，事实上我们需要的人力远远小于这个数的，因为不是每一个问题都会遇到，也许我们仅需要一、两百个人力就可以解决这个问题了，这主要和各个金矿所需要的人数有关。” 小才立刻回答到。 故事的最后，自然是国王再一次向他的臣民们证明了他是这个国家里最聪明的人，现在我们通过故事的第二部分来考虑动态规划的另外两个思考点。 思考动态规划的第五点—-做备忘录： 正如上面所说的一样，当我们遇到相同的问题时，我们可以问同一个人。讲的通俗一点就是，我们可以把问题的解放在一个变量中，如果再次遇到这个问题就直接从变量中获得答案，因此每一个问题仅会计算一遍，如果不做备忘的话，动态规划就没有任何优势可言了。 思考动态规划的第六点—-时间分析： 正如上面所说，如果我们用穷举的方法，至少需要2^n个常数时间，因为总共有2^n种情况需要考虑，如果在背包问题中，包的容量为1000，物品数为100，那么需要考虑2^100种情况,这个数大约为10的30次方。 而如果用动态规划，最多大概只有1000*100 = 100000个不同的问题，这和10的30次方比起来优势是很明显的。而实际情况并不会出现那么多不同的问题，比如在金矿模型中，如果所有的金矿所需人口都是1000个人，那么问题总数大约只有100个。 非正式地，我们可以很容易得到动态规划所需时间，如果共有questionCount个相同的子问题，而每一个问题需要面对chooseCount种选择时，我们所需时间就为questionCount chooseCount个常数。在金矿模型中，子问题最多有大概people n 个(其中people是用于开采金矿的总人数，n是金矿的总数)，因此questionCount = people n，而就像国王需要考虑是采用左部下的结果还是采用右部下的结果一样，每个问题面对两个选择，因此chooseCount = 2,所以程序运行时间为 T = O(questionCount chooseCount) =O(people * n)，别忘了实际上需要的时间小于这个值，根据所遇到的具体情况有所不同。 这就是动态规划的魔力，它减少了大量的计算，因此我们需要动态规划！ —-第三节—-动态规划的思考角度———- 那么什么是动态规划呢？我个人觉得，如果一个解决问题的方法满足上面六个思考点中的前四个，那么这个方法就属于动态规划。而在思考动态规划方法时，后两点同样也是需要考虑的。 面对问题要寻找动态规划的方法，首先要清楚一点，动态规划不是算法，它是一种方法，它是在一件事情发生的过程中寻找最优值的方法，因此，我们需要对这件事情所发生的过程进行考虑。而通常我们从过程的最后一步开始考虑，而不是先考虑过程的开始。 打个比方，上面的挖金矿问题，我们可以认为整个开采过程是从西至东进行开采的（也就是从第0座开始），那么总有面对最后一座金矿的时候（第9座），对这座金矿不外乎两个选择，开采与不开采，在最后一步确定时再去确定倒数第二步，直到考虑第0座金矿（过程的开始）。 而过程的开始，也就是考虑的最后一步，就是边界。 因此在遇到一个问题想用动态规划的方法去解决时，不妨先思考一下这个过程是怎样的，然后考虑过程的最后一步是如何选择的，通常我们需要自己去构造一个过程，比如后面的练习。 —-第四节—-总结——- 那么遇到问题如何用动态规划去解决呢？根据上面的分析我们可以按照下面的步骤去考虑： 1、构造问题所对应的过程。 2、思考过程的最后一个步骤，看看有哪些选择情况。 3、找到最后一步的子问题，确保符合“子问题重叠”，把子问题中不相同的地方设置为参数。 4、使得子问题符合“最优子结构”。 5、找到边界，考虑边界的各种处理方式。 6、确保满足“子问题独立”，一般而言，如果我们是在多个子问题中选择一个作为实施方案，而不会同时实施多个方案，那么子问题就是独立的。 7、考虑如何做备忘录。 8、分析所需时间是否满足要求。 9、写出转移方程式。 —-第五节—-练习——- 题目一：买书 有一书店引进了一套书，共有3卷，每卷书定价是60元，书店为了搞促销，推出一个活动，活动如下： 如果单独购买其中一卷，那么可以打9.5折。 如果同时购买两卷不同的，那么可以打9折。 如果同时购买三卷不同的，那么可以打8.5折。 如果小明希望购买第1卷x本，第2卷y本，第3卷z本，那么至少需要多少钱呢？（x、y、z为三个已知整数）。 当然，这道题完全可以不用动态规划来解，但是现在我们是要学习动态规划，因此请想想如何用动态规划来做？ 答案： 1、过程为一次一次的购买，每一次购买也许只买一本（这有三种方案），或者买两本（这也有三种方案），或者三本一起买（这有一种方案），最后直到买完所有需要的书。 2、最后一步我必然会在7种购买方案中选择一种，因此我要在7种购买方案中选择一个最佳情况。 3、子问题是，我选择了某个方案后，如何使得购买剩余的书能用最少的钱？并且这个选择不会使得剩余的书为负数。母问题和子问题都是给定三卷书的购买量，求最少需要用的钱，所以有“子问题重叠”，问题中三个购买量设置为参数，分别为i、j、k。 4、的确符合。 5、边界是一次购买就可以买完所有的书，处理方式请读者自己考虑。 6、每次选择最多有7种方案，并且不会同时实施其中多种，因此方案的选择互不影响，所以有“子问题独立”。 7、我可以用minMoney[j][k]来保存购买第1卷i本，第2卷j本，第3卷k本时所需的最少金钱。 8、共有x y z 个问题，每个问题面对7种选择，时间为：O( x y z 7) = O( x y z )。 9、用函数MinMoney(i,j,k)来表示购买第1卷i本，第2卷j本，第3卷k本时所需的最少金钱，那么有： MinMoney(i,j,k)=min(s1,s2,s3,s4,s5,s6,s7),其中s1,s2,s3,s4,s5,s6,s7分别为对应的7种方案使用的最少金钱： s1 = 60 0.95 + MinMoney(i-1,j,k) s2 = 60 0.95 + MinMoney(i,j-1,k) s3 = 60 0.95 + MinMoney(i,j,k-1) s4 = (60 + 60) 0.9 + MinMoney(i-1,j-1,k) s5 = (60 + 60) 0.9 + MinMoney(i-1,j,k-1) s6 = (60 + 60) 0.9 + MinMoney(i-1,j,k-1) s7 = (60 + 60 + 60) 0.85 + MinMoney(i-1,j-1,k-1) —-第六节—-代码参考—— 下面提供金矿问题的程序源代码帮助读者理解，并提供测试数据给大家练习。 输入文件名为“beibao.in”，因为这个问题实际上就是背包问题，所以测试数据文件名就保留原名吧。 输入文件第一行有两个数，第一个是国王可用用来开采金矿的总人数，第二个是总共发现的金矿数。 输入文件的第2至n+1行每行有两个数，第i行的两个数分别表示第i-1个金矿需要的人数和可以得到的金子数。 输出文件仅一个整数，表示能够得到的最大金子数。 输入样例： 100 5 77 92 22 22 29 87 50 46 99 90 输出样例： 133 java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * Created by FangHeart on 2016/9/11. */public class DongTaiGuihuaJinKuang &#123; int peopleTotal;//可以用于挖金子的人数 int n;//金矿数 int peopleNeed[] = new int[100];//每座金矿需要的人数 int gold[] = new int[100];//每座金矿能够挖出来的金子数 int maxGold[][] = new int[10000][100];//保存了i个人挖前j个金矿能够得到的最大金子数，等于-1时表示未知 int retMaxGold;//能得到的最大金子数 public void goldCaiji()&#123; init(); System.out.println( getMaxGold(peopleTotal,n-1 ) ); &#125; public void init()&#123; try &#123; FileInputStream fileInputStream = new FileInputStream( "F:\\IDEAProject\\算法\\src\\top\\fangheart\\Algorithm\\String\\jinkuang.in" ); InputStreamReader inputStreamReader = new InputStreamReader( fileInputStream,"utf-8" ); BufferedReader bufferedReader = new BufferedReader( inputStreamReader,512 ); String s; String a[] = bufferedReader.readLine().split( " " ); //总人数 peopleTotal = Integer.parseInt( a[0] ); //矿山数 n = Integer.parseInt( a[1] ); int i = 0; while((s=bufferedReader.readLine())!=null)&#123; a = null; a = s.split( " " ); peopleNeed[i] = Integer.parseInt( a[0] ); gold[i] = Integer.parseInt( a[1] ); i++; &#125; for (int j = 0; j &lt;= peopleTotal; j++) &#123; for (int k = 0; k &lt;n; k++) &#123; maxGold[j][k] = -1;//等于-1时表示未知 [对应动态规划中的“做备忘录”] &#125; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //获得在仅有people个人和前mineNum个金矿时能够得到的最大金子数，注意“前多少个”也是从0开始编号的 public int getMaxGold(int people, int minNum)&#123; //如果这个问题曾经计算过 [对应动态规划中的“做备忘录”] if (maxGold[people][minNum] != -1)&#123; //获得保存起来的值 retMaxGold = maxGold[people][minNum]; &#125;else if (minNum==0)&#123;//如果仅有一个金矿时 [对应动态规划中的“边界”] //如果仅有一个金矿时 [对应动态规划中的“边界”] if (people&gt;=peopleNeed[minNum])&#123; //得到的最大值就是这座金矿的金子数 retMaxGold = gold[minNum]; &#125;else &#123;//人数不足时候 retMaxGold = 0; &#125; &#125;else if (people &gt;= peopleNeed[minNum])&#123;//不是边界并且人数充足 retMaxGold = Math.max( getMaxGold( people - peopleNeed[minNum],minNum-1 ) + gold[minNum], getMaxGold( people,minNum-1 )); &#125;else&#123;//否则给出的人不够开采这座金矿 [对应动态规划中的“最优子结构”] //仅考虑不开采的情况 retMaxGold = getMaxGold( people,minNum - 1 ); &#125; //做备忘录 maxGold[people][minNum] = retMaxGold; return retMaxGold; &#125;&#125; 扩展简单动态规划求两个字符串的最大子串（2016.09美团免试题）如字符串1 asrfdsdadgfdsf字符串2 asdsdsdadhgj输出 dsdad 这样即使想获得最大子字符串的长度也很容易12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Created by FangHeart on 2016/9/11. *//** * 用动态规划算法求解 最长公共子串 * */public class DongTaiGuiHuaZuiChangZiChuan&#123; public static String getLCSLength(String s,String t)&#123; int p = s.length() ; int q = t.length(); String[][] num = new String[p][q]; char char1 = '\0'; char char2 = '\0' ; int len = 0 ; String lcs = ""; for(int i = 0;i&lt;p ;i++)&#123; for(int j=0;j&lt;q;j++)&#123; char1 = s.charAt(i); char2 = t.charAt(j); if(char1 != char2)&#123; num[i][j] = ""; &#125;else &#123; if(i==0 ) num[i][j] = String.valueOf(char1) ; else if(j ==0)num[i][j] = String.valueOf(char2); else num[i][j] = num[i-1][j-1] +String.valueOf(char1) ; if(num[i][j].length() &gt; len)&#123; len = num[i][j].length(); lcs = num[i][j]; &#125;else if(num[i][j].length() == len)&#123; lcs = lcs +","+num[i][j] ;//也有可能多个最大子字符串 &#125; &#125; &#125; &#125; return lcs ; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[多种排序总结]]></title>
      <url>%2F2016%2F08%2F29%2F%E5%A4%9A%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[闲来无事，复习下算法，对各种经典的排序算法进行初步的总结。巩固下基础，同时为将来找工作做下准备，也作为我博客正式发文的开端。 所有排序默认从小到大。时间复杂度详见总结。 一、选择排序（Selectionsort)选择排序（Selectionsort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。例如a[] = {112,123,12,23,234,345,435,345,21,2};第一个循环只能将最小的数字2放到第一位，然后第二次循环，12放到第二位。 123456789101112131415161718void selectSort(int *a,int n) &#123; int i,j,k,temp; for(i=0;i&lt;n-1;i++) &#123; k=i; /*给记号赋值*/ for(j=i+1;j&lt;n;j++) if(a[k]&gt;a[j]) k=j; /*是k总是指向最小元素*/ if(i!=k) &#123; /*当k!=i是才交换，否则a[i]即为最小*/ temp=a[i]; a[i]=a[k]; a[k]=temp; &#125; &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536package top.fangheart.Algorithm.sort;/** * Created by FangHeart on 2016/8/29. */public class SelectSort &#123; int a[] = &#123;112,123,12,23,234,345,435,345,21,2&#125;; int i,j,k,t; public void sort()&#123; System.out.println("初始数组为:"); for (int l = 0; l &lt; 10; l++) &#123; System.out.print(a[l]+ " "); &#125; System.out.print("\n"); for (int i = 0; i &lt; 9; i++) &#123; k = i; for (int j = i+1; j &lt; 10; j++) &#123; if (a[j]&lt;a[k]) k =j; if (i!=k)&#123; t = a[i]; a[i] = a[k]; a[k] = t; &#125; &#125; System.out.print("第"+i+"次排序后:"); for (int l = 0; l &lt; 10; l++) &#123; System.out.print(a[l]+ " "); &#125; System.out.print("\n"); &#125; &#125;&#125; 二、冒泡排序（Bubble Sort）冒泡排序算法的运作如下：比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。1234567891011121314151617181920void bubbleSort()&#123; int i,j,t; int a[6] = &#123;71,5,7,10,6,2&#125;; for(i = 0; i &lt; 6 - 1;i++)&#123; for(j = 0; j &lt; 6 - 1 - i; j++)&#123; if(a[j] &gt; a[j+1])&#123; t = a[j]; a[j] = a[j+1]; a[j+1] = t; &#125; &#125; &#125; printf("冒泡排序后:"); for(i = 0 ; i &lt; 6; i++)&#123; printf("%d ",a[i]); &#125;&#125; 12345678910111213141516171819public void sort()&#123; int a[] = &#123;123,124,454356,132,1234,2354&#125;; int temp; int n = a.length; for (int i = 0; i &lt; n-1; i++) &#123; for (int j = 0; j &lt; n-1-i; j++) &#123; if(a[j] &gt; a[j+1])&#123; temp = a[j]; a[j] = a[j+1]; a[j+1] = temp; &#125; &#125; &#125; System.out.println("排序后:"); for (int i = 0; i &lt; n; i++) &#123; System.out.printf(a[i] + " "); &#125; &#125; 三、插入排序(InsertSort)插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 步骤： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果被扫描的元素（已排序）大于新元素，将该元素后移一位 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 具体过程如下图所示： 12345678910111213141516void insertSort(int a[],int n)&#123; int i=0,j; int temp; for (i=1;i&lt;n;i++) &#123; temp = a[i]; j = i - 1; while (j&gt;=0&amp;&amp;temp&lt;a[j]) &#123; a[j+1] = a[j]; j--; &#125; a[j+1] = temp; &#125;&#125; 1234567891011121314151617int a[]=&#123;2,1,7,8,4,6,5,9,3,0&#125;; int i,j; int temp; public void sort()&#123; for(i=1;i&lt;a.length;i++)&#123; temp=a[i]; j = i-1; while(j&gt;=0&amp;&amp;temp&lt;a[j])&#123; a[j+1] = a[j]; j--; &#125; a[j+1]=temp; &#125; for(int m=0;m&lt;a.length;m++)&#123; System.out.print(a[m]+" "); &#125; &#125; 四、简单桶排序(BucketSort)桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。 1234567891011121314151617181920212223void bucketSort()&#123; int n,book[1000],i,j,t; for (i = 0; i &lt;= 1000; i++)&#123; book[i] = 0; &#125; printf("请输入排序个数n:"); scanf("%d", &amp;n); printf("请输入数字(排序数字需要小于1000):"); for (i = 0 ; i &lt; n; i++)&#123; scanf("%d ",&amp;t); book[t]++; &#125; for(i = 0; i &lt;= 1000; i++)&#123; for(j = 0; j &lt; book[i]; j++) printf("%d",i); &#125; &#125; 12345678910111213141516171819202122public void sort()&#123; int n; int book[] = new int[1000]; for(int i = 0; i &lt; 1000; i++)&#123; book[i] = 0; &#125; Scanner scanner = new Scanner(System.in); System.out.println("请输入排序的个数n:"); n = scanner.nextInt(); System.out.println("请输入小于1000的" + n + "个数:"); for(int i = 0; i &lt; n; i++)&#123; int t =scanner.nextInt(); book[t]++; &#125; System.out.println("经过排序后"); for(int i = 0; i &lt; 1000; i++) for(int j = 0; j &lt; book[i]; j++) &#123; System.out.println(i + " "); &#125; &#125; 五、快速排序(QuickSort)快速排序通常明显比同为Ο(nlogn)的其他算法更快，因此常被采用，而且快排采用了分治法的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。 步骤： 1.从数列中挑出一个元素作为基准数（一般为第一个数）。2.分区过程，将比基准数大的放到右边，小于或等于它的数都放到左边。（注意这个过程先从右到左比较，再从左到右）3.再对左右区间递归执行第二步，直至各区间只有一个数。123456789101112131415161718192021222324252627282930void quickSort(int a[],int left,int right)&#123; int i,j,t,temp; if(left &gt; right) return; temp = a[left]; i = left; j = right; while(i!=j)&#123; while(a[j]&gt;=temp &amp;&amp; i &lt;j)&#123; j--; &#125; while(a[i]&lt;=temp &amp;&amp; i &lt;j)&#123; i++; &#125; if(i&lt;j)&#123; t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; a[left] = a[i]; a[i] = temp; quickSort(a,left,i-1); quickSort(a,i+1,right); &#125; 12345678910111213141516171819202122232425262728293031323334public int a[] = &#123;456,124,454356,132,1234,2354&#125;; public void sort(int left,int right)&#123; int i,j,t,temp; i = left; j = right; if (left &gt; right) return; temp = a[left]; while (i != j)&#123; while (a[j]&gt;=temp &amp;&amp; i&lt;j)&#123; j--; &#125; while (a[i]&lt;=temp &amp;&amp; i&lt;j)&#123; i++; &#125; if (i &lt; j)&#123; t = a[i]; a[i] = a[j]; a[j] =t; &#125; &#125; a[left] = a[i]; a[i] = temp; sort(left,i-1); sort(i+1,right); &#125; public void print()&#123; for (int k = 0; k &lt; a.length; k++) &#123; System.out.print(a[k] + " "); &#125; &#125; 六、堆排序(HeapSort)堆是一种特殊的树形数据结构，其每个节点都有一个值，通常提到的堆都是指一颗完全二叉树，根结点的值小于（或大于）两个子节点的值，同时，根节点的两个子树也分别是一个堆。堆排序就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根节点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中次大的值。如此反复执行，便能得到一个有序序列了。堆排序的实现需要解决的两个关键问题：（1）将一个无序序列构成一个堆。（2）输出堆顶元素后，调整剩余元素成为一个新堆。12345678910111213141516171819202122232425262728293031323334353637public class HeapSort &#123; /** * 构建大顶堆 */ public static void adjustHeap(int[] a, int i, int len) &#123; int temp, j; temp = a[i]; for (j = 2 * i; j &lt; len; j *= 2) &#123;// 沿关键字较大的孩子结点向下筛选 if (j &lt; len &amp;&amp; a[j] &lt; a[j + 1]) ++j; // j为关键字中较大记录的下标 if (temp &gt;= a[j]) break; a[i] = a[j]; i = j; &#125; a[i] = temp; &#125; public static void heapSort(int[] a) &#123; int i; for (i = a.length / 2 - 1; i &gt;= 0; i--) &#123;// 构建一个大顶堆 adjustHeap(a, i, a.length - 1); &#125; for (i = a.length - 1; i &gt;= 0; i--) &#123;// 将堆顶记录和当前未经排序子序列的最后一个记录交换 int temp = a[0]; a[0] = a[i]; a[i] = temp; adjustHeap(a, 0, i - 1);// 将a中前i-1个记录重新调整为大顶堆 &#125; &#125; public static void main(String[] args) &#123; int a[] = &#123; 51, 46, 20, 18, 65, 97, 82, 30, 77, 50 &#125;; heapSort(a); System.out.println(Arrays.toString(a)); &#125;&#125; 七、希尔排序(ShellSort)希尔排序也成为“缩小增量排序”，其基本原理是，现将待排序的数组元素分成多个子序列，使得每个子序列的元素个数相对较少，然后对各个子序列分别进行直接插入排序，待整个待排序列“基本有序”后，最后在对所有元素进行一次直接插入排序。因此，我们要采用跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。希尔排序是对直接插入排序算法的优化和升级。 所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小的基本在中间，例如｛2,1,3,6,4,7,5,8,9｝就可以称为基本有序了。但像｛1,5,9,3,7,8,2,4,6｝这样，9在第三位，2在倒数第三位就谈不上基本有序。 123456789101112131415161718192021222324252627282930public static void shellSortSmallToBig(int[] data) &#123; int j = 0; int temp = 0; for (int increment = data.length / 2; increment &gt; 0; increment /= 2) &#123; System.out.println("increment:" + increment); for (int i = increment; i &lt; data.length; i++) &#123; // System.out.println("i:" + i); temp = data[i]; for (j = i - increment; j &gt;= 0; j -= increment) &#123; // System.out.println("j:" + j); // System.out.println("temp:" + temp); // System.out.println("data[" + j + "]:" + data[j]); if (temp &lt; data[j]) &#123; data[j + increment] = data[j]; &#125; else &#123; break; &#125; &#125; data[j + increment] = temp; &#125; for (int i = 0; i &lt; data.length; i++) System.out.print(data[i] + " "); &#125; &#125; public static void main(String[] args) &#123; int[] data = new int[] &#123; 26, 53, 67, 48, 57, 13, 48, 32, 60, 50 &#125;; shellSortSmallToBig(data); System.out.println(Arrays.toString(data)); &#125; 八、归并排序(MergeSort)归并排序是利用递归与分治技术将数据序列化分成越来越小的半子表，再对班子表排序，最后再用递归方法将排序好的半子表合并成越来越大的有序列表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class MergeSort &#123; /** * 归并排序 * 简介:将两个（或两个以上）有序表合并成一个新的有序表 即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列 * 时间复杂度为O(nlogn) * 稳定排序方式 * @param nums 待排序数组 * @return 输出有序数组 */ public static int[] sort(int[] nums, int low, int high) &#123; int mid = (low + high) / 2; if (low &lt; high) &#123; // 左边 sort(nums, low, mid); // 右边 sort(nums, mid + 1, high); // 左右归并 merge(nums, low, mid, high); &#125; return nums; &#125; public static void merge(int[] nums, int low, int mid, int high) &#123; int[] temp = new int[high - low + 1]; int i = low;// 左指针 int j = mid + 1;// 右指针 int k = 0; // 把较小的数先移到新数组中 while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (nums[i] &lt; nums[j]) &#123; temp[k++] = nums[i++]; &#125; else &#123; temp[k++] = nums[j++]; &#125; &#125; // 把左边剩余的数移入数组 while (i &lt;= mid) &#123; temp[k++] = nums[i++]; &#125; // 把右边边剩余的数移入数组 while (j &lt;= high) &#123; temp[k++] = nums[j++]; &#125; // 把新数组中的数覆盖nums数组 for (int k2 = 0; k2 &lt; temp.length; k2++) &#123; nums[k2 + low] = temp[k2]; &#125; &#125; // 归并排序的实现 public static void main(String[] args) &#123; int[] nums = &#123; 2, 7, 8, 3, 1, 6, 9, 0, 5, 4 &#125;; MergeSort.sort(nums, 0, nums.length-1); System.out.println(Arrays.toString(nums)); &#125; &#125; 总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MarkDown语法]]></title>
      <url>%2F2016%2F08%2F29%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
      <content type="text"><![CDATA[MarkDown语法1. 排版1234567891011121314151617**粗体** *斜体* ~~这是一段错误的文本。~~引用:&gt; 引用Leanote官方的话, 为什么要做Leanote, 原因是...有充列表: 1. 支持Vim 2. 支持Emacs无序列表: - 项目1 - 项目2 上述写法效果如下：粗体 斜体 这是一段错误的文本。 引用: 引用Leanote官方的话, 为什么要做Leanote, 原因是… 有充列表: 支持Vim 支持Emacs 无序列表: 项目1 项目2 2. 图片与链接123456789图片:![网络方式](http://ocef6bnjz.bkt.clouddn.com/images/hexo0422.jpg)![路径方式](/img/banner.jpg)链接:**提示**, 如果想对图片的宽度和高度进行控制, 你也可以通过img标签, 如:&lt;img src=&quot;http://leanote.com/images/logo/leanote_icon_blue.png&quot; width=&quot;50px&quot; /&gt;[这是我的博客的链接](http://fangheart.top) 链接: 这是我的博客的链接 3. 标题以下是各级标题, 最多支持5级标题 123456# h1## h2### h3#### h4##### h4###### h5 4. 代码示例: function get(key) { return m[key]; } 代码高亮示例: 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 1234567class Employee: empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 5. Markdown 扩展Markdown 扩展支持: 表格 定义型列表 Html 标签 脚注 目录 时序图与流程图 MathJax 公式 5.1 表格12345678910111213Item | Value-------- | ---Computer | \$1600Phone | \$12Pipe | \$1可以指定对齐方式, 如Item列左对齐, Value列右对齐, Qty列居中对齐| Item | Value | Qty || :------- | ----: | :---: || Computer | \$1600 | 5 || Phone | \$12 | 12 || Pipe | \$1 | 234 | Item Value Computer \$1600 Phone \$12 Pipe \$1 可以指定对齐方式, 如Item列左对齐, Value列右对齐, Qty列居中对齐 Item Value Qty Computer \$1600 5 Phone \$12 12 Pipe \$1 234 5.2 定义型列表名词 1: 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 5.3 Html 标签支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：12345678910111213&lt;table&gt; &lt;tr&gt; &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt; &lt;th&gt;星期一&lt;/th&gt; &lt;th&gt;星期二&lt;/th&gt; &lt;th&gt;星期三&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;/td&gt; &lt;td&gt;张明&lt;/td&gt; &lt;td&gt;王平&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 5.4 时序图与流程图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob–&gt;Alice: I am good thanks! 流程图: 12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 提示: 更多关于时序图与流程图的语法请参考: 时序图语法 流程图语法 5.7 MathJax 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。 $$ 表示整行公式： $$\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$ $$\sum^{j-1}{k=0}{\widehat{\gamma}{kj} z_k}$$ 更复杂的公式:$$\begin{eqnarray}\vec\nabla \times (\vec\nabla f) &amp; = &amp; 0 \cdots\cdots梯度场必是无旋场\\vec\nabla \cdot(\vec\nabla \times \vec F) &amp; = &amp; 0\cdots\cdots旋度场必是无散场\\vec\nabla \cdot (\vec\nabla f) &amp; = &amp; {\vec\nabla}^2f\\vec\nabla \times(\vec\nabla \times \vec F) &amp; = &amp; \vec\nabla(\vec\nabla \cdot \vec F) - {\vec\nabla}^2 \vec F\\end{eqnarray}$$ 访问 MathJax 参考更多使用方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F08%2F23%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo命令以及主题]]></title>
      <url>%2F2016%2F08%2F10%2Fhexo%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E4%B8%BB%E9%A2%98%2F</url>
      <content type="text"><![CDATA[hexo new page “名字” 建新的分类页面hexo n “name” 创建新的文章hexo s 开启本地服务hexo clean 删除当前信息hexo g 生成新的信息hexo d 上传到github jacman menu 默认没有启用 /tags 和 /categories 页面，如果需要启用请在博客目录下的source文件夹中分别建立tags和categories文件夹每个文件夹中分别包含一个index.md文件。内容为：layout: tags (或categories) title: tags (或categories)新建文章内 tags: test或者如下123tags: - test - test1 如果用vno主题新建的文章 tags: [test]这样写tag标签可看到]]></content>
    </entry>

    
  
  
</search>
